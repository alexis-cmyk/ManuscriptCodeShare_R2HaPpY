---
title: "pTyrSiteLevel"
author: "Alexis Chang"
date: "`r Sys.Date()`"
output: console
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#I. LIBRARIES
```{r}
library(tidyverse)
library(janitor)
library(readr)
library(gridExtra)
library(ggrepel)
library(cowplot)
library(reshape2)
library(eulerr)
library(protti)
library(iq)
library(RColorBrewer)
library(biomaRt)
#for PCA loadings
library(FactoMineR)

#for protti sample correlation and volcano plots
library(dendextend)
library(pheatmap)
library(seriation)
library(UpSetR)

#for GO enrichments
library(gprofiler2)

#for c-means clustering
library(e1071)

#for motif logos
library(ggseqlogo)

library(limma)

# install.packages("conflicted")
library(conflicted)
conflicted::conflicts_prefer(dplyr::select)
conflicted::conflicts_prefer(dplyr::rename)
conflicts_prefer(dplyr::filter)

```
Katarina Vlajic uses mfuzz for cmeans clustering per the Olsen paper: https://bioconductor.org/packages/release/bioc/html/Mfuzz.html
https://bioconductor.org/packages/release/bioc/vignettes/Mfuzz/inst/doc/Mfuzz.pdf
BioconductorBioconductor
Mfuzz
The Mfuzz package implements noise-robust soft clustering of omics time-series data, including transcriptomic, proteomic or metabolomic data. It is based on the use of c-means clustering. For convenience, it includes a graphical user interface. (318 kB)

##_b) functions
###---alexis_theme()
```{r}
alexis_theme <- function() {
  theme(
    # panel.border = element_rect(colour = "blue", fill = NA, linetype = 2),
    panel.border = element_blank(),
    panel.background = element_blank(),
    panel.grid.major.x  = element_blank(),
    panel.grid.minor = element_blank(),
    # axis.text.x = element_text(angle = 90, vjust = 0.25, hjust = 1),
    axis.text.x = element_text(angle = 0, vjust = 0.0, hjust = 0.5),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(colour = "black", face = "plain", family = "sans", size = 14),
    axis.title = element_text(colour = "black", family = "sans", size = 14),
    axis.ticks = element_line(colour = "black"),
    title = element_text(size = 8, hjust = 0.5),
    strip.text = element_text(size= 12, family = "sans"),
    # legend at the bottom 6)
    legend.position = "right")   
}

```

###---my_qc_cvs
```{r}
my_qc_cvs <- function (data,
                       grouping,
                       condition,
                       intensity,
                       plot = TRUE,
                       plot_style = "density",
                       max_cv = 200,
                       xlab = "condition",
                       showlegend = FALSE,
                       yintercept = 25){
  
  
  protti_colours <- "placeholder"
  utils::data("protti_colours", envir = environment())
  
  
  #-----------------------------------------------------------------------------------  
  if (plot == FALSE) {
    
    
    if (max(dplyr::pull(data, {{intensity}}), na.rm = TRUE) < 1000) {
      stop(strwrap("Please backtransform your data or use raw values.\nThe function does not handle log2 transformed data.", 
                   prefix = "\n", initial = ""))  }
    
    
    result <- data %>% dplyr::distinct({{grouping}}, {{condition}}, {{intensity}}) %>%
      tidyr::drop_na({{intensity}}) %>%
      dplyr::group_by({{grouping}}) %>%
      dplyr::mutate(cv_combined = (stats::sd({{intensity}})/mean({{intensity}})) * 100) %>%
      dplyr::group_by({{condition}}, {{grouping}}) %>%
      dplyr::mutate(cv = (stats::sd({{intensity}})/mean({{intensity}})) * 100) %>%
      dplyr::distinct({{condition}}, {{grouping}}, .data$cv_combined, .data$cv) %>%
      tidyr::drop_na() %>%
      dplyr::group_by({{condition}}) %>%
      dplyr::mutate(median_cv = stats::median(.data$cv)) %>% 
      dplyr::ungroup() %>%
      dplyr::mutate(median_cv_combined = stats::median(.data$cv_combined)) %>% 
      dplyr::select(-{{grouping}}, -c("cv_combined", "cv")) %>%
      dplyr::distinct() 
    return(result)  }  
  
  ##-----------------------------------------------------------------------------------   
  if (plot == TRUE) {
    if (max(dplyr::pull(data, {{intensity}}), na.rm = TRUE) < 1000) {
      stop(strwrap("Please backtransform your data or use raw values.\nThe function does not handle log2 transformed data.", 
                   prefix = "\n", initial = ""))}
    
    result <- data %>%
      dplyr::distinct({{grouping}}, {{condition}}, {{intensity}}) %>%
      tidyr::drop_na({{intensity}}) %>%
      
      dplyr::group_by({{grouping}}) %>%
      dplyr::mutate(
        cv_combined = (stats::sd({{intensity}})/mean({{intensity}})) * 100) %>%
      
      
      dplyr::group_by({{condition}}, {{grouping}}) %>%
      dplyr::mutate(cv = (stats::sd({{intensity}})/mean({{intensity}})) * 100) %>%
      dplyr::ungroup() %>%
      
      dplyr::distinct({{condition}}, {{grouping}}, .data$cv_combined, .data$cv) %>%
      tidyr::drop_na() %>%
      tidyr::pivot_longer(cols = starts_with("cv"), names_to = "type", values_to = "values") %>%
      dplyr::mutate(type = ifelse(.data$type =="cv", {{condition}}, "all")) %>%
      dplyr::mutate(type = forcats::fct_relevel(as.factor(.data$type),"all")) %>%
      dplyr::select(-{{condition}}) %>%
      dplyr::group_by(.data$type) %>%
      dplyr::mutate(median = stats::median(.data$values)) %>% 
      dplyr::distinct()
    
    if (max(result$values) > max_cv) {
      cv_too_high <- result %>%
        dplyr::filter(.data$values >max_cv) %>%
        nrow()
      
      warning(paste(cv_too_high), " values were exluded from the plot (CV > ",max_cv, " %)")  }
    
    
    
    ##-----------------------------------------------------------------------------------      
    if (plot_style == "boxplot") {
      plot <- ggplot2::ggplot(result) +
        ggplot2::geom_boxplot(aes(x = .data$type, y = .data$values, fill = .data$type), na.rm = TRUE, size = 1, show.legend = showlegend,
                              alpha   = 0.5, outlier.alpha = 0.5, outlier.shape = 21) + 
        ggplot2::labs(
          # title = "Coefficients of variation",
          y = "Coefficient of variation [%]", fill = "Condition") + 
        ggplot2::geom_hline(yintercept = {{yintercept}}, linetype = 1, size = 0.75, alpha = 0.3) +
        ggplot2::scale_y_continuous(limits = c(0, max_cv)) + 
        scale_fill_brewer(palette = "Dark2") +
        # ggplot2::scale_fill_manual(values = c("grey",protti_colours)) +
        alexis_theme() +
        xlab({{xlab}})
      # ggplot2::theme(plot.title = ggplot2::element_text(size = 20),
      #                axis.title.x = ggplot2::element_text(size = 15), 
      #                axis.text.y = ggplot2::element_text(size = 15),
      #                axis.text.x = ggplot2::element_text(size = 12,angle = 75, hjust = 1),
      #                axis.title.y = ggplot2::element_text(size = 15), 
      #                legend.title = ggplot2::element_text(size = 15),
      #                legend.text = ggplot2::element_text(size = 15))
      return(plot)
    }
    
    ##-----------------------------------------------------------------------------------    
    if (plot_style == "density") {
      plot <- ggplot2::ggplot(result) +
        ggplot2::geom_density(ggplot2::aes(x = .data$values, col = .data$type), size = 1, na.rm = TRUE, show.legend = showlegend) + 
        ggplot2::labs(
          # title = "Coefficients of variation",
          x = "Coefficient of variation [%]", y = "Density", color = "Condition") +
        ggplot2::scale_x_continuous(limits = c(0,max_cv)) +
        geom_vline(data = dplyr::distinct(result,  .data$median, .data$type),
                   ggplot2::aes(xintercept = median, col = .data$type),
                   size = 1,
                   linetype = "dashed", 
                   show.legend = FALSE) +
        scale_fill_brewer(palette = "Dark2") +
        # ggplot2::scale_color_manual(values = c("grey",protti_colours)) +
        alexis_theme() +
        xlab(xlab)
      # ggplot2::theme(plot.title = ggplot2::element_text(size = 20), 
      #                axis.title.x = ggplot2::element_text(size = 15),
      #                axis.text.y = ggplot2::element_text(size = 15),
      #                axis.text.x = ggplot2::element_text(size = 12, angle = 75, hjust = 1),
      #                axis.title.y = ggplot2::element_text(size = 15),
      #                legend.title = ggplot2::element_text(size = 15),
      #                legend.text = ggplot2::element_text(size = 15))
      
      return(plot)
      
    }
    
    ##-----------------------------------------------------------------------------------
    if (plot_style == "violin") {
      
      plot <- ggplot2::ggplot(result, aes(x = .data$type, 
                                          y = .data$values, fill = .data$type)) +
        ggplot2::geom_violin(na.rm = TRUE, size = 1) + 
        ggplot2::geom_boxplot(width = 0.15, fill = "white", na.rm = TRUE, alpha = 0.6, size = 0.75, outlier.color = NA) +
        ggplot2::labs(
          # title = "Coefficients of variation",
          x = "", y = "Coefficient of variation [%]",
          fill = "Condition") +
        ggplot2::geom_hline(yintercept = {{yintercept}}, linetype = 1, size = 0.75, alpha = 0.3) +
        ggplot2::scale_y_continuous(limits = c(0, max_cv)) +
        # ggplot2::scale_fill_manual(values = c("grey",  protti_colours)) +
        scale_fill_brewer(palette = "Dark2") +
        alexis_theme() +
        xlab(xlab)
      # ggplot2::theme_bw() +
      # ggplot2::theme(plot.title = ggplot2::element_text(size = 20),
      #                axis.title.x = ggplot2::element_text(size = 15),
      #                axis.text.y = ggplot2::element_text(size = 15), 
      #                axis.text.x = ggplot2::element_text(size = 12, angle = 75, hjust = 1), axis.title.y = ggplot2::element_text(size = 15),
      #                legend.title = ggplot2::element_text(size = 15), 
      #                legend.text = ggplot2::element_text(size = 15))
      
      return(plot)
      
    }
  }
}
```


###---hierarchical clustering
```{r}
my_hier_cluster <- function (data,
                             sample,
                             grouping,
                             intensity_log2,
                             condition_order_for_colors = c("EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"),
                             breaklist = seq(0.5, 1, by = 0.1),
                             condition,
                             digestion = NULL, 
                             run_order = NULL, 
                             method = "spearman", 
                             fontsize_number = 14,
                             number_color = "white",
                             cell_height = 20, 
                             interactive = FALSE) 
{
  
  protti_colours <- "placeholder"
  
  utils::data("protti_colours", envir = environment())
  
  viridis_colours <- "placeholder"
  
  utils::data("viridis_colours", envir = environment())
  
  
  
  
  correlation <- data %>%
    dplyr::distinct({{sample}}, {{grouping}}, {{intensity_log2}}) %>%
    tidyr::pivot_wider(names_from = { {sample}},
                       values_from = {{intensity_log2}}) %>%
    tibble::column_to_rownames(var = rlang::as_name(enquo(grouping))) %>% 
    stats::cor(method = {{method}}, use = "complete.obs")
  
  
  
  
  annotation <- data %>%
    dplyr::mutate(`:=`({{condition}}, as.character({{condition}}))) %>%
    dplyr::distinct({{sample}}, {{condition}}, {{digestion}}, {{run_order}}) %>%
    tibble::column_to_rownames(var = rlang::as_name(enquo(sample)))
  
  n_conditions <- 0
  n_digest <- 0
  n_run_ord <- 0
  conditions_colour <- c()
  digest_colours <- c()
  run_ord_colours <- c()
  
  
  
  #changed this section to allow custom ordering of conditions for coloring. added new variable condition_order_for_colors.
  if (!missing(condition)) {
    # conditions <- unique(dplyr::pull(annotation, {{condition}}))
    # n_conditions <- length(conditions)
    conditions <- {{condition_order_for_colors}}
    n_conditions <- length(conditions)
    conditions_colours <- protti_colours[1:n_conditions]
    names(conditions_colours) <- conditions
  }
  
  
  
  
  
  
  if (!missing(digestion)) {
    digest <- unique(dplyr::pull(annotation, {{digestion}}))
    n_digest <- length(digest)
    digest_colours <- protti_colours[(n_conditions + 1):(n_digest + 
                                                           n_conditions)]
    names(digest_colours) <- digest
  }
  
  
  
  
  
  if (!missing(run_order)) {
    colfunc <- grDevices::colorRampPalette(c("#0D0887", 
                                             "#2E0595", "#46039F", "#5C01A6", "#7201A8", "#8707A6", 
                                             "#9A169F", "#AC2694", "#BC3587", "#CA457A", "#D6556D", 
                                             "#E26561", "#EB7655", "#F48849", "#FA9B3D", "#FDAF31", 
                                             "#FDC527", "#F9DC24", "#F0F921"))
    run_ord <- unique(dplyr::pull(annotation, {
      {
        run_order
      }
    }))
    n_run_ord <- length(run_ord)
    run_ord_colours <- colfunc(n_run_ord)
    names(run_ord_colours) <- run_ord
  }
  
  
  
  
  annotation_colours <- list(conditions_colours, digest_colours, run_ord_colours)
  
  
  names(annotation_colours) <- c(if (!missing(condition)) {
    rlang::as_name(enquo(condition))
  } else {
    "condition"
  }, if (!missing(digestion)) {
    rlang::as_name(enquo(digestion))
  } else {
    "digestion"
  }, if (!missing(run_order)) {
    rlang::as_name(enquo(run_order))
  } else {
    "run_order"
  })
  
  
  
  
  
  #interactive -----------------------------------------------------------------------------------
  
  if (interactive == TRUE) {
    if (!requireNamespace("heatmaply", quietly = TRUE)) {
      message("Package \"heatmaply\" is needed for this function to work. Please install it.", 
              call. = FALSE)
      return(invisible(NULL))
    }
    heatmap_interactive <- heatmaply::heatmaply(correlation, 
                                                main = "Correlation based hirachical clustering of samples", 
                                                col_side_colors = annotation, col_side_palette = c(annotation_colours[[1]], 
                                                                                                   annotation_colours[[2]], annotation_colours[[3]]),
                                                display_numbers(round(correlation, 2)),
                                                k_col = NA, k_row = NA, plot_method = "plotly")
    return(heatmap_interactive)
  }
  
  
  
  
  
  #not interactive ----------------------------------------------------------------------------------
  
  if (interactive == FALSE) {
    dependency_test <- c(dendextend = !requireNamespace("dendextend", 
                                                        quietly = TRUE),
                         pheatmap = !requireNamespace("pheatmap", 
                                                      quietly = TRUE), seriation = !requireNamespace("seriation", quietly = TRUE))
    if (any(dependency_test)) {
      
      dependency_name <- names(dependency_test[dependency_test ==  TRUE])
      
      if (length(dependency_name) == 1) {
        message("Package \"", paste(dependency_name), "\" is needed for this function to work. Please install it.", call. = FALSE)
        return(invisible(NULL))
      }
      
      else {
        message("Packages \"", paste(dependency_name, collapse = "\" and \""), "\" are needed for this function to work. Please install them.", call. = FALSE)
        return(invisible(NULL))
      }
    }
    
    
    distance <- stats::dist(correlation)
    
    hierachical_clustering <- stats::hclust(distance)
    
    dendrogram <- stats::as.dendrogram(hierachical_clustering)
    
    dendrogram_row <- dendextend::seriate_dendrogram(dendrogram, 
                                                     distance, method = "OLO")
    
    dendrogram_column <- dendextend::rotate(dendrogram_row, 
                                            order = rev(labels(distance)[seriation::get_order(stats::as.hclust(dendrogram_row))]))
    
    #actual heatmap with cell labels, not interactive -------------------------------------------------------
    heatmap_static <- pheatmap::pheatmap(correlation,
                                         cluster_rows = stats::as.hclust(dendrogram_row), 
                                         cluster_cols = stats::as.hclust(dendrogram_column), 
                                         # display_numbers = TRUE,
                                         display_numbers = round(correlation,2),  #annotations within column, can change to asterisks, see above
                                         # display_numbers = FALSE,  #annotations within column, can change to asterisks, see above
                                          #can change df = correlation to a variable to allow either matrix or filtered matrix input, such as for asterixes, etc.
                                         number_color = {{number_color}}, #in-cell annotations
                                         fontsize_number = {{fontsize_number}}, #fontsize of in-cell annotations
                                         annotation = annotation,
                                         annotation_colors = annotation_colours, 
                                         main = "Correlation based hierachical clustering of samples", 
                                         #modified color and added breaks variables to control heatmap coloring and intervals.
                                         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length({{breaklist}})),
                                          breaks = {{breaklist}}, silent = TRUE)
                                         # color = viridis_colours, silent = TRUE)
    return(heatmap_static)
  }
}

```


###---hierarchical clustering no numbers
```{r}
my_hier_cluster_noNUMS <- function (data,
                             sample,
                             grouping,
                             intensity_log2,
                             condition_order_for_colors = c("EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"),
                             breaklist = seq(0.5, 1, by = 0.1),
                             condition,
                             digestion = NULL, 
                             run_order = NULL, 
                             method = "spearman", 
                             fontsize_number = 14,
                             # number_color = "white",
                             cell_height = 20, 
                             interactive = FALSE) 
{
  
  protti_colours <- "placeholder"
  
  utils::data("protti_colours", envir = environment())
  
  viridis_colours <- "placeholder"
  
  utils::data("viridis_colours", envir = environment())
  
  
  
  
  correlation <- data %>%
    dplyr::distinct({{sample}}, {{grouping}}, {{intensity_log2}}) %>%
    tidyr::pivot_wider(names_from = { {sample}},
                       values_from = {{intensity_log2}}) %>%
    tibble::column_to_rownames(var = rlang::as_name(enquo(grouping))) %>% 
    stats::cor(method = {{method}}, use = "complete.obs")
  
  
  
  
  annotation <- data %>%
    dplyr::mutate(`:=`({{condition}}, as.character({{condition}}))) %>%
    dplyr::distinct({{sample}}, {{condition}}, {{digestion}}, {{run_order}}) %>%
    tibble::column_to_rownames(var = rlang::as_name(enquo(sample)))
  
  n_conditions <- 0
  n_digest <- 0
  n_run_ord <- 0
  conditions_colour <- c()
  digest_colours <- c()
  run_ord_colours <- c()
  
  
  
  #changed this section to allow custom ordering of conditions for coloring. added new variable condition_order_for_colors.
  if (!missing(condition)) {
    # conditions <- unique(dplyr::pull(annotation, {{condition}}))
    # n_conditions <- length(conditions)
    conditions <- {{condition_order_for_colors}}
    n_conditions <- length(conditions)
    conditions_colours <- protti_colours[1:n_conditions]
    names(conditions_colours) <- conditions
  }
  
  
  
  
  
  
  if (!missing(digestion)) {
    digest <- unique(dplyr::pull(annotation, {{digestion}}))
    n_digest <- length(digest)
    digest_colours <- protti_colours[(n_conditions + 1):(n_digest + 
                                                           n_conditions)]
    names(digest_colours) <- digest
  }
  
  
  
  
  
  if (!missing(run_order)) {
    colfunc <- grDevices::colorRampPalette(c("#0D0887", 
                                             "#2E0595", "#46039F", "#5C01A6", "#7201A8", "#8707A6", 
                                             "#9A169F", "#AC2694", "#BC3587", "#CA457A", "#D6556D", 
                                             "#E26561", "#EB7655", "#F48849", "#FA9B3D", "#FDAF31", 
                                             "#FDC527", "#F9DC24", "#F0F921"))
    run_ord <- unique(dplyr::pull(annotation, {
      {
        run_order
      }
    }))
    n_run_ord <- length(run_ord)
    run_ord_colours <- colfunc(n_run_ord)
    names(run_ord_colours) <- run_ord
  }
  
  
  
  
  annotation_colours <- list(conditions_colours, digest_colours, run_ord_colours)
  
  
  names(annotation_colours) <- c(if (!missing(condition)) {
    rlang::as_name(enquo(condition))
  } else {
    "condition"
  }, if (!missing(digestion)) {
    rlang::as_name(enquo(digestion))
  } else {
    "digestion"
  }, if (!missing(run_order)) {
    rlang::as_name(enquo(run_order))
  } else {
    "run_order"
  })
  
  
  
  
  
  #interactive -----------------------------------------------------------------------------------
  
  if (interactive == TRUE) {
    if (!requireNamespace("heatmaply", quietly = TRUE)) {
      message("Package \"heatmaply\" is needed for this function to work. Please install it.", 
              call. = FALSE)
      return(invisible(NULL))
    }
    heatmap_interactive <- heatmaply::heatmaply(correlation, 
                                                main = "Correlation based hirachical clustering of samples", 
                                                col_side_colors = annotation, col_side_palette = c(annotation_colours[[1]], 
                                                                                                   annotation_colours[[2]], annotation_colours[[3]]),
                                                display_numbers(round(correlation, 2)),
                                                k_col = NA, k_row = NA, plot_method = "plotly")
    return(heatmap_interactive)
  }
  
  
  
  
  
  #not interactive ----------------------------------------------------------------------------------
  
  if (interactive == FALSE) {
    dependency_test <- c(dendextend = !requireNamespace("dendextend", 
                                                        quietly = TRUE),
                         pheatmap = !requireNamespace("pheatmap", 
                                                      quietly = TRUE), seriation = !requireNamespace("seriation", quietly = TRUE))
    if (any(dependency_test)) {
      
      dependency_name <- names(dependency_test[dependency_test ==  TRUE])
      
      if (length(dependency_name) == 1) {
        message("Package \"", paste(dependency_name), "\" is needed for this function to work. Please install it.", call. = FALSE)
        return(invisible(NULL))
      }
      
      else {
        message("Packages \"", paste(dependency_name, collapse = "\" and \""), "\" are needed for this function to work. Please install them.", call. = FALSE)
        return(invisible(NULL))
      }
    }
    
    
    distance <- stats::dist(correlation)
    
    hierachical_clustering <- stats::hclust(distance)
    
    dendrogram <- stats::as.dendrogram(hierachical_clustering)
    
    dendrogram_row <- dendextend::seriate_dendrogram(dendrogram, 
                                                     distance, method = "OLO")
    
    dendrogram_column <- dendextend::rotate(dendrogram_row, 
                                            order = rev(labels(distance)[seriation::get_order(stats::as.hclust(dendrogram_row))]))
    
    #actual heatmap with cell labels, not interactive -------------------------------------------------------
    heatmap_static <- pheatmap::pheatmap(correlation,
                                         cluster_rows = stats::as.hclust(dendrogram_row), 
                                         cluster_cols = stats::as.hclust(dendrogram_column), 
                                         # display_numbers = TRUE,
                                         # display_numbers = round(correlation,2),  #annotations within column, can change to asterisks, see above
                                         display_numbers = FALSE,  #annotations within column, can change to asterisks, see above
                                          #can change df = correlation to a variable to allow either matrix or filtered matrix input, such as for asterixes, etc.
                                         # number_color = {{number_color}}, #in-cell annotations
                                         # fontsize_number = {{fontsize_number}}, #fontsize of in-cell annotations
                                         annotation = annotation,
                                         annotation_colors = annotation_colours, 
                                         main = "Correlation based hierachical clustering of samples", 
                                         #modified color and added breaks variables to control heatmap coloring and intervals.
                                         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length({{breaklist}})),
                                          breaks = {{breaklist}}, silent = TRUE)
                                         # color = viridis_colours, silent = TRUE)
    return(heatmap_static)
  }
}

```




###---my volcano plot

#II. FASTAs
```{r}
human_fasta_2024 <- read_csv("raw_data/MainFig3to6_SuppFig9to15/sp_reviewed_UP000005640_2024_03_21_forR.csv")


#just to convert PTMSEA gene names to uniprot ID references
fasta_gene_names <- read_tsv(file = "raw_data/MainFig3to6_SuppFig9to15/uniprotkb_proteome_UP000005640_2024_09_04.tsv") %>%
  clean_names() %>% 
  #many gene names per uniprot reference, hope first gene name matches,
  #otherwise figure out if secondary matches improve join.
  separate(gene_names, into = c("gene", "gene2", "gene3", "gene4", "gene5", "gene6"), remove = FALSE)

fasta_subcellular_location <- read_tsv("raw_data/MainFig3to6_SuppFig9to15/uniprotkb_proteome_UP000005640_2024_10_16_locations.txt") %>% clean_names() %>% 
  rename(reference = entry) %>% 
  filter(grepl("HUMAN", sequence) == FALSE) #remove titin which was annotated oddly


#fasta with functions, subcellular component and cellular location.
fxns_fasta <- read_tsv(file = "raw_data/MainFig3to6_SuppFig9to15/fxns_UP000005640_2024_11_05.tsv") %>% clean_names() %>% 
  rename(gene_names = gene)
```
##_a. overlap between FASTAs
```{r}
overlap_human_FASTA2024_gene_names <- fasta_gene_names %>%
  mutate(fasta_gene_names = TRUE) %>% 
  rename(reference = entry) %>% 
  left_join(y = human_fasta_2024 %>% separate(gene, into =c("gene", "org_del"), sep = "_") %>% select(-org_del) %>% mutate(human_2024 = TRUE),
            by = "reference") %>% 
  mutate(
    length_check = case_when(
      length.x == length.y ~ "match",
      TRUE ~ "different"),
    gene_check = case_when(
      gene.x == gene.y ~ "match",
      TRUE ~ "different") ) %>% 
  group_by(gene.x) %>% 
  mutate(n_unique_references_fasta_gene_names = n_distinct(reference, na.rm = TRUE)) %>% 
  ungroup()


# so the overlap is poor! 
#gene name from FASTA gene names better matches the PSP and PTMSigDB databases. 
#however, protein sequence lengths can be different between the two FASTAs even for the same gene. 
```


#III. PSITE LISTS
##_a. PSP all p-sites
```{r}
# PSP_all <- read_csv(file = "raw_data/MainFig3to6_SuppFig9to15/Phosphorylation_site_dataset/Phosphorylation_site_dataset.csv") %>% clean_names() %>%
#   filter(organism == "human") %>% 
#   mutate(mod_rsd = str_replace_all(mod_rsd, "-p", ""),
#          mod_res = str_sub(mod_rsd, end = 1L)) %>% 
#   rename(psite = mod_rsd) %>% 
#   mutate(gene_ref = paste(gene, psite, sep = "_"))

# write_csv(x = PSP_all, file = "raw_data/MainFig3to6_SuppFig9to15/PSP_all_psites.csv")

PSP_all <- read_csv ("raw_data/MainFig3to6_SuppFig9to15/PSP_all_psites.csv")
```
###___ i. total pY sites in PSP for context
```{r}
total_pY_inPSP <- PSP_all %>% 
  filter(mod_res == "Y") %>% 
  distinct(gene_ref)
```


##_b. PTM-SEA EGFR phosphopathway
comes only with gene, mod res and mod residue. need to append a reference.
495 total entries to start
410 for only pY sites
2766 entries after joining to ascore_gene_names FASTA likely due to multiple gene names per reference.
2750 entries after keeping only matches to human_fasta_2024.
742 entries when keeping only the entries for which mod residue matches expected Y. 
  ^ 405 unique pY sites, meaning 5 of the gene names and mod sites didn't match to protein sequence.
then join to PSP_EGFR dataset. Then collapse to unique gene and mod_res (removing duplicated gene or reference names)
keep gene.x as gene (MAPK1, not MK01)
 
```{r}
EGFR1_pathway_PTMSigDB <- read_csv("raw_data/MainFig3to6_SuppFig9to15/EGFR1_phosphopathway_PTMSEA.csv") %>% clean_names() %>%
  filter(str_sub(psite, end = 1L) == "Y") %>% 
  # left_join(y = human_fasta_2024 %>% separate(gene, into = c("gene", "organism_del"), sep = "_", remove = TRUE), by = "gene") %>% 
  left_join(y = fasta_gene_names, by = "gene", relationship = "many-to-many") %>%  #match on gene1 worked!

  rename(reference = entry) %>%
  left_join(y = (human_fasta_2024 %>% mutate(HuFasta2024 = "yes")), by = "reference") %>%
  filter(HuFasta2024 == "yes") %>% 
  select(-c(gene_names : gene6)) %>%
  
  mutate(
    mod_residue = as.numeric(str_sub(psite, start = 2L)),
    ref = paste(reference, psite, sep = "_"),
    PTM_SEA = TRUE,
    mod_res = str_sub(psite, start = 1L, end = 1L)) %>% 
  
  #filter by mod_residue extracted from protein sequence equaling Y, then we know it is more likely the correct sequence.
  mutate(
    extracted_mod_res = str_sub(sequence, start = mod_residue, end = mod_residue) ) %>% 
  filter(extracted_mod_res == mod_res) %>%  #only keep entries where p-site index matches the expected psite residue (3362 to 914 rows, better)
  filter(mod_res == "Y") %>%  #only considering pY sites from the PTM-SEA EGFR signature here.
  mutate(n_unique_pY_sites = n_distinct(gene.x, psite)) %>% 
  
  #still have some duplicated entries per p-site
  #now join to human_fasta_2024 to only keep references that could potentially be in my search database if duplicated.
  # rename(full_protein_sequence = sequence) %>% 
  rename(gene = gene.x) %>% 
  select(-gene.y) %>% 
  select(gene, reference, mod_res, mod_residue, PTM_SEA, sequence)

#so, these multiple references and protein sequences per gene name is present in the human fasta 2024 as well. I will then just collapse to one psite per gene after joining against my own data below.

```

The PTMSigDB dataset is less easy to join a full_protein_sequence and  reference to because we just have gene names, and the fasta_gene_names dataframe has many different references per gene name. Therefore, I guess the best option I have here is to take the first protein sequence per gene type.
##_c. Phosphopedia ErbB
```{r}
# ppdia_ErbB_signaling <- read_csv(file = "raw_data/MainFig3to6_SuppFig9to15/Phosphopedia_ErbB_gene_sites.csv") %>% 
#   clean_names() %>% 
#   rename(mod_residue = psite) %>%
#   mutate(PPDIA = TRUE,
#          mod_res = str_sub(mod_residue, end = 1L))
```

##_d. PSP EGF signature
326  human pY sites including isoforms
307 human pY sites excluding isoforms (excluding isoforms because we did not search with them)
   ^ (17 references not in human FASTA 2024 due to isoforms)
   
   
```{r}
PSP_EGFR <- read_csv(file = "raw_data/MainFig3to6_SuppFig9to15/PSP_EGF_all_20241219.csv") %>% 
  clean_names() %>% 
  filter(organism == "human") %>% #just human sites
  rename(reference = acc_id) %>% 
  rename(psite = mod_rsd) %>%
  filter(grepl("-", reference) ==FALSE) %>%  #remove isoforms, my data doesn't search agaisnt a fasta containing isoforms
  mutate(PSP = TRUE,
    mod_res = str_sub(psite, end = 1L),
         mod_residue = as.numeric(str_sub(psite, start = 2L))) %>% 
  filter(mod_type == "p") %>%  #also includes glyco, ubi
  # filter(mod_res %in% c("S", "T", "Y")) #only include S, T or Y residues
  filter(mod_res == "Y") %>%  #only include Y residues
  left_join(y = human_fasta_2024 %>% distinct(reference, full_protein_sequence) %>% mutate(HuFasta2024 = "yes"), by = "reference") %>% 

  mutate(
    motif_in_full_protein_seq = case_when(
      str_detect(full_protein_sequence, str_to_upper(str_remove_all(site_7_aa, "_"))) == TRUE ~ "match",
      str_detect(full_protein_sequence, str_to_upper(str_remove_all(site_7_aa, "_"))) == FALSE ~ "no",
      TRUE ~ "what happened here")) %>% #all matches
  select(gene, reference, PSP, full_protein_sequence,motif_in_full_protein_seq, everything()) %>% 
  select(gene, reference, mod_res, mod_residue, PSP, full_protein_sequence)
```
Okay, the 7aa motifs are found in the matched protein sequences joined from human_fasta_2024.
Now, to use the protein reference throughout for easy joining.

#combine PSP and PTMSigDB EGF then collapse duplicates
```{r}
PSP_vs_PTMSigDB_EGF <- EGFR1_pathway_PTMSigDB %>%
  full_join(y = PSP_EGFR, by = c("gene", "mod_res", "mod_residue")) %>% 
  mutate(
    overlap = case_when(
      PSP == TRUE & PTM_SEA == TRUE ~ "match",
      TRUE ~ "not match"))

PSP_vs_PTMSigDB_EGF_matches <-    PSP_vs_PTMSigDB_EGF %>% 
  mutate(
    gene_reference_match = case_when(
      overlap == "match" & reference.x == reference.y ~ "full match",
      overlap == "match" & reference.x != reference.y ~ "soft match", #gene but not reference matches
      TRUE ~ "not matched"), 
    DB_overlap = case_when(
      PTM_SEA == TRUE & PSP == TRUE ~ "both\ndatabases",
      PSP == TRUE & is.na(PTM_SEA) ~ "PSP\nonly",
      is.na(PSP) & PTM_SEA == TRUE ~ "PTMSigDB\nonly")) %>%  
    # collape multiples of same site due to different genes and references in databases
  distinct(gene, mod_res, mod_residue, DB_overlap)

#COUNTS-------------------------------------
sums_PSP_vs_PTMSigDB_EGF_matches_plotting <- PSP_vs_PTMSigDB_EGF_matches %>%
  
  distinct(gene, mod_residue, mod_res, DB_overlap) %>% 
  group_by(DB_overlap) %>%
  mutate(n_sites = n()) %>%
  ungroup() %>% 
  distinct(DB_overlap, n_sites) %>% 
  mutate(n_sites_char = as.character(n_sites),
         overlap_num = case_when(
           DB_overlap == "both\ndatabases" ~ 1,
           DB_overlap == "PSP\nonly" ~ 2,
           DB_overlap == "PTMSigDB\nonly" ~ 3))

#PLOT -------------------------------------
plot_overlaps_PSP_vs_PTMSigDB_EGF_matches <- ggplot() +
  geom_bar(data = PSP_vs_PTMSigDB_EGF_matches,
           mapping = aes(x= DB_overlap, fill = mod_res), color = "black", size = 0.75, show.legend = FALSE, width = 0.75) +
  geom_text(data = sums_PSP_vs_PTMSigDB_EGF_matches_plotting, aes(x = overlap_num, y = n_sites +15, label = n_sites_char), size = 5) +
  scale_fill_viridis_d(direction = -1) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, lineheight = 0.75, vjust = 1),
        axis.text.y = element_text( size = 12),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 14)) +
  scale_y_continuous(limits = c(0, 350),breaks = c(seq(0, 300, 100)), expand = c(0, 0)) +
  ylab("Annotated pY sites") +
  xlab("database overlap")

plot_overlaps_PSP_vs_PTMSigDB_EGF_matches

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_PSP_vs_PTMSigDB_EGF_matches.png", plot = plot_overlaps_PSP_vs_PTMSigDB_EGF_matches, width = 6, height = 8, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_PSP_vs_PTMSigDB_EGF_matches.pdf", plot = plot_overlaps_PSP_vs_PTMSigDB_EGF_matches, width = 6, height = 8, scale = 0.4)


```
602 unique pY sites across both databases.


```{r}
# PSP_EGFR <- read_csv(file = "raw_data/MainFig3to6_SuppFig9to15/PSP_EGF/PSP_EGF_all.csv")%>%
#   clean_names() %>%
#   separate(mod_rsd, into = c("mod_residue", "mod_type"), sep = "-", remove = FALSE) %>% 
#   mutate(PSP = TRUE,
#          mod_res = str_sub(mod_residue, end = 1L)) %>%
#   rename(reference = acc_id) %>% 
#   filter(mod_type == "p") %>%  #also includes glyco, ubi
#   filter(mod_res %in% c("S", "T", "Y")) %>%  #only include S, T or Y residues
#   select(gene, mod_res, mod_residue, PSP) #can add protein, reference (w/ isoforms, study types)
```
EGF stimulation in any cell type.
##_e. overlaps in EGF:EGFR database annotations
with reference for acceptable joining given different gene names.
```{r}
# overlap_PSP_PTMSEA <- PSP_EGFR  %>% 
#   distinct(reference, gene, psite, mod_res, mod_residue, PSP, full_protein_sequence) %>% 
#   rename(reference.PSP = reference) %>% 
#   # full_join((ppdia_ErbB_signaling), by = c("gene", "mod_residue", "mod_res")) %>%
#   # full_join(EGFR1_pathway_PTMSigDB %>% select(gene, mod_res, mod_residue, PTM_SEA), by = c("gene", "mod_residue", "mod_res")) %>% 
#   full_join(EGFR1_pathway_PTMSigDB %>% rename(reference.PTMSEA = reference) ,
#             by = c( "psite", "mod_res", "mod_residue", "gene", "full_protein_sequence")) %>% #omit reference during joining because multiple references seem to map to the same gene and protein sequence.
# 
#   
#   
#   mutate(overlap = case_when(
#     #both
#     PSP == TRUE &  PTM_SEA == TRUE ~ "PSP &\nPTMSigDB",
#     
#     #one of two
#     PSP == TRUE &  is.na(PTM_SEA) ~ "PSP\nonly",
#     
#     is.na(PSP) &  PTM_SEA == TRUE ~ "PTMSigDB\nonly"),
#     
#     overlap = fct_relevel(overlap, "PSP &\nPTMSigDB",  "PSP\nonly",  "PTMSigDB\nonly"))%>%
#   mutate(
#     reference_comparison = case_when(
#       is.na(reference.PSP) ==TRUE  | is.na(reference.PTMSEA) ==TRUE ~ "unique site",
#       reference.PSP == reference.PTMSEA ~ "match",
#       reference.PSP != reference.PTMSEA ~ "different"), #aligns with overlap, condense into single column
#     reference = case_when(
#       reference_comparison == "match" ~ reference.PSP, #default to PSP reference if shared between 2x DBs
#       is.na(reference.PSP) ==TRUE ~ reference.PTMSEA,
#       is.na(reference.PTMSEA) == TRUE ~ reference.PSP,
#       TRUE ~ "missing reference")) %>%  #no missing references. good. proceed
#   
#   distinct(reference, gene, mod_res, mod_residue, overlap, PSP, PTM_SEA) #PTMSigDB needs the distinct filter because we drop references due to duplicates per gene. thus multiple rows for the same psite and gene are present. I am okay dropping reference here because we already matched on full protein sequence to show the references should be redundant with gene and protein sequence. (gets complicated, so this is my best assumption, but wouldn't hurt to go back and check these assumptions and matching steps again.)
# 
# # Increaase from  638 to 940 rows when reference is added to distinct(). This means duplicate references per gene_ref (gene_psite). Will keep this for matching to our data in case we have one reference but not another used in gene assignment by comet.
# 
# #counts considering only genes and p-sites, with full protein sequence used to join the two databases, leading to 36 more discrepancies than if joined by just gene name, but less discrepancies than using uniprot reference ids in joining meaning the reference ids can be redundant even for the same protein sequence.
# sums_psites_overlap_DBs <- overlap_PSP_PTMSEA %>%
#   filter(mod_res == "Y") %>% 
#   distinct(gene, mod_residue, mod_res, overlap) %>% 
#   group_by(overlap) %>%
#   mutate(n_sites = n()) %>%
#   ungroup() %>% 
#   distinct(overlap, n_sites) %>% 
#   mutate(n_sites_char = as.character(n_sites),
#          overlap_num = case_when(
#            # overlap == "all" ~ 1,
#            overlap == "PSP &\nPTMSigDB" ~ 1,
#            # overlap == "PSP\n+\nPPDIA" ~ 3,
#            # overlap == "PTMSigDB\n+\nPPDIA" ~ 4,
#            overlap == "PSP\nonly" ~ 2,
#            # overlap == "PPDIA\n \nonly" ~ 6,
#            overlap == "PTMSigDB\nonly" ~ 3))
  
```

1 PSP & PTMSigDB  110 110 1
2 PSP only        370 370 2
3 PTMSigDB only   394 394 3

After improved joining:
overlap           n_sites   n_sites_char  overlap_num
1 PSP & PTMSigDB  110       110             1
2 PSP only        197       197             2
3 PTMSigDB only   331       331             3

##_e2. for plotting: overlaps in EGF:EGFR database annotations
this matching omits some of the joining on full protein sequence leading to consolidation of 36 entries that shared the same site number and gene but different reference and therefore protein sequence. 
I will keep this more stringent matching for the assessment of overlaps because this is closer to assessing number of unique sites and not protein group assignment. The differences in protein group assignment will be more useful to include when joining to our data to ensure best chances of matching detected sites to annotated sites. I can then filter again on unique gene and site overlaps to focus on site level analysis, ignoring ambiguities in protein group assignment.
```{r}
# overlap_PSP_PTMSEA_plotting <- PSP_EGFR  %>% 
#   distinct(gene, mod_res, mod_residue, PSP) %>% 
#   # full_join((ppdia_ErbB_signaling), by = c("gene", "mod_residue", "mod_res")) %>%
#   # full_join(EGFR1_pathway_PTMSigDB %>% select(gene, mod_res, mod_residue, PTM_SEA), by = c("gene", "mod_residue", "mod_res")) %>% 
#   # full_join(EGFR1_pathway_PTMSigDB , by = c("reference", "psite", "mod_res", "mod_residue", "gene")) %>% 
#   full_join(EGFR1_pathway_PTMSigDB %>% select(gene, mod_res, mod_residue, PTM_SEA),
#             by = c("gene",  "mod_res", "mod_residue")) %>% 
#   mutate(overlap = case_when(
#     #all
#     PSP == TRUE &  PTM_SEA == TRUE ~ "PSP &\nPTMSigDB",
#     
#     #one of three
#     PSP == TRUE &  is.na(PTM_SEA) ~ "PSP\nonly",
#     
#     is.na(PSP) &  PTM_SEA == TRUE ~ "PTMSigDB\nonly"),
#     
#     overlap = fct_relevel(overlap, "PSP &\nPTMSigDB",  "PSP\nonly",  "PTMSigDB\nonly")) %>% 
#   distinct(gene, mod_res, mod_residue, overlap)
# 
# 
# 
# sums_psites_overlap_DBs_plotting <- overlap_PSP_PTMSEA_plotting %>%
#   filter(mod_res == "Y") %>% #unnecessary, already filtered. doesn't hurt to have here though.
#   distinct(gene, mod_residue, mod_res, overlap) %>% 
#   group_by(overlap) %>%
#   mutate(n_sites = n()) %>%
#   ungroup() %>% 
#   distinct(overlap, n_sites) %>% 
#   mutate(n_sites_char = as.character(n_sites),
#          overlap_num = case_when(
#            # overlap == "all" ~ 1,
#            overlap == "PSP &\nPTMSigDB" ~ 1,
#            # overlap == "PSP\n+\nPPDIA" ~ 3,
#            # overlap == "PTMSigDB\n+\nPPDIA" ~ 4,
#            overlap == "PSP\nonly" ~ 2,
#            # overlap == "PPDIA\n \nonly" ~ 6,
#            overlap == "PTMSigDB\nonly" ~ 3))
  
```
###__i. plot database overlaps
```{r}
# overlaps_EGFR_sites_plotting <- ggplot() +
#   geom_bar(data = overlap_PSP_PTMSEA_plotting %>% distinct(gene, mod_residue, mod_res, overlap) %>% filter(mod_res == "Y"),
#            mapping = aes(x= overlap, fill = mod_res), color = "black", size = 0.75, show.legend = FALSE) +
#   geom_text(data = sums_psites_overlap_DBs_plotting, aes(x = overlap_num, y = n_sites + 15, label = n_sites_char), size = 5) +
#   scale_fill_viridis_d(direction = -1) +
#   alexis_theme() +
#   theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, lineheight = 0.75, vjust = 1),
#         axis.text.y = element_text( size = 12),
#         axis.title = element_text(size = 12),
#         legend.title = element_text(size = 14)) +
#   scale_y_continuous(limits = c(0, 400),breaks = c(seq(0, 4000, 100)), expand = c(0, 0)) +
#   ylab("Annotated pY sites") +
#   xlab("database overlap")
# 
# overlaps_EGFR_sites_plotting
# 
# ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_sites_2databases.png", plot = overlaps_EGFR_sites_plotting, width = 6, height = 8, scale = 0.4)
# ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_sites_2databases.pdf", plot = overlaps_EGFR_sites_plotting, width = 6, height = 8, scale = 0.4)
```
PTM-SEA has many different protein entries for the same gene name....


##_f. WP437 EGFR node depths
```{r}
#added 1 and additional +10 to nodes in degradation + recycling
# WP437_EGFR_node_depths <- read_csv(file = "raw_data/MainFig3to6_SuppFig9to15/EGFR_WP437_node_depths.csv") %>%  clean_names()

#with lowest possible node depth within degradation pathway
WP437_EGFR_node_depths <- read_csv(file = "raw_data/MainFig3to6_SuppFig9to15/EGFR_WP437_node_depths2_2025Apr26.csv") %>%  clean_names()

```
can change to genes, but there will be many different references. 
This I think was defunct code anyways.
```{r}
# overlaps_2xDB_reference_names <- overlap_PSP_PTMSEA %>% 
#   distinct(reference)
# 
# write_delim(x = overlaps_2xDB_reference_names, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/2xDB_overlaps_references.txt")

```




#IV. IMPORT MY DATA

##_a. COMET
```{r}

comet <- read_csv("raw_data/MainFig3to6_SuppFig9to15/TyrPhospho/comet/result.csv") %>%
  clean_names() %>% 
  separate(col = sample_name, into = c("experiment", "enrichment", "condition", "replicate", "R2P2_well", "MS_method", "inj_vol"), sep = "_", remove = FALSE) %>% 
   
  left_join(y = human_fasta_2024, by = "reference") %>% 
  rename(intensity = max_intensity_light_c2837) %>% 
  filter(reverse == FALSE) %>% 
  mutate(phospho = case_when(
    grepl("\\@", sequence) ~ "phospho",
    TRUE ~ "none")) %>% 
  
  #remove pooled samples
  filter(grepl("POOL", condition) == FALSE) %>% 
  
  #to get sense of data thus far, and maybe for 8 reps in future, consider pooled bio reps their own reps.
  mutate(
    replicate = case_when(
      grepl("POOL", condition) == TRUE ~ paste(replicate, 0, sep = ""),
      TRUE ~ replicate), #distinguish replicates when collapsing pool into regular replicates
    condition = str_remove_all(condition, "POOL")) %>% #count pool as normal replicate
  filter(grepl("VSrc", condition) == FALSE) %>%  #omit VSrc controls in analysis for now
  mutate(sample_id = paste(condition, replicate, sep = " ")) 
```

##_a2. MASTER FASTA
```{r}
master_references <- human_fasta_2024 %>% 
  distinct(reference, full_protein_sequence) #%>% 
  # group_by(reference) %>% 
  # mutate(n_distinct_sequences = n_distinct(full_protein_sequence))

master_FASTA <- overlap_human_FASTA2024_gene_names %>% 
  rename(gene = gene.x) %>% 
  filter(human_2024 = TRUE) %>% 
  distinct(reference, gene, keywords, keyword_id) %>%
  left_join(y = master_references, by = "reference")
```


##_b. ASCORE

###_i. ascore redundancy info
```{r}
ascore_redundancyinfo <- read_csv("raw_data/MainFig3to6_SuppFig9to15/TyrPhospho/ascore_w_proteins_andPOOL/result.csv") %>% 

  clean_names() %>% 
  separate(col = sample_name, into = c("experiment", "enrichment", "condition", "replicate", "R2P2_well", "MS_method", "inj_vol"), sep = "_", remove = FALSE) %>% 
   
  left_join(y = master_FASTA, by = "reference") %>% 
  rename(intensity = max_intensity_light_c2837) %>% 
  filter(reverse == FALSE) %>% 
  mutate(phospho = case_when(
    grepl("\\@", sequence) ~ "phospho",
    TRUE ~ "none")) %>% 
  
  #remove pooled samples
  # filter(grepl("POOL", condition) == FALSE) %>% 
  
  #to get sense of data thus far, and maybe for 8 reps in future, consider pooled bio reps their own reps.
  mutate(
    replicate = case_when(
      grepl("POOL", condition) == TRUE ~ paste(replicate, 0, sep = ""),
      TRUE ~ replicate), #distinguish replicates when collapsing pool into regular replicates
    condition = str_remove_all(condition, "POOL")) %>% #count pool as normal replicate
  filter(grepl("VSrc", condition) == FALSE) %>% #omit VSrc controls in analysis for now
  mutate(sample_id = paste(condition, replicate, sep = " ")) %>% 
  separate(proteins, into = c("reference1", "reference2", "reference3", "reference4", "reference5", "reference6", "reference7", "reference8", "reference9"), sep = " ",remove = FALSE) %>% 
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference1 = reference) %>% rename(gene_names1 = gene_names), by = "reference1") %>% 
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference2 = reference) %>% rename(gene_names2 = gene_names), by = "reference2") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference3 = reference) %>% rename(gene_names3 = gene_names), by = "reference3") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference4 = reference) %>% rename(gene_names4 = gene_names), by = "reference4") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference5 = reference) %>% rename(gene_names5 = gene_names), by = "reference5") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference6 = reference) %>% rename(gene_names6 = gene_names), by = "reference6") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference7 = reference) %>% rename(gene_names7 = gene_names), by = "reference7") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference8 = reference) %>% rename(gene_names8 = gene_names), by = "reference8") %>%
  left_join(fxns_fasta %>% select(reference, gene_names) %>% rename(reference9 = reference) %>% rename(gene_names9 = gene_names), by = "reference9") %>% 
  unite("gene_redundancy", gene_names1:gene_names9, sep = " ", na.rm = TRUE) %>% 
  select(ascore_sequence, num_sites, a_score_1, a_score_2, a_score_3, condition, redundancy, reference, proteins, gene_redundancy, everything()) %>% 
  mutate(condition_numeric = case_when(
    condition == "EGF0min" ~ 0,
    condition == "EGF1min" ~ 1,
    condition == "EGF3min" ~ 3,
    condition == "EGF5min" ~ 5,
    condition == "EGF15min" ~ 15))
  

#use for pY data:
write_csv(x = ascore_redundancyinfo, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/ascore_redundancy_info.csv")
#key specific to pY, a bit hard coded because combos are unique to this data. Must recreate the key if data changes.



key_proteins_gene_redundnacy <- ascore_redundancyinfo %>% distinct(proteins, gene_redundancy)
```




sub analysis, one off, unused CDK1 analysis - not stringent enough and used POOL samples
```{r}
plot_CDK1_ascore_redundancy <- ggplot(data = ascore_redundancyinfo %>%
                                        filter(grepl("CDK1 ", gene_redundancy)==TRUE) %>% 
                                        filter(reference == "P06493") %>% 
                                        distinct(condition, condition_numeric, intensity, gene_redundancy, reference)) +
  
  geom_jitter(mapping = aes(x= condition_numeric, y = log2(intensity), fill = condition), size = 3.5, shape = 21, height = 0, width = 0.05, alpha = 0.75, show.legend = FALSE)+
  geom_boxplot(mapping = aes(x = condition_numeric, y= log2(intensity), fill = condition), alpha = 0.25, show.legend = FALSE) +
  scale_fill_manual(values = c(rep("grey90", 12))) +
  scale_x_continuous(limits = c(-1, 16), labels = c(0, 1, 3, 5, 15),breaks =  c(0, 1, 3, 5, 15), name = "EGF treatment\nduration (min)") +
  scale_y_continuous(name = expression("Log" [2]* "(intensity)"), expand = c(0.05,0.2))  +
  alexis_theme() +
  theme(axis.title = element_text(size = 12),
        axis.text.x = element_text(vjust = 1))

plot_CDK1_ascore_redundancy

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_CDK1_ascore_redundancy.png", plot = plot_CDK1_ascore_redundancy, width = 6, height = 6, scale = 0.4)
```

##_d. ascore parsing
```{r}
ascore <- read_csv("raw_data/MainFig3to6_SuppFig9to15/TyrPhospho/ascore/result.csv") %>% 

  clean_names() %>% 
  separate(col = sample_name, into = c("experiment", "enrichment", "condition", "replicate", "R2P2_well", "MS_method", "inj_vol"), sep = "_", remove = FALSE) %>% 
   
  left_join(y = master_FASTA, by = "reference") %>% 
  rename(intensity = max_intensity_light_c2837) %>% 
  filter(reverse == FALSE) %>% 
  mutate(phospho = case_when(
    grepl("\\@", sequence) ~ "phospho",
    TRUE ~ "none")) %>% 
  
  #remove pooled samples
  filter(grepl("POOL", condition) == FALSE) %>% 
  
  #to get sense of data thus far, and maybe for 8 reps in future, consider pooled bio reps their own reps.
  mutate(
    replicate = case_when(
      grepl("POOL", condition) == TRUE ~ paste(replicate, 0, sep = ""),
      TRUE ~ replicate), #distinguish replicates when collapsing pool into regular replicates
    condition = str_remove_all(condition, "POOL")) %>% #count pool as normal replicate
  filter(grepl("VSrc", condition) == FALSE) %>% #omit VSrc controls in analysis for now
  mutate(sample_id = paste(condition, replicate, sep = " ")) %>% 
  left_join(ascore_redundancyinfo) %>% 
  select(ascore_sequence, mod_locations, gene_redundancy, everything())
```


###___i. ppm analysis
```{r}
plot_ppm_error <- ggplot(data = ascore %>% mutate(raw_file_num = as.factor(str_sub(raw_file_name, start = 2L)))) +
  geom_hline(yintercept = 10, color = "red4", alpha = 0.4, linewidth = 2) +
  geom_violin(mapping = aes(x = raw_file_num, y = ppm), draw_quantiles = c(0.25, 0.5, 0.75))+
  
  # ylim(0, 20) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5),
        axis.text.y = element_text( size = 12, hjust = 1),
        axis.title = element_text(size = 18)) +
  coord_flip()

plot_ppm_error

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/ppm_ascore_violin.png", plot = plot_ppm_error, width = 10, height = 20, scale = 0.4)
```
ppm mass error drifted quite a lot from an already high ppm error as the heat wave hit amidst my runs. 80+F in MS room.Expanding ppm window didn't seem to help recover IDs from that later runs with >10ppm mass error.

###___ii. parse phosphosite localization


Working from 'Ascore Extended' output from Zucchini. Avoids relying on "mod_location" for phospho localization.

```{r}
ascore.site2 <- ascore %>% 
  distinct() %>%
  
  mutate(seq_no_mods = str_remove_all(ascore_sequence, "[:punct:]"),
         seq_no_mods = str_remove_all(seq_no_mods, "[n]")) %>% ##remove n from n## mark of nAc modification. 
  mutate_at(c("a_score_1", "a_score_2", "a_score_3", "position_1", "position_2", "position_3"), funs(as.numeric)) %>% 
  mutate_at(c("a_score_1", "a_score_2", "a_score_3", "position_1", "position_2", "position_3"), ~replace_na(., 0)) %>%

  select(sample_name, condition, replicate, sample_id,  reference, gene,
         ascore_sequence, num_sites, a_score_1, a_score_2, a_score_3, position_1, position_2, position_3,
         seq_no_mods, intensity,
         q_score_c2837, num_scans_light_c2837,
         charge, x_corr, proteins, gene_redundancy,
         missed_cleavages, num_sites, redundancy, full_protein_sequence) %>% 
 
##extract modified residue
  mutate(
    mod_res1 = str_sub(seq_no_mods, start = position_1+1L, end = position_1 + 1L),
    mod_res2 = str_sub(seq_no_mods, start = position_2+1L, end = position_2 + 1L),
    mod_res3 = str_sub(seq_no_mods, start = position_3+1L, end = position_3 + 1L))


## pivot wider to match each p-site to an ascore and filter for STY
ascore.site2_longer <- ascore.site2 %>% 
  unite(ascore_mod_res1, c(a_score_1, mod_res1, position_1), sep = "_") %>% 
  unite(ascore_mod_res2, c(a_score_2, mod_res2, position_2), sep = "_") %>%
  unite(ascore_mod_res3, c(a_score_3, mod_res3, position_3), sep = "_") %>%
  pivot_longer(cols = c("ascore_mod_res1", "ascore_mod_res2", "ascore_mod_res3")) %>% 
  separate(value, into = c("ascore", "mod_res", "mod_position"), sep = "_") %>% 
  mutate(ascore= as.numeric(ascore))
  

```

###___ii. filter for confidently localized phosphosites

```{r}
ascore.site2_longer_stringent <- ascore.site2_longer %>% 
  filter(ascore >= 13) %>% 
  filter(grepl("[STY]", mod_res) == TRUE)
```

###___iii. keep detected proteins
already joined to fasta above
```{r}
ascore_fasta <- ascore.site2_longer_stringent %>% 
  filter(!is.na(ascore_sequence))
```

###___iv. get protein level site number

This code chunk includes the following update (from Sept 2023)

I made the z-substitute script to solve bug Sophie found.

The goal is to not have NA mods. Sophie found on Sept 20, 2023 that those mods are result of incorrect Isoleucine, Leucine assignment in peptide sequence.

Sophie implemented a very nice test of S, T, Y, or NA mods to see if parsing is complete and captures peptides with isoleucine or leucine that may have been swapped during searching.

```{r}
ascore_fasta_protein_mod_loc_allobservations <- ascore_fasta %>% 
  mutate(
    mod_position = as.numeric(mod_position), ##mod_position parsed from ascore output above
    z_peptide = str_replace_all(seq_no_mods, "[IL]", "Z"),
    z_protein = str_replace_all(full_protein_sequence, "[IL]", "Z"),
    z_pept_position_in_z_protein = str_locate(z_protein, pattern = z_peptide), ##get peptide mod_residue from z-substituted peptide and protein
    mod_position_in_protein = z_pept_position_in_z_protein[,"start"] + mod_position, ##extract mod mod_residue from true protein sequence
    test_mod_position = str_sub(full_protein_sequence, start = mod_position_in_protein, end = mod_position_in_protein)) %>% 
  select(test_mod_position, mod_res, mod_position, ascore_sequence, everything()) %>% 
  unite(col = "mod_protein_location", c(mod_res, mod_position_in_protein), sep = "", remove = FALSE) %>% 
  unite(col = "ref", c(reference, mod_protein_location), sep = "_", remove = FALSE) 
  
  
  #join to BCA quant for correlation analysis with plate protein yield
  # left_join(y = df_BCA, by = c("condition", "replicate", "density_numeric", "density")) 

#--------------------------------------------------
    ##tally up the number of rows that have NA vs. STY in test_mod_position
mod_pos_group <- ascore_fasta_protein_mod_loc_allobservations %>% 
  select(test_mod_position) %>% 
  group_by(test_mod_position) %>% 
   summarize(
    num_phospeptides = n())
mod_pos_group

    ##all mods are on S, T or Y as hoped
  
#--------------------------------------------------
```
####----write_csv `ascore_fasta_protein_mod_loc_allobservations`
Used in script 08_ comparison to Reddy et al. 2016
```{r}
write_csv(x = ascore_fasta_protein_mod_loc_allobservations %>%
            rename(psite = mod_protein_location) %>%
            distinct(reference, psite),
          file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/AllpYSiteDetections_CompareToOtherStudies.csv")
```

###___v. rollup PSM to precursor, then sum precursor intensities to p-site and median normalize

Just precursor level for peptide level reporting for publication
```{r}
ascore_stringent_fasta_precursor <- ascore_fasta_protein_mod_loc_allobservations %>% 
  group_by(condition, replicate, ascore_sequence, charge, ascore) %>% 
  filter(intensity == max(intensity)) %>% 
  ungroup()
```

_save lists of peptides for supplementary_
write to csv
```{r}
#replicate
write_csv(x = ascore_stringent_fasta_precursor %>% distinct(condition, replicate, ascore_sequence, charge, ascore, intensity, reference, sample_name,gene, proteins, gene_redundancy, redundancy,  mod_position_in_protein, ref), file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_pSTYpeptides_ascore13_replicate.csv", col_names = TRUE)


#condition
write_csv(x = ascore_stringent_fasta_precursor %>% distinct(condition,  ascore_sequence, proteins, gene_redundancy, redundancy, charge, ascore, intensity, reference, gene, mod_position_in_protein, ref), file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_pSTYpeptides_ascore13_condition.csv", col_names = TRUE)
```


may want to go to peptide isoform as well...!
```{r}
#keep single PSM per precursor:

ascore_fasta_protein_mod_loc_sum_psite_allobservations <- ascore_fasta_protein_mod_loc_allobservations %>% 
  group_by(condition, replicate, ascore_sequence, charge, ascore) %>% 
  filter(intensity == max(intensity)) %>% 
  ungroup() %>% 




  ##SUM PRECURSOR INTENSITIES TO P-SITES + median normalize

 
  group_by(condition, replicate,  sample_id, reference, mod_res,  ref) %>% #ref = unique p-site
  
  #sum PSM intensities of confident p-sites to individual p-sites
  mutate(
    sum_intensity_precursor_to_psite = sum(intensity),
    log2_psite_qty = log2(sum_intensity_precursor_to_psite)) %>% 
  ungroup() %>% 
  
  #keep single summed intensity per p-site prior to median normalization
  distinct(condition, replicate, sample_id, reference, mod_res, ref, sum_intensity_precursor_to_psite, log2_psite_qty, proteins, gene_redundancy, redundancy) %>% 
  
  
  #median normalize intensities summed to p-site
  mutate(
    global_median_intensity = median(log2_psite_qty)) %>% 
  group_by(condition, replicate) %>% 
  mutate(
    sample_median_intensity = median(log2_psite_qty)) %>% 
  ungroup() %>% 
  mutate(
    median_norm_intensity = log2_psite_qty - sample_median_intensity + global_median_intensity,
    raw_median_norm_intensity = 2^median_norm_intensity)

```

###___vi. filter for at least one condition with minimum of 3 replicates
 group_by(reference, gene_ref) %>% 
  mutate(max_obs_in_any_condition = max(n_obs)) %>% 
  ungroup() %>% 
  filter(max_obs_in_any_condition > 2)

```{r}
#could call df 3repsonce, but omitting for easier integration into pre-existing code
ascore_fasta_protein_mod_loc_sum_psite <- ascore_fasta_protein_mod_loc_sum_psite_allobservations %>% 
  mutate(
    string_length_proteins = str_length(proteins)  ) %>% 
  #collapse redundant protein assignments to maximal possible proteins assigned.
  group_by(sample_id, reference, ref) %>% 
  filter(string_length_proteins == max(string_length_proteins)) %>%  
  ungroup()%>%
  select(-string_length_proteins) %>% 
  group_by(condition, ref) %>% 
  mutate(
    n_obs_per_condition = n()  ) %>% 
  ungroup() %>% 
  group_by(ref) %>% 
  mutate(max_obs_in_any_condition = max(n_obs_per_condition)) %>% 
  ungroup() %>% 
  filter(max_obs_in_any_condition > 2) #requires 3 or more observations in one condition to be considered in all later analyses.
```



###___vii. key of well measured sites to filter ascore_fasta_mod_loc too
filter the ascore dataframe used for counting distinct sites to those sites only well measured by filter above. 
For example minimum of 3 replicates in any one condition.
```{r}
key_sites_measured_gt3reps_min_once <- ascore_fasta_protein_mod_loc_sum_psite %>% 
  distinct(ref)
```

apply the completeness filter to ascore_fasta_protein_mod_loc as well because this dataframe is used later too.
```{r}
ascore_fasta_protein_mod_loc <- ascore_fasta_protein_mod_loc_allobservations %>% 
  filter(ref %in% key_sites_measured_gt3reps_min_once$ref)
```

#V. COST COMPARISON
##  - with more details
```{r}
cost_df_detailed <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                      magnetic_beads = c(5172, 1728, 465),
                      purification_reagents = c(0, 110 , 0),
                      characterization_reagents = c(0, 20, 20),
                      bead_labor_cost = c(0, 720, 60),
                      bug_labor_cost = c(0, 26, 7.7)) %>% 
  mutate(      total_cost = magnetic_beads +purification_reagents + bead_labor_cost + bug_labor_cost+ characterization_reagents,
               in_house_total = purification_reagents + bead_labor_cost + bug_labor_cost+ characterization_reagents) %>% 
  pivot_longer(cols = c(magnetic_beads, purification_reagents ,bead_labor_cost , bug_labor_cost , characterization_reagents), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "magnetic_beads" ~ "magnetic beads",
      cost_type == "purification_reagents" ~ "protein purification\nconsumables",
      cost_type == "characterization_reagents" ~ "bead QC",
      cost_type == "bead_labor_cost" ~ "bead labor",
      cost_type == "bug_labor_cost" ~ "E.coli labor")) %>% 
  mutate(
    cost_type = fct_relevel(cost_type,"bead QC",
                            
                            "protein purification\nconsumables",
                            "E.coli labor",
                            "bead labor",
                             "magnetic beads"),
    bead_type = fct_relevel(bead_type, "CST\U00AE mAb\npTyr-1000", "NHS-sSrc", "Halo-TEV-sSrc"))


plot_cost_distribution_detailed <-  ggplot(data = cost_df_detailed %>% filter(cost_type != "magnetic beads")) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2, width = 0.75, position = "stack") +
  geom_text(data = cost_df_detailed %>% distinct(bead_type, in_house_total), mapping = aes (x = bead_type, y = in_house_total + 80, label = paste0("$", round(in_house_total,0))), size = 4, inherit.aes = FALSE, fontface = "bold", family ="sans" ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 12, family = "sans", angle = -60),
        axis.title.y = element_text(hjust = 1, vjust = 0.5, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(vjust = 0.5, size = 10, family = "sans", lineheight = 0.75),
        
        legend.key.size =unit(0.5, 'cm'),
        legend.key.spacing = unit(0.1, 'cm')) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1000), breaks = c(seq(0, 1000,200))) +
  xlab("") +
  scale_fill_manual(values = c("#DEEBF7", "#9ECAE1", "#2171B5","#08306B", "grey90"), name = "in-house costs") 


# "#F7FCF5" "#E5F5E0" "#C7E9C0" "#A1D99B" "#74C476" "#41AB5D" "#238B45" "#006D2C" "#00441B" ,"#A1D99B"
# "#F7FBFF" "#DEEBF7" "#C6DBEF" "#9ECAE1" "#6BAED6" "#4292C6" "#2171B5" "#08519C" "#08306B"

plot_cost_distribution_detailed

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution_detailed_stack.png", plot = plot_cost_distribution_detailed, width = 8, height = 6, scale = 0.5)

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution_detailed_stack.pdf", plot = plot_cost_distribution_detailed, width = 8, height = 6, scale = 0.5)
```
#### . . . Ab first, then NHS, then Halo
```{r}
cost_df_detailed1 <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                      magnetic_beads = c(5172, 1728, 465),
                      purification_reagents = c(0, 110 , 0),
                      characterization_reagents = c(0, 20, 20),
                      bead_labor_cost = c(0, 720, 60),
                      bug_labor_cost = c(0, 26, 7.7)) %>% 
  mutate(      total_cost = magnetic_beads +purification_reagents + bead_labor_cost + bug_labor_cost+ characterization_reagents,
               in_house_total = purification_reagents + bead_labor_cost + bug_labor_cost+ characterization_reagents) %>% 
  pivot_longer(cols = c(magnetic_beads, purification_reagents ,bead_labor_cost , bug_labor_cost , characterization_reagents), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "magnetic_beads" ~ "magnetic beads",
      cost_type == "purification_reagents" ~ "protein purification\nconsumables",
      cost_type == "characterization_reagents" ~ "bead QC",
      cost_type == "bead_labor_cost" ~ "bead labor",
      cost_type == "bug_labor_cost" ~ "E.coli labor")) %>% 
  mutate(
    cost_type = fct_relevel(cost_type,"bead QC",
                            
                            "protein purification\nconsumables",
                            "E.coli labor",
                            "bead labor",
                             "magnetic beads"),
    bead_type = fct_relevel(bead_type, "CST\U00AE mAb\npTyr-1000", "NHS-sSrc", "Halo-TEV-sSrc"))


plot_cost_distribution_detailed_total1 <-  ggplot(data = cost_df_detailed1 ) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2, width = 0.75, position = "stack") +
  geom_text(data = cost_df_detailed1 %>% distinct(bead_type, total_cost),
            mapping = aes (x = bead_type, y = total_cost + 150, label = paste0("$", round(total_cost,0))), size = 4, inherit.aes = FALSE, fontface = "bold", family ="sans" ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 12, family = "sans", angle = -60),
        axis.title.y = element_text(hjust = 0.1, vjust = 0.5, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(vjust = 0.5, size = 10, family = "sans", lineheight = 0.75),
        
        legend.key.size =unit(0.5, 'cm'),
        legend.key.spacing = unit(0.1, 'cm')) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5500), breaks = c(seq(0, 5000,1000))) +
  xlab("") +
  scale_fill_manual(values = c("#DEEBF7", "#9ECAE1", "#2171B5","#08306B", "grey90"), name = "total costs") 


# "#F7FCF5" "#E5F5E0" "#C7E9C0" "#A1D99B" "#74C476" "#41AB5D" "#238B45" "#006D2C" "#00441B" ,"#A1D99B"
# "#F7FBFF" "#DEEBF7" "#C6DBEF" "#9ECAE1" "#6BAED6" "#4292C6" "#2171B5" "#08519C" "#08306B"

plot_cost_distribution_detailed_total1

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution_detailed_total_stack1.png", plot = plot_cost_distribution_detailed_total1, width = 8, height = 6, scale = 0.5)

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution_detailed_total_stack1.pdf", plot = plot_cost_distribution_detailed_total1, width = 8, height = 6, scale = 0.5)
```
#### . . . Halo first, then NHS, then Ab
```{r}
cost_df_detailed2 <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                      magnetic_beads = c(5172, 1728, 465),
                      purification_reagents = c(0, 110 , 0),
                      characterization_reagents = c(0, 20, 20),
                      bead_labor_cost = c(0, 720, 60),
                      bug_labor_cost = c(0, 26, 7.7)) %>% 
  mutate(      total_cost = magnetic_beads +purification_reagents + bead_labor_cost + bug_labor_cost+ characterization_reagents,
               in_house_total = purification_reagents + bead_labor_cost + bug_labor_cost+ characterization_reagents) %>% 
  pivot_longer(cols = c(magnetic_beads, purification_reagents ,bead_labor_cost , bug_labor_cost , characterization_reagents), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "magnetic_beads" ~ "magnetic beads",
      cost_type == "purification_reagents" ~ "protein purification\nconsumables",
      cost_type == "characterization_reagents" ~ "bead QC",
      cost_type == "bead_labor_cost" ~ "bead labor",
      cost_type == "bug_labor_cost" ~ "E.coli labor")) %>% 
  mutate(
    cost_type = fct_relevel(cost_type,"bead QC",
                            
                            "protein purification\nconsumables",
                            "E.coli labor",
                            "bead labor",
                             "magnetic beads"),
    bead_type = fct_relevel(bead_type, "Halo-TEV-sSrc" , "NHS-sSrc", "CST\U00AE mAb\npTyr-1000"))


plot_cost_distribution_detailed_total2 <-  ggplot(data = cost_df_detailed2 ) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2, width = 0.75, position = "stack") +
  geom_text(data = cost_df_detailed2 %>% distinct(bead_type, total_cost),
            mapping = aes (x = bead_type, y = total_cost + 150, label = paste0("$", round(total_cost,0))), size = 4, inherit.aes = FALSE, fontface = "bold", family ="sans" ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 12, family = "sans", angle = -60),
        axis.title.y = element_text(hjust = 1, vjust = 0.5, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(vjust = 0.5, size = 10, family = "sans", lineheight = 0.75),
        
        legend.key.size =unit(0.5, 'cm'),
        legend.key.spacing = unit(0.1, 'cm')) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5500), breaks = c(seq(0, 5000,1000))) +
  xlab("") +
  scale_fill_manual(values = c("#DEEBF7", "#9ECAE1", "#2171B5","#08306B", "grey90"), name = "total costs") 


# "#F7FCF5" "#E5F5E0" "#C7E9C0" "#A1D99B" "#74C476" "#41AB5D" "#238B45" "#006D2C" "#00441B" ,"#A1D99B"
# "#F7FBFF" "#DEEBF7" "#C6DBEF" "#9ECAE1" "#6BAED6" "#4292C6" "#2171B5" "#08519C" "#08306B"

plot_cost_distribution_detailed_total2

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution_detailed_total_stack2.png", plot = plot_cost_distribution_detailed_total2, width = 8, height = 8, scale = 0.5)

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution_detailed_total_stack2.pdf", plot = plot_cost_distribution_detailed_total2, width = 8, height = 8, scale = 0.5)
```

##  - with less details
```{r}
cost_df <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                        reagent_cost = c(5172, 1728+80+30, 465),
                        bead_labor_cost = c(0, 720 , 60),
                        bug_labor_cost = c(0, 26, 7.7)) %>% 
  mutate(      total_cost = reagent_cost + bead_labor_cost + bug_labor_cost) %>% 
  pivot_longer(cols = c(reagent_cost ,bead_labor_cost , bug_labor_cost), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "reagent_cost" ~ "reagent cost", 
      cost_type == "bead_labor_cost" ~ "bead labor",
      cost_type == "bug_labor_cost" ~ "E.coli labor")) %>% 
  mutate(
    bead_type = fct_relevel(bead_type, "CST\U00AE mAb\npTyr-1000", "NHS-sSrc", "Halo-TEV-sSrc"))


plot_cost_distribution <-  ggplot(data = cost_df) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2) +
  geom_text(data = cost_df %>% distinct(bead_type, total_cost), mapping = aes (x = bead_type, y = total_cost + 200, label = paste0("$", total_cost)), size = 2, inherit.aes = FALSE ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 8, family = "sans", angle = -60),
        axis.title.y = element_text(hjust = 0, vjust = 0.5, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(size = 10, family = "sans")) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5500), breaks = c(seq(0, 5000, 1000))) + 
  xlab("") +
  scale_fill_manual(values = c("grey50", "grey70", "grey90"), name = "cost type") 


plot_cost_distribution

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution.png", plot = plot_cost_distribution, width = 6, height = 6, scale = 0.5)
```
```{r}
cost_df2 <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                        reagent_cost = c(5172, 1728+80+30, 465),
                        bead_labor_cost = c(0, 720 , 60),
                        bug_labor_cost = c(0, 26, 7.7)) %>% 
  mutate(      total_cost = reagent_cost + bead_labor_cost + bug_labor_cost) %>% 
  pivot_longer(cols = c(reagent_cost ,bead_labor_cost , bug_labor_cost), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "reagent_cost" ~ "reagent cost", 
      cost_type == "bead_labor_cost" ~ "bead labor",
      cost_type == "bug_labor_cost" ~ "E.coli labor")) %>% 
  mutate(
    bead_type = fct_relevel(bead_type,"Halo-TEV-sSrc", "NHS-sSrc", "CST\U00AE mAb\npTyr-1000" ))


plot_cost_distribution2 <-  ggplot(data = cost_df2) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2) +
  geom_text(data = cost_df2 %>% distinct(bead_type, total_cost), mapping = aes (x = bead_type, y = total_cost + 200, label = paste0("$", total_cost)), size = 2, inherit.aes = FALSE ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 8, family = "sans", angle = -60),
        axis.title.y = element_text(hjust = 0, vjust = 0.5, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(size = 10, family = "sans")) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5500), breaks = c(seq(0, 5000, 1000))) + 
  xlab("") +
  scale_fill_manual(values = c("grey50", "grey70", "grey90"), name = "cost type") 


plot_cost_distribution2

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution2.png", plot = plot_cost_distribution2, width = 6, height = 6, scale = 0.5)
```

##  - least details
```{r}
cost_df <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                        commercial_cost = c(5172, 1728, 465),
                        in_house_costs = c(0, 720 + 26+80+30 + 20 , 60 +20 + 7.7)) %>% 
  mutate(      total_cost = commercial_cost + in_house_costs) %>% 
  pivot_longer(cols = c(commercial_cost,in_house_costs), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "commercial_cost" ~ "commercial", 
      cost_type == "in_house_costs" ~ "in-house")) %>% 
  mutate(
    bead_type = fct_relevel(bead_type, "CST\U00AE mAb\npTyr-1000", "NHS-sSrc", "Halo-TEV-sSrc"),
    cost_type = fct_relevel(cost_type,  "in-house","commercial"))


plot_cost_distribution <-  ggplot(data = cost_df) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2) +
  geom_text(data = cost_df %>% distinct(bead_type, total_cost), mapping = aes (x = bead_type, y = total_cost + 200, label = paste0("$", total_cost)), size = 2, inherit.aes = FALSE ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 8, family = "sans", angle = -60),
        axis.title.y = element_text(hjust = 0, vjust = 0.5, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(size = 10, family = "sans")) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5500), breaks = c(seq(0, 5000, 1000))) + 
  xlab("") +
  scale_fill_manual(values = c("grey50", "grey90"), name = "cost type") 


plot_cost_distribution

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution.png", plot = plot_cost_distribution, width = 6, height = 6, scale = 0.5)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution.pdf", plot = plot_cost_distribution, width = 6, height = 6, scale = 0.5)
```

```{r}
cost_df <- data.frame(bead_type = c(bquote("CST\U00AE mAb\npTyr-1000"), "NHS-sSrc", "Halo-TEV-sSrc"), 
                        commercial_costs = c(5172, 1728, 465),
                        in_house_costs = c(0, 720 + 26+80+30 + 20 , 60 +20 + 7.7)) %>%  
  mutate(      total_cost = commercial_costs + in_house_costs) %>% 
  pivot_longer(cols = c(commercial_costs,in_house_costs), names_to = "cost_type", values_to = "cost") %>%
  mutate(
    cost_type = case_when(
      cost_type == "commercial_costs" ~ "commercial", 
      cost_type == "in_house_costs" ~ "in-house")) %>% 
  mutate(
    bead_type = fct_relevel(bead_type, "CST\U00AE mAb\npTyr-1000", "NHS-sSrc", "Halo-TEV-sSrc"),
    cost_type = fct_relevel(cost_type,  "in-house","commercial"))


plot_cost_distribution <-  ggplot(data = cost_df) +
  geom_col(mapping = aes(x = bead_type, y = cost,  fill = cost_type), color = "black", size = 0.2) +
  geom_text(data = cost_df %>% distinct(bead_type, total_cost), mapping = aes (x = bead_type, y = total_cost + 200, label = paste0("$", round(total_cost,0))), size = 2.5, inherit.aes = FALSE, fontface = "bold" ) +
  alexis_theme() + 
  theme(axis.text.x = element_text(hjust = 0, vjust = 0.9, size = 8, family = "sans", angle = -60),
        axis.text.y = element_text(hjust = 1, size = 10, family = "sans"),
        axis.title.y = element_text(hjust = 0.5, vjust = 1, size = 12, family = "sans", angle = 90),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(size = 10, family = "sans"),
        legend.key.size = unit(1,"line")) +
  ylab("Cost per 96-well plate ($)") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 5500), breaks = c(seq(0, 5000, 1000))) + 
  xlab("") +
  scale_fill_manual(values = c("grey50", "grey90"), name = "cost type") 


plot_cost_distribution

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution.png", plot = plot_cost_distribution, width = 6, height = 6, scale = 0.5)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cost_distribution.pdf", plot = plot_cost_distribution, width = 6, height = 6, scale = 0.5)
```


#------------------------------------------------------------------


#1. ANALYZE COMET




##_a) ENRICHMENT EFFICIENCY
###__i) counts
df
```{r}
enrichment_efficiency_count_df <- comet %>% 
  distinct( condition, replicate,sequence, phospho) %>% 
  group_by( condition, replicate, phospho) %>% 
  summarize(
    num_phospho = n()) %>% 
  pivot_wider(names_from = phospho, values_from = num_phospho) %>% 
  mutate(
    total_pept = none + phospho,
    individual_phosphopept_enrich_efficiency = phospho / total_pept) %>% 
  ungroup() %>% 
  group_by( condition) %>% 
  mutate(
    avg_phosphopeptide_enrichment_efficiency = mean(individual_phosphopept_enrich_efficiency)) %>% 
  ungroup() %>% 
  mutate(
    sample_id = paste(condition, replicate, sep = "_") )


##view df of phosphopeptide enrichment efficiency ratios
enrichment_efficiency_count_df
```



plot
```{r}
plot_ppept_enrich_efficiency <- ggplot() +
  geom_bar(data = (enrichment_efficiency_count_df %>%
                     mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")) %>%
                     distinct(condition, avg_phosphopeptide_enrichment_efficiency)),
           mapping = aes(x = condition, y = avg_phosphopeptide_enrichment_efficiency),
           stat = "identity", alpha = 1, fill = "gray80") + 
  geom_jitter(data = enrichment_efficiency_count_df,
              mapping = aes(x = condition, y = individual_phosphopept_enrich_efficiency, fill = replicate), shape = 1,
              width = 0.25, show.legend = FALSE) +
  geom_hline(yintercept = 0.96, linewidth = 1, alpha = 0.5, linetype = 2) +
  annotate(geom = "text",x = 3, y = 0.88, label = ">96%\npurity", size = 4, lineheight = 0.75) +
  theme_bw(14) +
  theme(legend.position = "none") +
  ylab("p-/all pept (count)") +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.25, hjust = 1)) +
  # scale_y_continuous(expand = c(0,0)) +
  expand_limits(y = c(0, 1)) +
  alexis_theme()+
  scale_y_continuous(expand = c(0,0))
  ## ggtitle("Phosphopeptide enrichment efficiency")

plot_ppept_enrich_efficiency
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/phospho_pept_enrich_efficiency_counts.png", plot = plot_ppept_enrich_efficiency, width = 6, height = 8, scale = 0.5)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/phospho_pept_enrich_efficiency_counts.pdf", plot = plot_ppept_enrich_efficiency, width = 6, height = 9, scale = 0.5)
```


###__ii) intensity
df
```{r}
enrichment_efficiency_intensity_df <- comet %>% 
  distinct(sequence,  condition, replicate, phospho, intensity) %>% 
  group_by(sequence,  condition, replicate, phospho) %>% 
  
##filter by max intensity for every peptide
  filter(intensity  == max(intensity)) %>% 
  ungroup() %>% 
  group_by(phospho, condition, replicate) %>% 
  
##summarize intensity of all peptides and just p-peptides
  summarise(all_peptides_intensity = sum(intensity)) %>% 
  pivot_wider(values_from = all_peptides_intensity, names_from = phospho) %>% 
  
##grouped mutate for taking mean of summed intensities for each replicate within each condition  
  group_by(condition) %>%   
  mutate(mean_phos = mean(phospho),
         mean_non = mean(none)) %>% 
  ungroup() %>% 
  mutate(mean_ratio = mean_phos / (mean_non + mean_phos),
         rep_ratio = phospho / (none + phospho)) %>% 
  ungroup() %>% 
  mutate(
    sample_id = paste(condition, replicate, sep = "_") )
  
  
  enrichment_efficiency_intensity_df
```



plot
```{r}
##relative to intensity of all peptides (with and without phospho)

plot_ratio_phos_intensity <- ggplot(data = (enrichment_efficiency_intensity_df %>%
                                              mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")))) + 
  geom_bar(aes(x = condition, y = mean_ratio),
           stat = "identity",
           position = "dodge",
           fill = "skyblue2") +
  geom_point(aes(x = condition,
                 y = rep_ratio,
                 fill = replicate),
             mod_residue = position_jitterdodge(dodge.width = 0.35), alpha = 1, size =2, shape = 1, show.legend = FALSE) +
  geom_hline(yintercept = 0.977, linewidth = 1, alpha = 0.5, linetype = 2) +
  annotate(geom = "text",x = 3, y = 0.87, label = "> 97%\npurity", size = 4) +
  alexis_theme()+
  scale_y_continuous(expand = c(0,0))+ 
  expand_limits(y = c(0, 1.005)) +
  # theme_bw(14) +
  # theme(axis.text.x = element_text(angle=90, vjust = 0.25, hjust = 1), legend.position = "none") +
  # theme(legend.position = "none") +
  ylab("p-/all pept (intensity)") + xlab("conditions")

plot_ratio_phos_intensity
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/phospho_pept_intensity_ratio.png", plot = plot_ratio_phos_intensity, width = 6, height = 8, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/phospho_pept_intensity_ratio.pdf", plot = plot_ratio_phos_intensity, width = 6, height = 9, scale = 0.5)
```
##_a) plot total phosphopeptides per sample: 
```{r}
plot_ppept_detections <- ggplot() +
  geom_bar(data = (enrichment_efficiency_count_df %>%
                     mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")) %>% 
                     ungroup() %>% 
                     group_by(condition) %>% 
                     mutate(
                       mean_phospho = mean(phospho)) %>% 
                     distinct(condition, mean_phospho)),
           
           mapping = aes(x = condition, y = mean_phospho),
           stat = "identity", alpha = 1, fill = "gray80") + 
  geom_jitter(data = enrichment_efficiency_count_df,
              mapping = aes(x = condition, y = phospho,
                            # color = replicate,
                            fill = replicate), shape = 21,
              width = 0.25, show.legend = FALSE, stroke = 0.5, size = 3) +
  # geom_hline(yintercept = 12000, linewidth = 0.5, alpha = 0.5, linetype = 2) +
  # annotate(geom = "text",x = 7.5, y = 10000, label = ">12,000\np-peptides", size = 4, lineheight = 0.75) +
  theme_bw(14) +
  theme(legend.position = "none") +
  ylab("unqiue p-peptides") +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.25, hjust = 1)) +
  # scale_y_continuous(expand = c(0,0)) +
  scale_fill_brewer(palette = "Purples") +
  expand_limits(y = c(0, 2500)) +
  alexis_theme()+
  # ylim(0, 15000) +
  scale_y_continuous(expand = c(0,0)) #removes whitespace below bars!
  ## ggtitle("Phosphopeptide enrichment efficiency")

plot_ppept_detections
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/phospho_pept_counts_noAscore.png", plot = plot_ppept_detections, width = 10, height = 10, scale = 0.5)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/phospho_pept_counts_noAscore.pdf", plot = plot_ppept_detections, width = 10, height = 10, scale = 0.5)
```


##_e)  OVERALL ITENSITY
```{r}
plot_psm_intensity_distribution_reps <- ggplot(data = comet %>%
                                                 mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"))) +
  geom_boxplot(mapping = aes(x = condition, y = log2(intensity), fill = as.factor(replicate)),
               outlier.shape = 21,
               outlier.alpha = 0.3) +
  theme_bw(18) +
  theme(legend.position = "none") +

  scale_fill_brewer(palette = "PuBu") +
  theme(axis.text.x = element_text(angle=90, vjust = 0.25, hjust = 1), legend.position = "none") +
  ylab(expression(log[2]~(intensity))) + xlab("condition") +
  ggtitle("Intensity of all PSMs")

plot_psm_intensity_distribution_reps


ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_psm_intensity_distribution_reps.png", plot = plot_psm_intensity_distribution_reps, width = 16, height = 16, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_psm_intensity_distribution_reps.pdf", plot = plot_psm_intensity_distribution_reps, width = 16, height = 16, scale = 0.4)
```
pink replicate perhaps is lower intensity related to bead amount.


#------------------------------------------------------------------

#2. ANALYZE ASCORE
##a. N DISTINCT P-SITES 

###__i. total:
```{r}
distinct_p_sites_total <- ascore_fasta_protein_mod_loc %>% 
  distinct(reference, mod_position_in_protein, mod_res) %>%
  mutate(filter_level = "3 reps in 1 condition")
```


#### . . . . summarized count for text (PUB)
```{r}
distinct_pY_sites_total_summary <- distinct_p_sites_total %>% 
  group_by(mod_res) %>% 
  summarize(
    n_distinct_sites = n()) %>% 
  ungroup()

distinct_pY_sites_total_summary
```


#### . . . . plot
```{r}
plot_distinct_p_sites_total <- ggplot(data = distinct_p_sites_total) +
  geom_bar(mapping = aes(x = filter_level, fill = mod_res)) +
  theme_bw(18) +
  scale_fill_viridis_d() +
  ylab("unique phospho sites") +
  alexis_theme()+
  expand_limits(y = c(0, 2000)) +
  scale_y_continuous(expand = c(0,0))
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.25, hjust = 1))

plot_distinct_p_sites_total

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_total.png", plot = plot_distinct_p_sites_total, width = 6, height = 8, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_total.pdf", plot = plot_distinct_p_sites_total, width = 8, height = 8, scale = 0.4)
```
#### . . . . overlap with databases (just detected)
```{r}
distinct_pY_sites_total_DB_comparison <- distinct_p_sites_total %>% 
  filter(mod_res == "Y") %>% 
  rename(mod_residue = mod_position_in_protein) %>% 
  #I want to join on reference to human_fasta_2024 but then use gene name from FASTA gene names
  left_join(y = master_FASTA %>% #keep gene name from fasta_gene_names
              distinct(reference, gene), by = "reference") %>% 
  
  # left_join(human_fasta_2024 %>% distinct(reference, gene) %>% separate(gene, into = c("gene", "organism_del"), sep = "_") %>% select(-organism_del), by = "reference") %>% 
  distinct(gene, reference, mod_res, mod_residue, filter_level) %>% 
  
  
  # full_join(overlap_PSP_PTMSEA, by = c("reference",  "mod_res", "mod_residue")) %>% 
  full_join(PSP_vs_PTMSigDB_EGF_matches, by = c("gene",  "mod_res", "mod_residue")) %>%
  
  #gene names don't match between DB and this study data. 
  mutate(
    DB_pY_detected = case_when(
      !is.na(filter_level) & !is.na(DB_overlap) ~ "shared",
      !is.na(filter_level) & is.na(DB_overlap) ~ "only this study",
      !is.na(DB_overlap) & is.na(filter_level) ~ "DB only",
      TRUE ~ "what happened here?")) %>% 
    #default to gene name from this study for shared sites, DB gene name for diff sites, then collapse to single pY site per gene to consolidate multiple references. 
    # gene = case_when(
    #   DB_pY_detected == "shared" ~ gene.x, #take gene name from human_fasta_2024
    #   DB_pY_detected == "only this study" ~ gene.x,
    #   DB_pY_detected == "DB only" ~ gene.y)) %>% 
  distinct(gene, mod_res, mod_residue, DB_pY_detected, filter_level) %>% 
  
  
  group_by(gene, mod_res, mod_residue) %>%
  mutate(n_duplicates_per_gene = n()) %>% 
  ungroup() %>% 
   
  group_by(DB_pY_detected) %>% #temporary asssessment of overlap, duplicated per row.
  mutate(n_intersecting_pY_sites = n()) %>%
  # mutate(n_intersecting_pY_sites = n_distinct(gene, mod_res, mod_residue)) %>% 
  ungroup()

```
Intersections of pY sites detected doesn't change the overlap ratios significantly. 

  - 907 pY site unique to this study. 

  - 459 pY sites in databases only. 

  - 215 pY sites shared with databases. 
  
_Long story short, I think two options seem reasonable:_

_1._ Keep the statement that 466 of the annotated EGF pY sites were not regulated in this study - not bothering to compare mere detections.

_2._ Indicate both detected and regulated pY site intersection sizes . 

Something like:

"Of the 1,122 pY sites detected and passing the completeness filter but not necessarily regulated, 215 were previously annotated as EGF-responsive, while 907 were unique to this study, and 459 were not previously annotaed. The distribution was similar for regulated pY sites. 0f the 878 pY sites found to be regulated in this study, ~19% (171) were previously annotated,  ~80% (705) of the regulated pY sites were not in either database and 77% (466)  were not identified as regulated here. "



###__ii. by condition:

#### . . . . filter for distinct phospho sites


```{r}
distinct_p_sites_condition <- ascore_fasta_protein_mod_loc %>% 
  distinct(reference, mod_protein_location, mod_res, condition)
##this collapses all  replicates into a single set of unique p sites.
```

#### . . . . write to csv 
write to csv distinct pSTY sites per condition

```{r}
write_csv(x = distinct_p_sites_condition, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pSTYsites_ascore13_condition.csv", col_names = TRUE)
```

#### . . . . plot
plot number of distinct phospho sites 
-look at relative fraction of STY and compare to human ratios.

```{r}
plot_distinct_p_sites_condition <- ggplot(data = distinct_p_sites_condition %>% 
                                            mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"))) +
  geom_bar(mapping = aes(x = condition, fill = mod_res)) +

  scale_fill_viridis_d() +
  ylab("unique phospho sites") +
  xlab("EGF stimulation time (min)") +
  labs(fill = "modified\nresidue")+
  alexis_theme()+
  # expand_limits(y = c(0, 2000)) +
  scale_y_continuous(expand = c(0,0), limits = c(0, 2000), breaks = c(seq(0, 2000, 500))) +
  theme(axis.text.x = element_text(angle = 00, vjust = 1, hjust = 0.5),
        legend.justification = "center",
        legend.title= element_text(size = 14, family = "sans"),
        # Margins around the full legend area
    legend.box.margin = margin(0, 0, 0, 0, "cm"), 
    # Background of legend area: element_rect()
    legend.box.background = element_blank(), 
    # The spacing between the plotting area and the legend box
    legend.box.spacing = unit(0.2, "cm"),
    # Change legend key size and key width
  legend.key.size = unit(1, "cm"),
  legend.key.width = unit(0.5,"cm")  ) +
    scale_x_discrete( labels = c("unt.", "1'", "3'", "5'", "15'"))

plot_distinct_p_sites_condition

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_condition.png", plot = plot_distinct_p_sites_condition, width = 8, height = 8, scale = 0.5)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_condition.pdf", plot = plot_distinct_p_sites_condition, width = 8, height = 8, scale = 0.4)
```
####. . . . counts
```{r}
counts_distinct_psites_condition <- distinct_p_sites_condition %>% 
  distinct() %>% 
  group_by(condition, mod_res) %>% 
  summarize(
    n_distinct_sites = n()) %>% 
  ungroup() %>% 
  group_by(condition) %>% 
  mutate(total_sites = sum(n_distinct_sites)) %>% 
  ungroup() %>% 
  mutate(
    ratio_pY_sites = n_distinct_sites / total_sites * 100) %>% 
  group_by(mod_res) %>% 
  mutate(
    average_pYsite_percent = mean(ratio_pY_sites) ) %>% 
  ungroup()

counts_distinct_psites_condition
```
###__iii. by replicate

#### . . . . filter for distinct phospho sites

df
```{r}
distinct_p_sites_reps <- ascore_fasta_protein_mod_loc %>% 
  ungroup() %>% 
  # filter(replicate %in% c("01", "02", "03", "1", "2", "3")) %>% #distinct(replicate) - successfully downsampled to 3 reps 
  distinct(condition, replicate, sample_id, reference, mod_protein_location, mod_res)
##this collapses all  replicates into a single set of unique p sites.
```


#### . . . . write to csv
```{r}
write_csv(x = distinct_p_sites_reps, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pSTYsites_ascore13_reps.csv", col_names = TRUE)
```

#### . . . . plot
```{r}
plot_distinct_p_sites_reps <- ggplot(data = distinct_p_sites_reps %>% 
                                       mutate(sample_id = fct_relevel(sample_id,
                                                                      "EGF0min rep1","EGF0min rep2","EGF0min rep3","EGF0min rep4","EGF0min rep5","EGF0min rep6", "EGF0min rep10","EGF0min rep20", "EGF0min rep30","EGF0min rep40","EGF0min rep50","EGF0min rep60",
                                                                      "EGF1min rep1","EGF1min rep2","EGF1min rep3","EGF1min rep4","EGF1min rep5","EGF1min rep6","EGF1min rep10","EGF1min rep20",
                                                                      "EGF3min rep1","EGF3min rep2","EGF3min rep3","EGF3min rep4","EGF3min rep5","EGF3min rep6","EGF3min rep10","EGF3min rep20","EGF3min rep30",
                                                                      "EGF5min rep1","EGF5min rep2","EGF5min rep3","EGF5min rep4","EGF5min rep5","EGF5min rep6","EGF5min rep10","EGF5min rep20",
                                                                      "EGF15min rep1","EGF15min rep2","EGF15min rep3","EGF15min rep4","EGF15min rep5","EGF15min rep6", "EGF15min rep10","EGF15min rep20")))+
  geom_bar(mapping = aes(x = sample_id, fill = mod_res)) +
  theme_bw(10) +
  scale_fill_viridis_d() +
  ylab("unique phospho sites")  +
  alexis_theme()+
  expand_limits(y = c(0, 1000)) +
  scale_y_continuous(expand = c(0,0)) 
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.25, hjust = 1))

plot_distinct_p_sites_reps

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_reps.png", plot = plot_distinct_p_sites_reps, width = 10, height = 7, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_reps.pdf", plot = plot_distinct_p_sites_reps, width = 15, height = 12, scale = 0.4)
```




#### . . . . psites per ppm error
```{r}
psites_ppm_joined <- distinct_p_sites_reps %>%
  group_by(condition, replicate) %>%
  distinct(reference, mod_protein_location) %>% 
  mutate(n_unique_psites = n()) %>% 
  ungroup() %>% 
  distinct(condition, replicate, n_unique_psites) %>% 
  left_join(y = (ascore %>%
              group_by(raw_file_name) %>% 
              mutate(median_ppm = median(ppm)) %>% 
              ungroup() %>% 
              distinct(condition, replicate, raw_file_name, median_ppm)), by = c("condition", "replicate"))

###plot ------------------------------
ppm_psites <- ggplot(data = psites_ppm_joined %>% mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"))) +
  geom_point(mapping = aes(x = median_ppm, y = n_unique_psites, fill = raw_file_name), shape = 21, size = 4) +
  geom_line(mapping = aes(x = median_ppm, y = n_unique_psites)) +
  alexis_theme() +
  scale_fill_viridis_d() + facet_wrap(facets = vars(condition),nrow = 1) +
  theme(legend.position = "top")

ppm_psites
```
correaltion between end of runs, increased ppm error and decreased psite identification. But cannot be sure ppm error is the true reason last reps/runs had lower psites.Could have been other technical error like pipetting or processing order. Or evaporation in vial... I remember resuspending rep 6 slightly differently and that could also explain this.

table and error bar df 
```{r}
summarize_distinct_psites_replicates <- distinct_p_sites_reps %>%
  ungroup() %>% 
  group_by(condition, replicate, sample_id, mod_res) %>% 
  summarize(
    n_psites = n()) %>% 
  ungroup()

summarize_distinct_psites_replicates



#errorbar ------------------------------------------------------------
df_geom_errorbar <- summarize_distinct_psites_replicates %>%
  group_by(condition, mod_res) %>%
  mutate(
    min_psites = min(n_psites), 
    max_psites = max(n_psites), 
    mid_psites = mean(n_psites)) %>% 
  ungroup() %>% 
  distinct(condition, mod_res, min_psites, max_psites) #could also include mid psites later if needed

df_geom_errorbar
```
###__iii) condition + replicate as dots


plot
```{r}
plot_distinct_p_sites_condition_reps_wPTS <- ggplot() +
  geom_bar(data = (distinct_p_sites_condition %>%
                     filter(grepl("pool", condition) == FALSE) %>% 
                     mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"))),
                   mapping = aes(x = condition, fill = mod_res),show.legend = FALSE) +
  
  geom_errorbar(data = (df_geom_errorbar %>%
                          filter(grepl("pool", condition) == FALSE) %>% 
                          mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"))),
                mapping = aes(x = condition, ymin = min_psites, ymax = max_psites),  show.legend = FALSE, linewidth = 0.5, width = 0.25, color = "grey90") +
  
  
  geom_jitter(data = (distinct_p_sites_reps%>%
                        filter(grepl("pool", condition) == FALSE) %>% 
                        mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"))),
              mapping = aes(x = condition, color = sample_id, fill = mod_res),
              stat = "count", shape = 1, show.legend = FALSE, size = 1, stroke =0.5,
              width = 0.35, height = 0, alpha = 0.5) +
   
  theme_bw(10) +
  facet_wrap(facets = vars(mod_res), ncol = 3) +
  scale_fill_viridis_d() +
  scale_color_manual(values = rep(c("grey70" ),60)) +
  ylab("unique phospho sites")   +
  alexis_theme()+
  scale_y_continuous(expand = c(0,0))
  # theme(axis.text.x = element_text(angle = 30, vjust = 0.99, hjust = 1, size = 10))

plot_distinct_p_sites_condition_reps_wPTS

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_condition_wPTS.png", plot = plot_distinct_p_sites_condition_reps_wPTS, width = 6, height = 6, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_p_sites_condition_wPTS.pdf", plot = plot_distinct_p_sites_condition_reps_wPTS, width = 6, height = 6, scale = 0.4)
```

####___iv) focus on pY
```{r}
plot_distinct_p_sites_condition_reps_wPTS <- ggplot() +
  geom_bar(data = (distinct_p_sites_condition %>%
                     filter(grepl("pool", condition) == FALSE) %>% 
                     mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")) %>% filter(mod_res == "Y")),
                   mapping = aes(x = condition, fill = mod_res),show.legend = FALSE, color = "black", size = 0.5) +
  
  
  
  
  geom_jitter(data = (distinct_p_sites_reps%>%
                        filter(grepl("pool", condition) == FALSE) %>% 
                        mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")) %>% filter(mod_res == "Y")),
              mapping = aes(x = condition, color = sample_id, fill = mod_res),
              stat = "count", shape = 1, show.legend = FALSE, size = 1, stroke =0.5,
              width = 0.25, height = 0, alpha = 0.5) +
  
  geom_errorbar(data = (df_geom_errorbar %>%
                          filter(grepl("pool", condition) == FALSE) %>% 
                          mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")) %>% filter(mod_res == "Y")),
                mapping = aes(x = condition, ymin = min_psites, ymax = max_psites),  show.legend = FALSE, linewidth = 0.5, width = 0.25, color = "grey30") +
   
  # theme_bw(10) +
  facet_wrap(facets = vars(mod_res), ncol = 3) +
  scale_fill_viridis_d(direction = -1) +
  scale_color_manual(values = rep(c("grey30" ),60)) +
  ylab("unique phospho sites")   +
  alexis_theme()+
  scale_y_continuous(expand = c(0,0)) +
  expand_limits(y = c(0, 1200)) +
  theme(axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0, size = 12))

plot_distinct_p_sites_condition_reps_wPTS

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_pY_sites_condition_wPTS.png", plot = plot_distinct_p_sites_condition_reps_wPTS, width = 6, height = 8, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/distinct_pY_sites_condition_wPTS.pdf", plot = plot_distinct_p_sites_condition_reps_wPTS, width = 6, height = 6, scale = 0.4)
```

#LIST OF pY SITES FOR CORAL
get total pY sites per uniprot ID to map in coral. regulated is not a requirement.

```{r}
n_pYsites_per_uniprot <- distinct_p_sites_condition %>%
  filter(mod_res == "Y") %>% 
  group_by(reference) %>% 
  summarize(
    n_pY = n_distinct(mod_protein_location)) %>% 
  ungroup()

write_csv(x = n_pYsites_per_uniprot, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/n_pYsites_per_uniprot.csv")
```

coral plots and input data saved to output>>> CORAL/
#====================================
#ONLY PY SITES FROM HERE ONWARDS_
#====================================
#master ref of all pY sites
```{r}
ascore_fasta_protein_mod_loc_pY <- ascore_fasta_protein_mod_loc %>% 
  filter(mod_res == "Y")

ascore_fasta_protein_mod_loc_pY_sum_psite <- ascore_fasta_protein_mod_loc_sum_psite %>% 
  filter(mod_res == "Y")
```

### ---SUPP FILE 2 list of proteins endosomal recycling/degradation
```{r}
endosome_proteins <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  left_join(fxns_fasta, by = "reference") %>% 
  filter(grepl("endosom|clathrin", subcellular_location_cc) ==TRUE | grepl("endosom|clathrin", gene_ontology_cellular_component) ==TRUE) %>% 
  distinct(reference, gene_redundancy, protein_names, subcellular_location_cc, gene_ontology_cellular_component)


lysosome_proteins <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  left_join(fxns_fasta, by = "reference") %>% 
  filter(grepl("lyso", subcellular_location_cc) ==TRUE | grepl("lyso", gene_ontology_cellular_component) ==TRUE) %>% 
  distinct(reference, gene_redundancy, protein_names, subcellular_location_cc, gene_ontology_cellular_component)
  
```



###--- SHINY ALL pY SITES DATAFRAME for boxplots
2025 Oct 08
```{r}
#Get most common protein family (aka gene_redundancy info):
#dataframe for SHINY interactive dataset:
most_common_protein_family_per_site <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  filter(!is.infinite(median_norm_intensity)) %>% 
  separate(col = ref, into = c("del", "mod_site"), sep = "_", remove = FALSE) %>%
  select(-del) %>% 
  left_join(y = master_FASTA %>%  distinct(reference, gene), by = "reference") %>% 
  mutate(gene_ref = paste(gene, mod_site, sep = "_")) %>% 
  rename(n_obs = n_obs_per_condition) %>% 
  #keep most common gene_redundnacy info
  group_by(gene_ref, gene_redundancy) %>% 
  mutate(n_obs_gene_redundancy = n()) %>% 
  ungroup() %>% 
  distinct(gene_ref, gene_redundancy, n_obs_gene_redundancy) %>% 
  group_by(gene_ref) %>% 
    mutate(most_common_gene_redundancy = max(n_obs_gene_redundancy)) %>% 
  filter(n_obs_gene_redundancy == most_common_gene_redundancy) %>% 
    distinct(gene_ref, gene_redundancy,most_common_gene_redundancy)
  
  #note to self, or future readers: To revert back to granualar and peptide specific redunancy assignments, remove the code above that starts at comment: '#keep most common gene_redundnacy info' and no further need to left join to the full dataframe. I switched to taking the most common gene redundnacy info/ aka protein groups, becuase the hover toool in the shiny app took the first or shortest redundancy list even if the list was not the most common occurence of that peptide. I cross-checked CDK1 vs. CDK3 in proteome data, for whcih CDK1 is well measured while CDK3 is seen in unambiguously CDK1|2|3 or CDK2|3 forms only. It is still possible that the CDK3 is the uniquely phosphorylated version, but given few occurences of the CDK3 n-terminal speicifc peptide, and much mroe pervasive ambiguous assignment, I believe it is reasonable to maintain the ambiguity and extend the filter to most commonly observed protein/gene family ambiguity.
    
write_csv(most_common_protein_family_per_site, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/KEY_most_common_protein_family_per_site.csv")



#dataframe for SHINY interactive dataset:
SHINY_pY_SITE_input <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  filter(!is.infinite(median_norm_intensity)) %>% 
  separate(col = ref, into = c("del", "mod_site"), sep = "_", remove = FALSE) %>%
  select(-del) %>% 
  left_join(y = master_FASTA %>%  distinct(reference, gene), by = "reference") %>% 
  mutate(gene_ref = paste(gene, mod_site, sep = "_")) %>% 
  rename(n_obs = n_obs_per_condition) %>%
  select(-c(proteins, gene_redundancy)) %>% 
  distinct() %>% 
  left_join(most_common_protein_family_per_site, by = "gene_ref") %>% 
  mutate(redundancy = as.numeric(redundancy),
         ambiguous = case_when(redundancy == 0 ~ "single protein assignment",
                               redundancy >=1 ~ paste("ambiguous protein assignment,", redundancy +1, "proteins", sep = " "))) %>% 
  left_join(fxns_fasta %>% distinct(reference, protein_names), by = "reference" )
  

write_csv(SHINY_pY_SITE_input, "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/SHINY_pY_SITE_input.csv" )
```



##0.)  location of pY along protein sequence
```{r}
psite_location <- ascore_fasta_protein_mod_loc_pY %>%
  mutate(
    protein_length = str_length(full_protein_sequence)) %>% 
   
  mutate(
    # mod_position_in_protein = as.numeric(str_sub(mod_loc, start = 2L)),
    position_ratio = mod_position_in_protein / protein_length) %>% 
  # filter(!is.na(position_ratio)) %>% 
  distinct(condition, ref, position_ratio)


#histogram------------------------------------
    #define range
breaks <- seq(min(psite_location$position_ratio), max(psite_location$position_ratio), length.out = 100)

plot_psite_position_in_protein_histogram <- ggplot(data = psite_location)  +
  geom_histogram(mapping = aes(x = position_ratio, fill = condition),binwidth =  NULL, breaks = breaks) +
  theme_bw(18) + 
  facet_grid(rows = vars(condition))

plot_psite_position_in_protein_histogram

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_psite_position_in_protein_histogram.png", plot = plot_psite_position_in_protein_histogram, width = 20, height = 16, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_psite_position_in_protein_histogram.pdf", plot = plot_psite_position_in_protein_histogram, width = 20, height = 16, scale = 0.4)
```
As expected, some enrichment at C-term and a bit at the N-terminus. not too different from global phospho.



##00.) n-terminal processing
```{r}
Nterm_mod_ascore_pY_listofpYsites <- ascore_fasta_protein_mod_loc_pY %>% 
  distinct( ref, seq_no_mods, full_protein_sequence, mod_position_in_protein) %>% 
  mutate(peptide_position = str_locate(full_protein_sequence, seq_no_mods),
         
         #turn matrix into normal dataframe columns by binding columns explicitly
         start = peptide_position[,1],
         end = peptide_position[,2]) %>% 
  select(-peptide_position) %>% 
  filter(start <= 2) #get p-sites found on peptides with known N-terminal processing info measured. 

                    #we do see a number of pY sites found at the N-termini, but there is a tryptic cut site that removed the actually N-termini from what we detected in the pY pulldown. and total proteome data has poor overlap with pY pulldown.


Nterm_mod_ascore_pY <- ascore_fasta_protein_mod_loc_pY %>% 
  filter(ref %in% Nterm_mod_ascore_pY_listofpYsites$ref) %>% 
  mutate(
    Nterm_mod_type = case_when(
      str_sub(ascore_sequence, start = 1L, end = 1L) == "M" ~ "not clipped\nnot acetylated",
      str_sub(ascore_sequence, start = 1L, end = 3L) == "n#M" ~ "not clipped\nyes acetylated",
      str_sub(ascore_sequence, start = 1L, end = 3L) != "n#M" & str_sub(ascore_sequence, start = 1L, end = 2L) == "n#" ~ "yes clipped\nyes acetylated",
      str_sub(ascore_sequence, start = 1L, end = 3L) != "n#M" & str_sub(ascore_sequence, start = 1L, end = 1L) != "M" ~ "yes clipped\nnot acetylated",
      TRUE ~ "not classified" )) %>% # all are classified!
  distinct( ref, Nterm_mod_type) %>% 
  group_by(Nterm_mod_type) %>% 
  mutate(
    n_unique_pYsites = n()) %>% 
  ungroup()


x_axis_labels = c("not clipped\nnot acetylated", "yes clipped\nnot acetylated", "not clipped\nyes acetylated", "yes clipped\nyes acetylated")

plot_nterm_modtypes_condition <-  ggplot(data = Nterm_mod_ascore_pY) +
  geom_bar(mapping = aes(x = Nterm_mod_type), width = 0.5) + 
  geom_text(data = Nterm_mod_ascore_pY %>% distinct(Nterm_mod_type, n_unique_pYsites), mapping = aes (x = Nterm_mod_type, y = n_unique_pYsites + 1, label = paste0(n_unique_pYsites)), size = 6) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -60, hjust = 0, vjust = 0.9, size = 14)) +
  scale_y_continuous(expand = c(0,0), limits = c(0, 20), breaks = c(seq(0, 20, 5))) +
  scale_x_discrete(limits = x_axis_labels,breaks = x_axis_labels, labels = x_axis_labels) +
  xlab("N-terminal processing type") +
  ylab("n unique pY sites")

plot_nterm_modtypes_condition

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_nterm_modtypes_condition.png", plot = plot_nterm_modtypes_condition, width = 12, height = 12, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_nterm_modtypes_condition.pdf", plot = plot_nterm_modtypes_condition, width = 12, height = 12, scale = 0.4)
```

#3.) PSITE OVERLAPS
##a). UPSET overlaps

###__i) replicate

```{r}
df_overlaps_reps <- ascore_fasta_protein_mod_loc_pY %>% 
  ungroup() %>% 
  distinct(condition, replicate, sample_id, ref) %>% 
  mutate(psite_present = 1) %>% 
  pivot_wider(names_from = sample_id, values_fill = 0, values_from = psite_present, id_cols = ref)

df_overlaps_reps_less <- df_overlaps_reps %>% 
  select(-ref) %>% 
  mutate_all(.funs = as.numeric) %>% 
  as.matrix() %>% 
  as.data.frame()

upset_plot_reps <- upset(data = df_overlaps_reps_less, nsets = 30, order.by = "freq", text.scale = 3, nintersects = 30) 
upset_plot_reps


png("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/upset_plot_reps_pYsites.png", width = 1000, height = 600)
print(upset_plot_reps)
dev.off()


pdf("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/upset_plot_reps_pYsites.pdf", width = 12, height = 8)
print(upset_plot_reps)
dev.off()
```

###__i) condition

```{r}
df_overlaps_condition <- ascore_fasta_protein_mod_loc_pY %>% 
  ungroup() %>% 
  distinct(condition,  ref) %>% 
  mutate(psite_present = 1) %>% 
  pivot_wider(names_from = condition, values_fill = 0, values_from = psite_present, id_cols = ref)

df_overlaps_condition_less <- df_overlaps_condition %>% 
  select(-ref) %>% 
  mutate_all(.funs = as.numeric) %>% 
  as.matrix() %>% 
  as.data.frame()

upset_plot_condition <- upset(data = df_overlaps_condition_less, nsets = 7, order.by = "freq", text.scale = 3, nintersects = 30) 
upset_plot_condition


png("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/upset_plot_condition_pYsites.png", width = 1000, height = 600)
print(upset_plot_condition)
dev.off()


pdf("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/upset_plot_condition_pYsites.pdf", width = 12, height = 8)
print(upset_plot_condition)
dev.off()
```





##b). intensity per condition overlap
variation in psite localizations correlates with intensity
```{r}
psite_overlaps_condition <- df_overlaps_condition %>% 
  ungroup() %>% 
  pivot_longer(cols = c( EGF0min, EGF1min, EGF3min, EGF5min, EGF15min), names_to = c("condition")) %>% 
  group_by(ref) %>% 
  mutate(
    n_detections = sum(value)) %>% 
  ungroup()  
  # filter(replicate %in% c(1, 2, 3)) %>% 
  
ascore_psite_overlaps <- ascore_fasta_protein_mod_loc_pY_sum_psite %>% 
  inner_join(y = psite_overlaps_condition %>%  distinct(ref, n_detections), by = c("ref")) %>% 
  mutate(n_detections = as.factor(n_detections))


```

```{r}
#plot
  ## intensity by condition overlaps---------------------------------------------
intensity_distribution_psite_overlaps <- ggplot(data = ascore_psite_overlaps) +
  geom_violin(mapping = aes(x = n_detections, y = median_norm_intensity, fill = condition), draw_quantiles = c(0.25, 0.5, 0.75), show.legend = FALSE) +
  theme_bw(18) +
  theme(strip.text = element_text(size = 8)) +
  facet_wrap(facets = vars(condition), nrow = 1)
intensity_distribution_psite_overlaps
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/intensity_distribution_psite_overlaps.png", plot = intensity_distribution_psite_overlaps, width = 20, height = 10, scale = 0.4)


```


#------------------------------------------------------------------
#4. PROTTI

##_a) CVs
###__i) not normalized
```{r}
all_psite_CVs <- qc_cvs(data = ascore_fasta_protein_mod_loc_pY_sum_psite,
                            grouping = ref,
                            intensity = sum_intensity_precursor_to_psite,
                            condition = condition,
                            plot = FALSE)

all_psite_CVs_plot <- qc_cvs(data = ascore_fasta_protein_mod_loc_pY_sum_psite,
                            grouping = ref,
                            intensity = sum_intensity_precursor_to_psite,
                            condition = condition,
                            plot_style = "violin",
                            plot = TRUE)

#return
all_psite_CVs
all_psite_CVs_plot

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_psite_CVs_plotNotNorm.png", plot = all_psite_CVs_plot, width = 18, height = 14, scale = 0.4)
```


###__ii) normalized
```{r}
all_psite_CVs_NORM <- qc_cvs(data = ascore_fasta_protein_mod_loc_pY_sum_psite,
                            grouping = ref,
                            intensity = raw_median_norm_intensity,
                            condition = condition,
                            plot = FALSE)

all_psite_CVs_plot_NORM <- qc_cvs(data = ascore_fasta_protein_mod_loc_pY_sum_psite,
                            grouping = ref,
                            intensity = raw_median_norm_intensity,
                            condition = condition,
                            plot_style = "violin",
                            plot = TRUE)

#return
all_psite_CVs_NORM
all_psite_CVs_plot_NORM

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_psite_CVs_plot_Norm.png", plot = all_psite_CVs_plot_NORM, width = 18, height = 14, scale = 0.4)

#custom cv function built from protti function
# all_psite_CVs_NORM <- my_qc_cvs(data = ascore_fasta_protein_mod_loc_pY_sum_psite,
#                             grouping = ref,
#                             intensity = raw_median_norm_intensity,
#                             condition = condition,
#                             plot = FALSE)



###run after ascore_gene_clusters_Imputation_noSD which is specified later.
# CV gt 3 observations
# CV_gt3_obs <- ascore_gene_clusters_Imputation_noSD %>%
#   mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>% 
#   filter(gene_ref %in% gt3_obs_for_FC)
# 
# 
# all_psite_CVs_NORM <- my_qc_cvs(data = CV_gt3_obs,
#                             grouping = ref,
#                             intensity = raw_median_norm_intensity,
#                             condition = condition,
#                             plot_style = "violin",
#                             plot = FALSE)
# 
# 
# all_psite_CVs_plot_NORM <- my_qc_cvs(data = CV_gt3_obs,
#                             grouping = ref,
#                             intensity = raw_median_norm_intensity,
#                             condition = condition,
#                             plot_style = "violin",
#                             plot = TRUE)
# 
# #return
# all_psite_CVs_NORM
# all_psite_CVs_plot_NORM
# 
# ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_psite_CVs_plot_Norm.png", plot = all_psite_CVs_plot_NORM, width = 18, height = 14, scale = 0.4)

```
CVs of bio reps are known to be worse than technical replicates. well documented. can cite in recent paper from Beltrao group.

####----intensity normalization checks


QC median normalization of intensities
```{r}
#check median normalization by plotting.

##NOT normalized intensities --------------------------------------------------------
check_all_psite_intensity_before_normalization <- qc_intensity_distribution(
  data = ascore_fasta_protein_mod_loc_pY_sum_psite,
  sample = sample_id, 
  grouping = ref,
  intensity_log2 = log2_psite_qty,
  plot_style = "boxplot")

check_all_psite_intensity_before_normalization

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/check_all_psite_intensity_before_normalization.pdf", plot = check_all_psite_intensity_before_normalization, width = 15, height = 15, scale = 0.5)

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/check_all_psite_intensity_before_normalization.png", plot = check_all_psite_intensity_before_normalization, width = 15, height = 15, scale = 0.5)

##YES normalized intensities --------------------------------------------------------
check_all_psite_intensity_after_normalization <- qc_intensity_distribution(
  data = ascore_fasta_protein_mod_loc_pY_sum_psite,
  sample = sample_id, 
  grouping = ref,
  intensity_log2 = median_norm_intensity,
  plot_style = "boxplot")

check_all_psite_intensity_after_normalization

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/check_all_psite_intensity_after_normalization.pdf", plot = check_all_psite_intensity_after_normalization, width = 15, height = 15, scale = 0.5)

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/check_all_psite_intensity_after_normalization.png", plot = check_all_psite_intensity_after_normalization, width = 15, height = 15, scale = 0.5)

```


##_b) hierarchical clustering

###---protti spearman
```{r}
all_pYsite_correlation <- qc_sample_correlation(
  data = ascore_fasta_protein_mod_loc_pY_sum_psite,
  sample = sample_id, 
  grouping = ref,
  method = "spearman",
  intensity_log2 = median_norm_intensity,
  condition = condition,
  interactive = FALSE)


all_pYsite_correlation

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_correlation_Spearman.png", plot = all_pYsite_correlation, width = 20, height = 20, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_correlation_Spearman.pdf", plot = all_pYsite_correlation, width = 16, height = 12, scale = 0.4)
```

Sweet! even when samples were randomized correlation is good and reveals condition specific grouping!

####----protti pearson
```{r}
all_pYsite_correlation_pearson <- qc_sample_correlation(
  data = ascore_fasta_protein_mod_loc_pY_sum_psite %>% filter(!is.infinite(median_norm_intensity)),
  sample = sample_id, 
  grouping = ref,
  method = "pearson",
  intensity_log2 = median_norm_intensity,
  condition = condition,
  interactive = FALSE)


all_pYsite_correlation_pearson

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_correlation_pearson.png", plot = all_pYsite_correlation_pearson, width = 20, height = 20, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_correlation_pearson.pdf", plot = all_pYsite_correlation_pearson, width = 16, height = 12, scale = 0.4)
```

####----my_hier_cluster pearson
```{r}
all_pYsite_my_correlation_pearson <- my_hier_cluster(
  data = ascore_fasta_protein_mod_loc_pY_sum_psite %>% filter(!is.infinite(median_norm_intensity)), #%>% 
    # mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"),
    #        condition_numeric = case_when(
    #          condition == "EGF0min" ~ 0,
    #          condition == "EGF1min" ~ 1,
    #          condition == "EGF3min" ~ 3,
    #          condition == "EGF5min" ~ 5,
    #          condition == "EGF15min" ~ 15),
    #        sample_id = fct_reorder(sample_id, condition_numeric)),
  breaklist = seq(0.5, 1, by = 0.1),
  sample = sample_id, 
  grouping = ref,
  fontsize_number = 4.5,
  number_color = "black",
  method = "pearson",
  intensity_log2 = median_norm_intensity,
  condition = condition,
  interactive = FALSE)


all_pYsite_my_correlation_pearson

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_my_correlation_pearson.png", plot = all_pYsite_my_correlation_pearson, width = 14, height = 12, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_my_correlation_pearson.pdf", plot = all_pYsite_my_correlation_pearson, width = 14, height = 12, scale = 0.4)


```

easier to read attempt
```{r}
all_pYsite_my_correlation_pearson_noNUMS <- my_hier_cluster_noNUMS(
  data = ascore_fasta_protein_mod_loc_pY_sum_psite %>% filter(!is.infinite(median_norm_intensity)), #%>% 
    # mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min"),
    #        condition_numeric = case_when(
    #          condition == "EGF0min" ~ 0,
    #          condition == "EGF1min" ~ 1,
    #          condition == "EGF3min" ~ 3,
    #          condition == "EGF5min" ~ 5,
    #          condition == "EGF15min" ~ 15),
    #        sample_id = fct_reorder(sample_id, condition_numeric)),
  breaklist = seq(0.5, 1, by = 0.1),
  sample = sample_id, 
  grouping = ref,
  # fontsize_number = 4.5,
  # number_color = NA,
  method = "pearson",
  intensity_log2 = median_norm_intensity,
  condition = condition,
  interactive = FALSE)


all_pYsite_my_correlation_pearson_noNUMS

ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_my_correlation_pearson_noNUMS.png", plot = all_pYsite_my_correlation_pearson_noNUMS, width = 12, height = 12, scale = 0.4)
ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_my_correlation_pearson_noNUMS.pdf", plot = all_pYsite_my_correlation_pearson_noNUMS, width = 16, height = 12, scale = 0.4)


```


##_c) PCA
###__i. scree
```{r}
PCA_df <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  # filter(!is.na(missingness)) %>% 
  filter(median_norm_intensity != -Inf)


all_psite_scree  <- qc_pca(
  data = PCA_df,
  sample = sample_id,
  grouping = ref,
  intensity = median_norm_intensity,
  condition = condition,
  digestion = NULL,
  plot_style = "scree")

all_psite_scree
```

###__ii. PC1 vs. PC2
```{r}
all_pYsite_PC_1_2  <- qc_pca(
  data = PCA_df,
  sample = sample_id,
  grouping = ref,
  intensity = median_norm_intensity,
  condition = condition,
  digestion = NULL,
  plot_style = "pca",
  components = c("PC1", "PC2"))

all_pYsite_PC_1_2

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_PC_1_2.png", plot = all_pYsite_PC_1_2, width = 24, height = 12, scale = 0.4)
```
that is cool grouping! I wonder if MS run order impacted the outliers of EGF0min rep3, EGF1min rep2, EGF3min rep2, EGF15min rep1? NEed to paint PCA by well number and therefore run order. See if these were the runs following washes. 
EGF1min rep2 = first run of my samples, immediately after wash, std, wash

(other post wash samples are not outliers, i.e. 15minrep5, 5minrep3, 3minrep6, 15minrep2)
###__iii. PC1 vs. PC3
```{r}
all_pYsite_PC_1_3  <- qc_pca(
  data = PCA_df,
  sample = sample_id,
  grouping = ref,
  intensity = median_norm_intensity,
  condition = condition,
  digestion = NULL,
  plot_style = "pca",
  components = c("PC1", "PC3"))

all_pYsite_PC_1_3

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/all_pYsite_PC_1_3.png", plot = all_pYsite_PC_1_3, width = 24, height = 12, scale = 0.4)
```


##_d) MISSINGNESS
```{r}
ascore_med_norm_missing <- assign_missingness(
    data = ascore_fasta_protein_mod_loc_pY_sum_psite,
    sample = sample_id, 
    grouping = ref, 
    intensity = median_norm_intensity,
    condition = condition, 
    ref_condition = "all",
    completeness_MAR = 0.5, #require 3 of 6 reps to have to be considered condition specific signature
    completeness_MNAR = 0.2 ) #any time obs is in 1 or less samples per condition, the psite is considered biologically missing.
```




##_e) DIFFERENTIAL ABUNDANCE
without imputation of any kind
```{r}
psite_diff_abundance_noImputation <- ascore_med_norm_missing %>% 
  calculate_diff_abundance(
    sample = sample_id,
    condition = condition, 
    grouping = ref, 
    intensity_log2 = median_norm_intensity,
    missingness = missingness,
    comparison = comparison,
    filter_NA_missingness = TRUE,
    method = "moderated_t-test" ) %>% 
  
  #make all comparisons 0 vs. later time point
  mutate(
    diff = case_when(
      comparison == "EGF0min_vs_EGF1min" ~ -diff,
      comparison == "EGF0min_vs_EGF3min" ~ -diff,
      comparison == "EGF0min_vs_EGF5min" ~ -diff,
      TRUE ~ diff ),
    comparison = case_when(
      comparison == "EGF0min_vs_EGF1min" ~ "EGF1min_vs_EGF0min",
      comparison == "EGF0min_vs_EGF3min" ~ "EGF3min_vs_EGF0min",
      comparison == "EGF0min_vs_EGF5min" ~ "EGF5min_vs_EGF0min",
      TRUE ~ comparison   )  )
```


##_f) VOLCANO PLOT
###__i. plot
```{r}
pYsite_volcano_noImputation <- volcano_plot(
  data = psite_diff_abundance_noImputation %>%
    filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")),
  grouping = ref,
  log2FC = diff,
  significance = pval,
  significance_cutoff = c(0.05, "adj_pval"),
  method = "significant",
  facet_by = comparison)

pYsite_volcano_noImputation
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pYsite_volcano_noImputation.png", plot = pYsite_volcano_noImputation, width = 30, height = 18, scale = 0.4)
```
It is so cool to see the cell biology (phospho signaling) change so quickly upon a perturbation and to change in a way expected.

I am curious to see what these sites are.

Really nice to see the magnitude of number of psites changes to correlate with duration of EGF stimulation!!

I want to next plot this with my custom volcano formatting (i.e. opaque points) and label with 'gene + site' as well as quantify amount of psites changing per condition as a percentage. 

Also, I think I learn by getting my hands dirty, and getting excited about this experiment makes me want to revisit Mario's yeast perturbation paper to see how he dug into a preliminary analysis such as volcano plot upon stress (x100+)

###__i0. total regulated p-Y sites
```{r}
total_regulated_pY_sites_noImputation <- psite_diff_abundance_noImputation %>%
  filter(grepl("_Y", ref) == TRUE) %>% 
        distinct(comparison, ref, diff, adj_pval) %>%
        group_by(comparison) %>%
        mutate(total_psites = n_distinct(ref)) %>%
        ungroup() %>%
        mutate(
          regulated_psite = case_when(
            adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
            TRUE ~ "not regulated")) %>%
        distinct(ref, regulated_psite) %>% 
        group_by(regulated_psite) %>%
        summarize(n_regulated_psites = n())

total_regulated_pY_sites_noImputation
```

_Intro 2024 12 02:_
"Our method not only recapitulates previously observed pY site changes, it reproducibly measures 56 pY sites not before annotated in PhosphoSitePlus, many of which are low abundance. We identify 1651 total pY sites, _425_ of which _significantly change between time points_ and uncover novel signaling events in the context of the well-studied epidermal growth factor stimulation of HeLa cells."

###__ii. overall percent p-sites changing per cell type
```{r}
percent_pYsites_diff_regulated_noImputation <- psite_diff_abundance_noImputation %>%
  distinct(comparison, ref, diff, adj_pval) %>%
  group_by(comparison) %>%
  mutate(total_psites = n_distinct(ref)) %>%
  ungroup() %>%
  mutate(
    regulated_psite = case_when(
      adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
      TRUE ~ "not regulated")) %>%
  group_by(comparison, regulated_psite) %>%
  mutate(n_regulated_psites = n()) %>%
  ungroup() %>%
  distinct(comparison, total_psites, regulated_psite, n_regulated_psites) %>%
  pivot_wider(id_cols = c(comparison, total_psites), names_from = regulated_psite, values_from = n_regulated_psites) %>%
  group_by(comparison) %>%
  mutate(percent_regulated = regulated / total_psites *100)
  

percent_pYsites_diff_regulated_noImputation
```
Wow! really cool to see the amount of psite regulation correlate with extent of EGF stimulation! Suggesting effect correlates with phospho signature in some way at least. now to see which phosphosites... (remember I need to adjust for protein abundance differences if any pair with regulated phosphosites) - also just see if these could be a measurment issue.
Also, only a small percentage of psites detected appear regulated. this is alright, but is it the full truth?

###__iii. percent up/down regulated 
```{r}
percent_pYsite_regulated_noImputation <- psite_diff_abundance_noImputation %>% 
  distinct(comparison, diff, adj_pval, ref) %>% 
  group_by(comparison) %>% 
  mutate(total_psites = n_distinct(ref)) %>%
  ungroup() %>%
  mutate(
    regulated_psite = case_when(
      adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
      TRUE ~ "not regulated"),
    regulated_psite_dir = case_when(
      regulated_psite == "regulated" & diff >= 1 ~ "up",
      regulated_psite == "regulated" & diff <= -1 ~ "down",
      regulated_psite == "not regulated" ~ "not regulated")) %>%
  group_by(comparison, regulated_psite_dir) %>% 
  mutate(n_regulated_psites = n()) %>% 
  ungroup() %>% 
  distinct(comparison, total_psites, regulated_psite, n_regulated_psites, regulated_psite_dir) %>% 
  pivot_wider(id_cols= c(comparison, total_psites), names_from = regulated_psite_dir, values_from = n_regulated_psites) %>% 
  group_by(comparison) %>% 
  mutate(percent_upregulated = up / total_psites*100,
         percent_downregulated = down / total_psites*100)
  

percent_pYsite_regulated_noImputation
```
###__iv. my volcano plot
```{r}

# EGF15min vs. EGF0min (aka control/ untreated) ------------------------------------------------------

my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = psite_diff_abundance_noImputation %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>% 
               # filter(abs(diff) < 1) %>% 
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = psite_diff_abundance_noImputation %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = psite_diff_abundance_noImputation %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff < -1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "blue", alpha = 0.1, shape =19) +
  geom_point(data = psite_diff_abundance_noImputation %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(diff > 1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "red", alpha = 0.1, shape =19) +
  theme_bw(18) +
  facet_wrap(facets = vars(comparison)) #+
  # scale_x_continuous(name = "Log2(fold change)", breaks = seq(-8, 8, 2), limits = c(-8, 8)) +
  # scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,20,5), limits = c(0, 20))

my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation.png", plot = my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation, width = 10, height = 8, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF15min_vs_EGF0min_noImputation.pdf", plot = my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation, width = 10, height = 8, scale = 0.4)
```


 ###__v. Y color + labels
could be nice to color by pSTY, and to add gene names to volcano with regulated sites. Also write up and down regulated percentages.
```{r}
pYsite_diff_abundance_gene_noImputation <- psite_diff_abundance_noImputation %>%
  separate(col = ref, into = c("reference", "modres_position"), sep = "_", remove = FALSE) %>%
  mutate(mod_res = str_sub(modres_position, start  = 1L, end = 1L),
         mod_residue = as.numeric(str_sub(modres_position, start = 2L))) %>%
  left_join(y = (fasta_gene_names %>% select(entry, gene, protein_names, keyword_id) %>% rename(reference = entry)), by = "reference")
```


##_g) DATABASE ANNOTATION JOIN
This code chunk assesses how many of the pY sites match database annotations from PSP, PTMSigDB and Phosphopedia (only adds BCAR1).

###database gene to entry conversion
```{r}
# overlap_PSP_PTMSEA_converted_entries <- overlap_PSP_PTMSEA %>% 
#   mutate(gene_conversion = paste(gene, "HUMAN", sep = "_"))
# 
# write_delim(x = overlap_PSP_PTMSEA_converted_entries %>% distinct(gene_conversion), file = "2xDB_gene_conversion.txt", col_names = FALSE)
```


_NOT IMPUTED_

EGFR databases(2x)  versus my data:
DATABASE EGFR PATHWAYS
###__i. PSITE joined
#### . . .  . dataframe
```{r}
intermediate_DB_joining_df <- pYsite_diff_abundance_gene_noImputation %>%
  filter(abs(diff) > 1) %>%
  filter (adj_pval <= 0.05) %>%
  rename(psite = modres_position) %>%
  rename(mod_residue = mod_residue) %>% 
  mutate(my_data = TRUE) %>%
  # full_join(y = overlap_PSP_PTMSEA %>% mutate(DB2x = TRUE) %>% select(reference, gene,  mod_residue, mod_res,   PSP, PTM_SEA,DB2x, overlap), by = c("reference", "mod_residue", "mod_res") ) %>%
  full_join(y = PSP_vs_PTMSigDB_EGF_matches, by = c("gene", "mod_res", "mod_residue")) #%>% 
  
  #do genes match purely after matching on reference?
  # mutate(
  #   genes_match = case_when(
  #     gene.x == gene.y ~ "match",
  #     gene.x != gene.y& my_data == TRUE ~ "not_match",
  #     is.na(gene.x) ~ "DB only",
  #     is.na(gene.y) ~ "my_data_only") ) %>% 
  #there are no gene names that differ between matching references. However, there may still be gene names that have multiple references, one of which could match my data, while the other gene and sites are duplicates assigned to a different protein group. Therefore, to keep the analysis at pY site level, I will remove duplicate references per gene name in DB only sites where I went in knowing duplicates occured to give best possible chance of matching to my data.
  # group_by(gene.y, mod_res, mod_residue) %>% 
  # mutate(
  #   n_references_per_gene = n_distinct(reference)) %>% 
  # ungroup()


#COLLAPSE -----------------------------------------    
#remove the DB only entries, collapse to one reference per gene name, mod_res, and mod_residue then add back via Rbind.
# DB_only_collapse_refs_to_gene_psite <- intermediate_DB_joining_df %>% 
#   # filter(genes_match == "DB only") %>% 
#   group_by(mod_res, mod_residue, gene) %>% 
#   filter(row_number() == 1) %>% 
#   ungroup() %>% 
#   # distinct(mod_res, mod_residue, gene.y, PTM_SEA, DB2x, overlap, genes_match) %>% 
#   
#   # check for duplicate references per gene again after collapsing to gene
#   group_by(gene, mod_res, mod_residue) %>% 
#   mutate(
#     n_references_per_gene = n_distinct(reference)) %>% 
#   ungroup()

#REJOIN -----------------------------------------  
#rbind the DB set collapsed to single reference per gene.:
psite_diff_abundance_gene_noImputation_2xDB <- intermediate_DB_joining_df %>%
  # # filter(genes_match != "DB only") %>% #remove the DB sites to enable rbind without duplicating rows.
  # # rbind(DB_only_collapse_refs_to_gene_psite) %>%
  # #COMBINE 'GENES.X' AND 'GENES.Y' INTO 'GENES'
  # mutate(
  #   gene = case_when(
  #     is.na(gene.x) == TRUE ~ gene.y,
  #     is.na(gene.y) == TRUE ~ gene.x,
  #     gene.x == gene.y ~ gene.x,
  #     TRUE ~ "what happened here")) %>%  #all good, no 'what happened here's.
  # select(-c(gene.x, gene.y)) %>% 
  # 
  # #TEST FOR DUPLICATE REFERENCES AGAIN
  # select(-n_references_per_gene) %>% 
  group_by(comparison, gene, mod_res, mod_residue) %>% 
  mutate(
    n_references_per_gene = n_distinct(reference)) %>% #successful collapse of multiple references to single gene name.
  ungroup() %>% 
 #ASSIGN OVERLAPS FOR SUBSEQUENT ANALYSIS:
  mutate(
    overlap_my_data = case_when(
      my_data == TRUE & !is.na(DB_overlap) ~ "both",
      my_data == TRUE & is.na(DB_overlap) ~ "this\nstudy",
      is.na(my_data) & !is.na(DB_overlap) ~ "DBs\nonly"),
    overlap_my_data = fct_relevel(overlap_my_data, "both", "this\nstudy", "DBs\nonly"))
#comparisons kept separate, filtered locally for some plots, but want to be able to separate out comparisons such as for volcano plots.

#plot annotations, comparisons collapsed to site level --------------------------

#counts for annotating plot (comparisons collapsed to site (if sig chg >= 1 time, counted once))
sums_psites_overlap_DBs_noImputation <- psite_diff_abundance_gene_noImputation_2xDB %>%
  filter(mod_res == "Y") %>%
  distinct(mod_res, mod_residue, gene, overlap_my_data) %>% 
  group_by(overlap_my_data) %>%
  mutate(n_sites = n()) %>%
  ungroup() %>%
  distinct(overlap_my_data, n_sites) %>%
  mutate(n_sites_char = as.character(n_sites),
         overlap_num = case_when(
           overlap_my_data == "both" ~ 1,
           overlap_my_data == "this\nstudy" ~ 2,
           overlap_my_data == "DBs\nonly" ~ 3))

```
#### . . .  . write to csv
```{r}
write_csv(x = psite_diff_abundance_gene_noImputation_2xDB, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psite_diff_abundance_gene_noImputation_2xDB.csv")
```

#### . . . . list of sig reg pY sites
```{r}
sig_reg_pYsites_noImputation <- psite_diff_abundance_gene_noImputation_2xDB %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  distinct(gene, mod_res, mod_residue, overlap_my_data) %>% 
  mutate(gene_ref = paste0(gene, "_", mod_res, mod_residue))
  
```


#### . . .  . barplot DB2x vs. my data
plot database overlaps
comparisons considered separately
```{r}
overlap_noImputation_2xDB <- ggplot() +
  geom_bar(data = psite_diff_abundance_gene_noImputation_2xDB %>%  distinct(mod_res, mod_residue, gene, overlap_my_data),
           mapping = aes(x= overlap_my_data, fill = mod_res), color = "black", size = 1) +
  geom_text(data = sums_psites_overlap_DBs_noImputation, aes(x = overlap_num, y = n_sites + 20, label = n_sites_char)) +
  scale_fill_viridis_d(direction = -1) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, lineheight = 0.5, vjust = 1),
        axis.text.y = element_text( size = 12),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 14)) +
  scale_y_continuous(limits = c(0, 600),breaks = c(seq(0, 600, 100)), expand = c(0, 0)) +
  ylab("unique phosphosites") +
  xlab("database overlap")

overlap_noImputation_2xDB

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_sites_2databases_mydata_noImputation_uniquepYsites.png", plot = overlap_noImputation_2xDB, width = 10, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_sites_2databases_mydata_noImputation_uniquepYsites.pdf", plot = overlap_noImputation_2xDB, width = 10, height = 10, scale = 0.4)
```
Need to remove Phosphopedia and perhaps separate Phosphosite Plus from PTMSigDB into separate plots.



#### . . . . volcano
No imputation
updated database joining 2025-01-25

##### . . . . . 15 min vs untreated
```{r}
# EGF15min vs. EGF0min (aka control/ untreated) ------------------------------------------------------

my_psite_volcano_plot_EGF15min_vs_EGF0min_noImputation <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>%
               # filter(abs(diff) < 1) %>%
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff < -1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff > 1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  facet_wrap(facets = vars(comparison)) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff >= 1) %>%
               filter(adj_pval <= 0.05),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = 8,
               force_pull   = 0.2, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(0, 30), ylim = c(-0.5, 26),
               direction = "y",
               family = "sans",
               # vjust = 1,
               hjust = "right",
               size = 1) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff <= -1.5) %>%
               filter(adj_pval <= 0.01),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = -8,
               direction = "y",
               force_pull   = 0, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(-10, 0), ylim = c(-0.5, 21),
               # vjust = 1,
               hjust = "left",
               size = 2) +
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_color_brewer(palette = "Dark2")

  # scale_x_continuous(name = "Log2(fold change)", breaks = seq(-10, 10, 2), limits = c(-10, 10)) +
  # scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,20,5), limits = c(0, 20))

my_psite_volcano_plot_EGF15min_vs_EGF0min_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation.png", plot = my_psite_volcano_plot_EGF15min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_pYsite_volcano_plot_EGF15min_vs_EGF0min_noImputation.pdf", plot = my_psite_volcano_plot_EGF15min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)
```

##### . . . . . 5 min vs. untreated
```{r}
# EGF5min vs. EGF0min (aka control/ untreated) ------------------------------------------------------

my_psite_volcano_plot_EGF5min_vs_EGF0min_noImputation <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>%
               # filter(abs(diff) < 1) %>%
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>%
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>%
               filter(diff < -1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>%
               filter(diff > 1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  # facet_wrap(facets = vars(comparison, mod_res)) +
  facet_wrap(facets = vars(comparison)) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF5min_vs_EGF0min") %>%
               filter(diff >= 1) %>%
               filter(adj_pval <= 0.05),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = 8,
               force_pull   = 0.2, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(0, 30), ylim = c(-0.5, 26),
               direction = "y",
               family = "sans",
               # vjust = 1,
               hjust = "right",
               size = 1) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF5min_vs_EGF0min") %>%
               filter(diff <= -1.5) %>%
               filter(adj_pval <= 0.01),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = -8,
               direction = "y",
               force_pull   = 0, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(-10, 0), ylim = c(-0.5, 21),
               # vjust = 1,
               hjust = "left",
               size = 2) +
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_color_brewer(palette = "Dark2")

  # scale_x_continuous(name = "Log2(fold change)", breaks = seq(-10, 10, 2), limits = c(-10, 10)) +
  # scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,20,5), limits = c(0, 20))

my_psite_volcano_plot_EGF5min_vs_EGF0min_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF5min_vs_EGF0min_noImputation.png", plot = my_psite_volcano_plot_EGF5min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF5min_vs_EGF0min_noImputation.pdf", plot = my_psite_volcano_plot_EGF5min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)
```
##### . . . . . 3 min vs. untreated
```{r}
# EGF3min vs. EGF0min (aka control/ untreated) ------------------------------------------------------

my_psite_volcano_plot_EGF3min_vs_EGF0min_noImputation <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>%
               # filter(abs(diff) < 1) %>%
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>%
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>%
               filter(diff < -1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>%
               filter(diff > 1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  # facet_wrap(facets = vars(comparison, mod_res)) +
  facet_wrap(facets = vars(comparison)) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF3min_vs_EGF0min") %>%
               filter(diff >= 1) %>%
               filter(adj_pval <= 0.05),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = 8,
               force_pull   = 0.2, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(0, 30), ylim = c(-0.5, 26),
               direction = "y",
               family = "sans",
               # vjust = 1,
               hjust = "right",
               size = 1) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF3min_vs_EGF0min") %>%
               filter(diff <= -1.5) %>%
               filter(adj_pval <= 0.01),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = -8,
               direction = "y",
               force_pull   = 0, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(-10, 0), ylim = c(-0.5, 21),
               # vjust = 1,
               hjust = "left",
               size = 2) +
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_color_brewer(palette = "Dark2")

  # scale_x_continuous(name = "Log2(fold change)", breaks = seq(-10, 10, 2), limits = c(-10, 10)) +
  # scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,20,5), limits = c(0, 20))

my_psite_volcano_plot_EGF3min_vs_EGF0min_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF3min_vs_EGF0min_noImputation.png", plot = my_psite_volcano_plot_EGF3min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF3min_vs_EGF0min_noImputation.pdf", plot = my_psite_volcano_plot_EGF3min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)
```

##### . . . . . 1 min vs. untreated
```{r}
# EGF1min vs. EGF0min (aka control/ untreated) ------------------------------------------------------

my_psite_volcano_plot_EGF1min_vs_EGF0min_noImputation <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>%
               # filter(abs(diff) < 1) %>%
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = pYsite_diff_abundance_gene_noImputation %>%
               distinct(comparison, diff, adj_pval, gene, modres_position, mod_res) %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>%
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>%
               filter(diff < -1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  geom_point(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>%
               filter(diff > 1) %>%
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  # facet_wrap(facets = vars(comparison, mod_res)) +
  facet_wrap(facets = vars(comparison)) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF1min_vs_EGF0min") %>%
               filter(diff >= 1) %>%
               filter(adj_pval <= 0.05),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = 8,
               force_pull   = 0.2, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(0, 30), ylim = c(-0.5, 26),
               direction = "y",
               family = "sans",
               # vjust = 1,
               hjust = "right",
               size = 1) +
  geom_text_repel(data = psite_diff_abundance_gene_noImputation_2xDB %>%
               distinct(comparison, diff, adj_pval, gene, mod_residue, overlap_my_data, mod_res) %>%
                filter(comparison == "EGF1min_vs_EGF0min") %>%
               filter(diff <= -1.5) %>%
               filter(adj_pval <= 0.01),
               mapping = aes(x = diff, y = -log10(adj_pval), label = paste(gene, mod_residue, sep = " "), color = overlap_my_data),
               max.overlaps = 200,
               segment.color = NA,
               # segment.color = "gray",
               # segment.size = 0.2,
               # mod_residue = position_stack( hjust = 6),
               nudge_x = -8,
               direction = "y",
               force_pull   = 0, # do not pull toward data points
               # xlim = c(-Inf, Inf), ylim = c(-Inf, Inf),
               xlim = c(-10, 0), ylim = c(-0.5, 21),
               # vjust = 1,
               hjust = "left",
               size = 2) +
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_color_brewer(palette = "Dark2")

  # scale_x_continuous(name = "Log2(fold change)", breaks = seq(-10, 10, 2), limits = c(-10, 10)) +
  # scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,20,5), limits = c(0, 20))

my_psite_volcano_plot_EGF1min_vs_EGF0min_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF1min_vs_EGF0min_noImputation.png", plot = my_psite_volcano_plot_EGF1min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_EGF1min_vs_EGF0min_noImputation.pdf", plot = my_psite_volcano_plot_EGF1min_vs_EGF0min_noImputation, width = 15, height = 10, scale = 0.4)
```


make sure BCAR1 abudance is not decreasing at proteome level. THis may need longer total proteome runs. if not, then perhaps all psites decrease in similar fashion. 
also, NEDD8 rings a bell, is it ubiquitin related. look into this protein.




#------------------------------------------------------------------
#5. MISC DATA FRAMES
BOXPLOTS + POINTS

##_a) my data only sites:
```{r}
sites_not2xDB_noImputation <- psite_diff_abundance_gene_noImputation_2xDB %>% 
  filter(overlap_my_data == "this\nstudy") %>% 
  select(gene, mod_res, mod_residue, comparison) %>% 
  mutate(
    psite = paste(mod_res, mod_residue, sep = ""),
    gene_ref = paste(gene, psite, sep = " "))
```





##_b) ascore_gene_noImputation df defined here
I think this title is old: imputed then zscored matrix including reps
Note, no filter for significance here.
```{r}
ascore_gene_noImputation <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  # left_join(y = human_fasta_2024 %>% 
  #             separate(gene, into = c("gene", "organism_del"), sep = "_") %>%
  #             select(-organism_del) %>% 
  #                        distinct(gene, reference), by = "reference") %>%  #human fasta 2024 has gene names named differently, like MK01
  # left_join(y = (fasta_gene_names %>% select(entry, gene, protein_names, keyword_id) %>% rename(reference = entry)), by = "reference") %>% #so this one has the gene names properly assigned to common names like MAPK!
  left_join(y = master_FASTA, by = "reference") %>% 
  
  separate(ref, into = c("reference2", "psite"), sep = "_", remove = FALSE) %>% 
  select(-reference2) %>%

  mutate(
    gene_ref = paste(gene, psite, sep = " "),
    condition = as.factor(condition),
    condition = fct_relevel(condition, "EGF0min", "EGF1min",  "EGF3min", "EGF5min", "EGF15min"),
    string_length_proteins = str_length(proteins)) %>% 

  #collapse redundant protein assignments to maximal possible proteins assigned.
  group_by(sample_id, reference, gene_ref, replicate) %>% 
  filter(string_length_proteins == max(string_length_proteins)) %>%  
  ungroup()%>% 
  
#count n_observatinos (n_obs) for use in other plots
  group_by(condition, ref, gene_ref) %>% 
  mutate(
    n_obs = n() ) %>% 
  ungroup() %>% 
  select(-string_length_proteins)


# # install.packages("mice")
# # library(mice)
# ascore_final_gene_observed_rep_matrix <- ascore_gene_noImputation %>% 
#   pivot_wider(id_cols = c("ref", "condition"), names_from = replicate, values_from = median_norm_intensity) %>%
#   mice(method = "pmm", m = 5) %>% 
#   complete(,1)
```


#-----------------------------------------------------------------
#6. DISTRIBUTIONS OF OBSERVATIONS
define data completeness prior to filtering
```{r}
#Tally obs here before imputation
num_observations_per_ref <- ascore_gene_noImputation %>%   
  group_by(gene_ref) %>% 
  mutate(
    n_observations_per_psite = n()) %>% 
  ungroup() %>% 
  distinct(gene_ref, n_observations_per_psite) %>% 
   mutate(gene_ref = str_replace_all(gene_ref, pattern = " ", replacement = "_"))
```
I previously only required at least 3 observations before clustering. Now, I will include only significantly changing p-sites, according to differential abundance analysis after imputation using standard deviations.


 ##_a. key-pair for >= 3 observations

```{r}
# psites_obs_gt_3 <- num_observations_per_ref %>%
#   filter(n_observations_per_psite > 2) %>%
#   mutate(well_observed = TRUE,
#          gene_ref = str_replace_all(gene_ref, pattern = " ", replacement = "_"))
```




###___i. histogram of observation per psite
```{r}
histogram_observations <- ggplot(data = num_observations_per_ref) +
  geom_histogram(mapping = aes(x = n_observations_per_psite), bins = 60) +
  alexis_theme() +
  scale_x_continuous(breaks = c(seq(0, 30, 2)))
  

histogram_observations
```


###___ii. plot intensity distribution for imputation
```{r}
#print lowest 1% and lowest 5% intensity
percent_1_5_intensity <- quantile(ascore_gene_noImputation$median_norm_intensity, probs = c(0.01, 0.05), na.rm = TRUE )
percent_1_5_intensity

#print lowest intensity overall
lowest_intensity <- min((ascore_gene_noImputation %>% filter(!is.infinite(median_norm_intensity)))$median_norm_intensity, na.rm =  TRUE)
lowest_intensity






#plot total intensity distribution of data
plot_obs_intensity_distribution <- ggplot(data = ascore_gene_noImputation) +
  geom_density(mapping = aes(x = median_norm_intensity, color = condition)) +
  alexis_theme() 

plot_obs_intensity_distribution


#imputation model of fully missing observations
normal_distribution_fully_missing_obs <-rnorm(100000,mean=10, sd=1)
hist(normal_distribution_fully_missing_obs,breaks=75,xlim=c(5,15),freq=FALSE)
abline(v=10, lwd=5)
abline(v=c(7,8,9,11,12,13), lwd=3,lty=3)

normal_distribution_fully_missing_obs_SD0o63 <-rnorm(100000,mean=10, sd=0.63)
hist(normal_distribution_fully_missing_obs_SD0o63,breaks=75,xlim=c(5,15),freq=FALSE)
abline(v=10, lwd=5)
abline(v=c(7,8,9,11,12,13), lwd=3,lty=3)

#imputation model of partially missing observations
normal_distribution_partially_missing_obs <-rnorm(100000,mean=20, sd=0.67)
hist(normal_distribution_partially_missing_obs,breaks=75,xlim=c(15,25),freq=FALSE)
abline(v=20, lwd=5)
abline(v=c(17.99,18.66,19.33,20.67,21.34,22.01), lwd=3,lty=3)
    #mean of distribution is set to average of any or all measured replicates, while SD is set to condition specific standard deviaton, generally ~ 0.67
```
Put lowest value at 10 because lowest measurement of intensity is 11



#7. BOXPLOT INTENSITY DATABASE OVERLAPS
##_a. join to DBs by P-SITE
assess database annotation intersection by direct p-site matching. 
###_I. all reps
####__i.  relative intensities of sites only my data vs. 2x DBs
dataframe Y only
```{r}
ascore_gene_noImputation_overlap_my_data_df <- ascore_gene_noImputation %>%
  
  filter(mod_res == "Y") %>% 
  full_join(psite_diff_abundance_gene_noImputation_2xDB %>% select(ref, overlap_my_data), by = "ref") %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  mutate(
    overlap_my_data = case_when(
      is.na(overlap_my_data) ~ "no sig chg",
      TRUE ~ overlap_my_data  ),
    n_obs = as.factor(n_obs)) %>% 
  distinct()
```


####__ii. t-test
```{r}
#t-test to show novel p-sites are significantly lower abundance relative to annotated pY sites
ascore_gene_noImputation_overlap_my_data_df_ttest <- ascore_gene_noImputation_overlap_my_data_df %>% 
  distinct(overlap_my_data, reference, psite, condition, replicate, median_norm_intensity)

both_intensities <- (ascore_gene_noImputation_overlap_my_data_df_ttest %>%
                       filter(overlap_my_data == "both") %>%
                       filter(median_norm_intensity != Inf) %>% 
                       filter(median_norm_intensity != -Inf))$median_norm_intensity

my_data_intensities <- (ascore_gene_noImputation_overlap_my_data_df_ttest %>% filter(overlap_my_data == "this\nstudy") %>%
                          filter(median_norm_intensity != Inf) %>%
                          filter(median_norm_intensity != -Inf))$median_norm_intensity

ttest_intensities <- t.test(x = both_intensities, y = my_data_intensities)
ttest_intensities
```

####__iii. counts
```{r}
#total counts per overlap (2) --------------------------------
countsascore_gene_noImputation_overlap_my_data_df <- ascore_gene_noImputation %>%
  filter(mod_res == "Y") %>% 
  full_join(psite_diff_abundance_gene_noImputation_2xDB %>% select(ref, overlap_my_data), by = "ref") %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  filter(n_obs <= 6) %>%  # a few sites with 8 or 9 observations.
  mutate(
    overlap_my_data = case_when(
      is.na(overlap_my_data) ~ "no sig chg",
      TRUE ~ overlap_my_data  ),
    n_obs = as.factor(n_obs)) %>% 
  distinct() %>% 
  group_by(overlap_my_data) %>% 
  mutate(distinct_psites = n()) %>% 
  ungroup () %>% 
  distinct(distinct_psites, overlap_my_data) %>% 
  mutate(y = 32)
  # group_by(overlap_my_data, n_obs) %>% 
  # mutate(
  #   n_psites_per_obs_intersect = n()) %>% 
  # ungroup()


#total counts per overlap X n_obs --------------------------------
countsascore_gene_noImputation_overlap_my_data_df_nOBS <- ascore_gene_noImputation %>%
  filter(mod_res == "Y") %>% 
  full_join(psite_diff_abundance_gene_noImputation_2xDB %>% select(ref, overlap_my_data), by = "ref") %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  filter(n_obs <= 6) %>%  # a few sites with 8 or 9 observations.
  mutate(
    overlap_my_data = case_when(
      is.na(overlap_my_data) ~ "no sig chg",
      TRUE ~ overlap_my_data  ),
    n_obs = as.factor(n_obs)) %>% 
  distinct() %>% 
  group_by(overlap_my_data, n_obs) %>%
  mutate(
    n_psites_per_obs_intersect = n()) %>%
  ungroup() %>% 
  filter(!is.na(n_obs)) %>% 
  distinct(overlap_my_data, n_obs, n_psites_per_obs_intersect) %>%
  
  arrange(overlap_my_data, n_obs) %>% 
  mutate(x = c(0.65,0.8, 0.95, 1.05, 1.2, 1.3,     1.72, 1.82, 1.94, 2.08, 2.22, 2.33),
         y = 8)
```

####__iv. plot
```{r}
my_data_rel_intensity_noImputation <- ggplot(data = ascore_gene_noImputation_overlap_my_data_df %>%
                                               filter(n_obs %in% c("0", "1", "2", "3", "4", "5", "6"))) +
  geom_boxplot(mapping = aes(x = overlap_my_data, y = median_norm_intensity)) +
  geom_boxplot(mapping = aes(x = overlap_my_data, y = median_norm_intensity, fill =  n_obs), color = "black", alpha = 0.3) +
  # geom_segment(data = tibble(x = c(0.75, 1.75), xend = c(1.25, 2.25), y = c(40, 40)), mapping = aes(x = x, xend = xend, y = y), inherit.aes = FALSE) +
  geom_segment(data = tibble(x = c(1), xend = c(2), y = c(38)), mapping = aes(x = x, xend = xend, y = y), inherit.aes = FALSE) +
  geom_text(data = countsascore_gene_noImputation_overlap_my_data_df, mapping = aes(x = overlap_my_data, y = y, label = distinct_psites)) +
  geom_text(data = countsascore_gene_noImputation_overlap_my_data_df_nOBS , mapping = aes(x = x, y = y, label = n_psites_per_obs_intersect), angle = 270) +
  geom_text(data = tibble(x = c(1), y = c(38.5), label = "***"), mapping = aes(x = x,  y = y, label = label), inherit.aes = FALSE, size = 10) +
  geom_text(data = tibble(x = c(1.8), y = c(39.5), label = "p-value < 2.2e-16"), mapping = aes(x = x,  y = y, label = label), inherit.aes = FALSE, size = 4) +
  alexis_theme() +
  scale_fill_brewer(palette = "Purples") +
  scale_y_continuous(expand = c(0,0)) +
  expand_limits(y = c(0, 40))


my_data_rel_intensity_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_data_rel_intensity_noImputation.png", plot = my_data_rel_intensity_noImputation, width = 12, height = 12, scale = 0.4)
```
pY sites found only in my data, even in all 6 replicates of a conditions suggesting confident localization, show lower intensity. This suggests the reproducibility and sensitvity of our enrichment expands our ability to measure new pY sites!

would be strong to add t-test and num_observations

##_II. focus only in 6 reps
####__i. dataframe limiting reps
```{r}
ascore_gene_noImputation_overlap_my_data_df_6reps <- ascore_gene_noImputation %>%
  filter(n_obs == 6) %>% 
  filter(mod_res == "Y") %>% 
  full_join(psite_diff_abundance_gene_noImputation_2xDB %>% select(ref, overlap_my_data), by = "ref") %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  mutate(
    overlap_my_data = case_when(
      is.na(overlap_my_data) ~ "no sig chg",
      TRUE ~ overlap_my_data  ),
    n_obs = as.factor(n_obs)) %>%
  filter(n_obs == 6) %>% 
  distinct()
```

##### . . . n pY sites of 6 reps both vs. this study
```{r}
num_psites_6reps_DB_intersects_noImputation <- ascore_gene_noImputation_overlap_my_data_df_6reps %>% 
  distinct(overlap_my_data, gene_ref) %>% 
  group_by(overlap_my_data) %>% 
  summarize(
    n_pY_sites = n())

num_psites_6reps_DB_intersects_noImputation
```



####__ii. t-test
```{r}
#t-test to show novel p-sites are significantly lower abundance relative to annotated pY sites
ascore_gene_noImputation_overlap_my_data_df_ttest_6reps <- ascore_gene_noImputation_overlap_my_data_df_6reps %>% 
  distinct(overlap_my_data, reference, psite, condition, replicate, median_norm_intensity)

both_intensities_6reps_noImputation <- (ascore_gene_noImputation_overlap_my_data_df_ttest_6reps %>%
                       filter(overlap_my_data == "both") %>%
                       filter(median_norm_intensity != Inf) %>% 
                       filter(median_norm_intensity != -Inf))$median_norm_intensity

my_data_intensities_6reps_noImputation <- (ascore_gene_noImputation_overlap_my_data_df_ttest_6reps %>% filter(overlap_my_data == "this\nstudy") %>%
                          filter(median_norm_intensity != Inf) %>%
                          filter(median_norm_intensity != -Inf))$median_norm_intensity

ttest_intensities_6reps_noImputation <- t.test(x = both_intensities_6reps_noImputation, y = my_data_intensities_6reps_noImputation)
ttest_intensities_6reps_noImputation

lower_fold_diff <- 2^2.17
upper_fold_diff <- 2^2.48

lower_fold_diff
upper_fold_diff
```

####__iii. counts
```{r}
#total counts per overlap (2) --------------------------------
countsascore_gene_noImputation_overlap_my_data_df_6reps <- ascore_gene_noImputation %>%
  filter(n_obs == 6) %>% 
  filter(mod_res == "Y") %>% 
  full_join(psite_diff_abundance_gene_noImputation_2xDB %>% select(ref, overlap_my_data), by = "ref") %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  mutate(
    overlap_my_data = case_when(
      is.na(overlap_my_data) ~ "no sig chg",
      TRUE ~ overlap_my_data  ),
    n_obs = as.factor(n_obs)) %>% 
  distinct() %>% 
  group_by(overlap_my_data) %>% 
  mutate(distinct_psites = n()) %>% 
  ungroup () %>% 
  distinct(distinct_psites, overlap_my_data) %>% 
  mutate(y = 32)
  # group_by(overlap_my_data, n_obs) %>% 
  # mutate(
  #   n_psites_per_obs_intersect = n()) %>% 
  # ungroup()


#total counts per overlap X n_obs --------------------------------
countsascore_gene_noImputation_overlap_my_data_df_nOBS_6reps <- ascore_gene_noImputation %>%
  filter(n_obs == 6) %>% 
  filter(mod_res == "Y") %>% 
  full_join(psite_diff_abundance_gene_noImputation_2xDB %>% select(ref, overlap_my_data), by = "ref") %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  mutate(
    overlap_my_data = case_when(
      is.na(overlap_my_data) ~ "no sig chg",
      TRUE ~ overlap_my_data  ),
    n_obs = as.factor(n_obs)) %>% 
  distinct() %>% 
  group_by(overlap_my_data, n_obs) %>%
  mutate(
    n_psites_per_obs_intersect = n()) %>%
  ungroup() %>% 
  filter(!is.na(n_obs)) %>% 
  distinct(overlap_my_data, n_obs, n_psites_per_obs_intersect) %>%
  arrange(overlap_my_data, n_obs) %>% 
  mutate(x = c(0.75, 1.75), y = c(26, 22))
```

####__iv. plot (PUB Fig 4)
```{r}
my_data_rel_intensity_6reps_noImputation <- ggplot(data = ascore_gene_noImputation_overlap_my_data_df_6reps) +

  
  geom_boxplot(mapping = aes(x = overlap_my_data, y = median_norm_intensity, fill =  overlap_my_data),
               color = "black", alpha = 0.8, show.legend = FALSE) +
  
  # geom_segment(data = tibble(x = c(0.75, 1.75), xend = c(1.25, 2.25), y = c(40, 40)), mapping = aes(x = x, xend = xend, y = y), inherit.aes = FALSE) +
  
  geom_segment(data = tibble(x = c(1), xend = c(2), y = c(38)),
               mapping = aes(x = x, xend = xend, y = y),
               inherit.aes = FALSE) +
  
  # geom_text(data = countsascore_gene_noImputation_overlap_my_data_df_6reps, mapping = aes(x = overlap_my_data, y = y, label = distinct_psites)) +
  
  geom_text(data = countsascore_gene_noImputation_overlap_my_data_df_nOBS_6reps ,
            mapping = aes(x = x, y = y + 1, label = paste("n=\n",n_psites_per_obs_intersect)),
            angle = 0, hjust = 0.5, lineheight= 0.75) +
  geom_text(data = tibble(x = c(1.1), y = c(38.5), label = "***"),
            mapping = aes(x = x,  y = y, label = label),
            inherit.aes = FALSE, size = 6) +
  
  geom_text(data = tibble(x = c(1.9), y = c(39), label = "p-value < 2.2e-16"),
            mapping = aes(x = x,  y = y, label = label),
            inherit.aes = FALSE, size = 3.5) +
  alexis_theme() +
  scale_fill_brewer(palette = "Dark2") +
  scale_y_continuous(expression("Log" [2]*"intensity"), expand = c(0,0)) + #asterisk required to join chr on backend.
  scale_x_discrete("annotation intersects", labels = c("both" = "DBs &\nmy data", "this\nstudy" = "my data\nonly")) +
  expand_limits(y = c(10, 40)) +
  theme(axis.text.x = element_text(size = 12, lineheight = 0.75, vjust = 1))


my_data_rel_intensity_6reps_noImputation

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_data_rel_intensity_6reps_noImputation.png", plot = my_data_rel_intensity_6reps_noImputation, width = 7, height = 9, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_data_rel_intensity_6reps_noImputation.pdf", plot = my_data_rel_intensity_6reps_noImputation, width = 7, height = 9, scale = 0.4)
```
I don't think a multiple testing correction is necessary here because I am only asking the t-test once to determine if these two populations are distinct. This is in contrast to doing multiple comparisons of subsets within these populations I believe where I would get multiple p-values out..

 The above analysis joins my data ot the 2 databases (PSP and PTMSigDB) by specific phosphosite not just gene. I could adapt the code to join at gene level to investigate relative intensity of pY sites on genes not previously included in EGF stimulation signatures. but this can complicate writing up the results, so I will stick to psite level joining for now, albeit this is more stringent and will show more unique pY sites in this study.
#---------------------------------------------
#8. BOXPLOT + POINTS
##_a) EGFR pY-sites
```{r}
pY_boxplot_points <- ggplot() + 
  # pY_boxplot_points <- ggplot(data = ascore_gene_noImputation %>% filter(gene %in% c("EGFR", "MAPK1", "STAT3"))) +
  geom_boxplot(data = ascore_gene_noImputation %>% filter(gene %in% c("EGFR")),
               mapping = aes(x = condition, y = median_norm_intensity), show.legend = FALSE, alpha = 0.3, outlier.color = NA) +
  geom_point(data = ascore_gene_noImputation %>% filter(gene %in% c("EGFR")),
             mapping = aes(x = condition, y = median_norm_intensity, fill = sample_id), shape = 21, alpha = 0.6, show.legend = FALSE) +
  geom_text(data = ascore_gene_noImputation %>% filter(gene %in% c("EGFR")) %>% distinct(condition, gene_ref, n_obs),
             aes(x = condition, y = 35, label = n_obs),size = 2.5, show.legend = FALSE, fontface = "bold") +
  alexis_theme() +
  facet_wrap(facets = vars(gene_ref), nrow = 2) + 
  theme(axis.text.x = element_text(angle = -90, size = 10, vjust = 0.5, hjust = 0))

pY_boxplot_points


ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pY_boxplot_points_EGFR.png", plot = pY_boxplot_points, height = 12, width = 20, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pY_boxplot_points_EGFR.pdf", plot = pY_boxplot_points, height = 12, width = 20, scale = 0.4)
```
##_b) MAPK1 pSTY-sites
```{r}
pY_boxplot_points_MAPK1 <- ggplot() + 
  # pY_boxplot_points <- ggplot(data = ascore_gene_noImputation %>% filter(gene %in% c("EGFR", "MAPK1", "STAT3"))) +
  geom_boxplot(data = ascore_gene_noImputation %>% filter(gene %in% c("MAPK1")), 
               mapping = aes(x = condition, y = median_norm_intensity,), show.legend = FALSE, alpha = 0.3, outlier.color = NA) +
  geom_point(data = ascore_gene_noImputation %>% filter(gene %in% c("MAPK1")),
             mapping = aes(x = condition, y = median_norm_intensity, fill = sample_id), shape = 21, alpha = 0.6, show.legend = FALSE) +
  geom_text(data = ascore_gene_noImputation %>% filter(gene %in% c("MAPK1")) %>% distinct(condition, gene_ref, n_obs),
             aes(x = condition, y = 36, label = n_obs),size = 2.5, show.legend = FALSE, fontface = "bold") +
  alexis_theme() +
  facet_wrap(facets = vars(gene_ref), nrow = 2) + 
  theme(axis.text.x = element_text(angle = -90, size = 10, vjust = 0.5, hjust = 0))
  

pY_boxplot_points_MAPK1


ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pY_boxplot_points_MAPK1.png", plot = pY_boxplot_points_MAPK1, height = 8, width = 6, scale = 0.4)
```
AHA! so I can detect the dual phospho of MAPK1 (Thr and Tyr). The differential abundance came out as insignificant, but when looking at boxplot of intensities for these sites, we see an expected intensity pattern! :) 




##==============================
##==============================

#9. IMPUTATION


##A. WITH STANDARD DEVIATION

imputed matrix

use this for fold change analysis
11/24/2024 --> 
- I guess imputation using only the mean is easier to see on the heatmap. but now that I have the darkness indicators for degree of imputation, it helps me to assess imputation not just by heatmap color homogeneity.

###_a. define SD and mean intensities
```{r}
set.seed(15)

#get SDs for condition and global to use in imputation
sd_ascore_final_gene <- ascore_gene_noImputation %>%
  filter(!is.nan((median_norm_intensity))) %>% 
  filter(!is.na(median_norm_intensity)) %>% 
  filter(!is.infinite(median_norm_intensity)) %>%
  mutate(all_sd = sd(median_norm_intensity, na.rm = TRUE)) %>% 
  # group_by(condition) %>% 
  # mutate(condition_sd = sd(median_norm_intensity, na.rm = TRUE)) %>% 
  ungroup() %>%
  group_by(condition, gene_ref) %>% 
  mutate(
    condition_gene_ref_sd = sd(median_norm_intensity, na.rm = TRUE),
    condition_gene_ref_mean_intensity = mean(median_norm_intensity, na.rm = TRUE)) %>%
  ungroup() %>%
  
  # group_by(condition) %>% #going with global average standard devation of 0.63, and not condition specific 0.61 - 0.67 for imputation.
  
  #get average within condition + psite SD
  mutate(avg_condition_gene_ref_sd = mean(condition_gene_ref_sd, na.rm = TRUE)) %>% 
  
  # ungroup() %>% #used for assessment of condition specific average standard deviations.
  distinct(condition, gene_ref, all_sd, condition_gene_ref_sd, avg_condition_gene_ref_sd, condition_gene_ref_mean_intensity)
```
0.61 (15min) to 0.67 (1min) are ranges of standard devation within conditions. I will just go with the global average sd since plots were made as such.

####__i. lowest intensities
```{r}
QC_measured_intensities_df <- ascore_gene_noImputation %>% 
  filter(!is.nan((median_norm_intensity))) %>% 
  filter(!is.na(median_norm_intensity)) %>% 
  filter(!is.infinite(median_norm_intensity)) %>% 
  group_by(condition, replicate) %>% 
  mutate(
    min_intensity = min(median_norm_intensity)  )
  

plot_range_intensities <- ggplot(data = QC_measured_intensities_df) +
 geom_violin(mapping = aes(x = condition, y = median_norm_intensity), draw_quantiles = c(0.1, 0.5, 0.9)) +
  geom_jitter(data = (QC_measured_intensities_df %>% distinct(condition, replicate, min_intensity)),mapping = aes (x = condition, y = min_intensity, fill = replicate), size = 3, shape = 21,  alpha = 0.6, width = 0.05, height = 0) +
  scale_fill_viridis_d(option = "A") +
  alexis_theme() +
  scale_y_continuous(breaks = c(seq(10, 40, 5)), limits = c(10, 40), expand = c(0, 0))

plot_range_intensities
  
```
Points indicate lowest measured intensities.

###_b. observation counting for FC plot
```{r}
#visualize distributions of observations per p-site globally
  ##---df
observation_filter <- ascore_gene_noImputation %>%
  mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
  filter(!is.na(median_norm_intensity)) %>% 
  filter(!is.infinite(median_norm_intensity)) %>% 
  group_by(gene_ref) %>% 
  mutate(
    n_observations = n())

  ##---histogram of observations per p-site globally
plot_observations <- ggplot(data = observation_filter) +
  geom_bar(mapping = aes(x = n_observations)) +
  geom_vline(xintercept = 3, linetype = 2, color = "darkblue") +
  alexis_theme()
plot_observations
```




###_c. imputation and pivoting
```{r}
set.seed(15)
#imputation using normal distributions happens here:
matrix_ascore_gene_imputed_wSD <- ascore_gene_noImputation %>%
  
  pivot_wider(id_cols = c("gene_ref", "condition"),
              names_from = replicate,
              values_from =  median_norm_intensity,
              values_fill = NA) %>%
  select(gene_ref, condition, rep1, rep2, rep3, rep4, rep5, rep6) %>% 
  pivot_longer(cols = c(rep1:rep6), names_to = "replicate") %>% 
  rename(median_norm_intensity = value) %>% 
  mutate(ref_condition = paste(gene_ref, condition, sep = " "),
         median_norm_intensity = case_when(is.infinite(median_norm_intensity) ~ NA,
                                           is.na(median_norm_intensity) ~ NA,
                                           TRUE ~ median_norm_intensity)) %>%
  left_join(y = sd_ascore_final_gene, by = c("condition", "gene_ref" )) %>%
  group_by(condition, gene_ref) %>% 
  
  mutate(
    num_missing_obs = sum(is.na(median_norm_intensity))) %>% 
  
  ungroup() %>%
  group_by(condition, gene_ref, replicate) %>% 
  mutate(
    imputed_intensity = case_when(
      !is.na(median_norm_intensity) ~ median_norm_intensity,
      
      #imputation of partially missing replicates, sd = condition SD, mean = mean of measured reps
      is.na(median_norm_intensity) & num_missing_obs < 6 ~ sample(rnorm(n = 6,
                                                                        mean = condition_gene_ref_mean_intensity,
                                                                        sd = avg_condition_gene_ref_sd), size = 1, prob = NULL),
      #imputation of psite missing in all replicates SD1= 1, mean = 10
      is.na(median_norm_intensity) & num_missing_obs  == 6 ~ sample(x = rnorm(n = 6, mean = 10, sd = 1),
                                                                    size =1, replace = FALSE, prob = NULL))) %>%
  ungroup() %>% 
  mutate(
      
      # 6 here is equivalent to adding in 'num_missing_obs' to choose vector size from normal distribution
      
      
      #add in column to backcalculate imputed measurements
      imputed_replicate = case_when(
        num_missing_obs > 0 ~ "imputed",
        num_missing_obs == 0 ~ "observed" ) )
      #can use above dataframe to look at distributions of psite missingness by plotting histogram of num_missing observations.
  



  #separate dataframe for pivoting. seems to be used in fold change analysis below.
  matrix_ascore_gene_imputed_wSD_wider <- matrix_ascore_gene_imputed_wSD %>%
    ungroup() %>%
    distinct(condition, gene_ref, replicate,  imputed_replicate, imputed_intensity) %>%
    mutate(gene_ref = str_replace_all(gene_ref, pattern = " ", replacement = "_"),
           sample_id = paste(condition, replicate, sep = "_")) %>%

  #now identify psites missing completely at one time point but measured in others.
  pivot_wider(id_cols = c("gene_ref"),
              names_from = sample_id,
              values_from = imputed_intensity,
              values_fill = NA) %>%
    pivot_longer(cols = contains("EGF"), names_to = "sample_id") %>%
    rename(imputed_intensity = value) %>%
    group_by(gene_ref, sample_id) %>%  #to allow for different value sampling during imputation in next step
    mutate(imputed_intensity = case_when(
      !is.na(imputed_intensity) ~ imputed_intensity,
      is.na(imputed_intensity) ~ sample(x = rnorm(n = 24, mean = 10, sd = 1), size =1, replace = FALSE, prob = NULL))) %>%
    ungroup() %>%
    #chose n = 24 to account for some cases where all 4 conditions X 6 reps were not measured. sampling to size = 1 means to keep one value.
    pivot_wider(id_cols = c("gene_ref"),
              names_from = sample_id,
              values_from = imputed_intensity,
              values_fill = NA)



```
###_d. categorize imputations and generate annotations for heatmap
```{r}
#to join with dataframe below for completely missing datapoints
data_completeness_wider_to_rbind <- matrix_ascore_gene_imputed_wSD %>% 
  distinct(gene_ref, condition, replicate, median_norm_intensity, imputed_intensity, imputed_replicate) %>% 
  mutate(gene_ref = str_replace_all(gene_ref, " ", "_"),
         sample_id = paste(condition, replicate, sep = "_")) %>%
  pivot_wider(id_cols = c("gene_ref"),
              names_from = sample_id,
              values_from = imputed_intensity,
              values_fill = NA) %>% 
    pivot_longer(cols = contains("EGF"), names_to = "sample_id") %>% 
    rename(imputed_intensity = value) %>% 
  mutate(imputed_replicate = case_when(
    is.na(imputed_intensity) ~ "imputed",
    !is.na(imputed_intensity) ~ "maybe observed to discard")) %>% 
  filter(imputed_replicate == "imputed") %>% 
  
  separate(sample_id, into = c("condition", "replicate"), sep = "_") %>% 
  select(condition, replicate, gene_ref, imputed_replicate)
```

categorize imputation per psite and condition
```{r}
##CATEGORIZE IMPUTATION PER PSITE AND CONDITION
data_completeness <- matrix_ascore_gene_imputed_wSD %>% 
  distinct(gene_ref, condition, replicate, median_norm_intensity, imputed_intensity,  imputed_replicate)


data_completeness_summary <- matrix_ascore_gene_imputed_wSD %>% 
  distinct(gene_ref, condition, replicate, median_norm_intensity, imputed_intensity,  imputed_replicate) %>% 
  mutate(gene_ref = str_replace_all(gene_ref, " ", "_"),
         sample_id = paste(condition, replicate, sep = "_")) %>%
  distinct(gene_ref, condition, replicate, imputed_replicate) %>% 
  rbind(data_completeness_wider_to_rbind) %>% 
  group_by(gene_ref, condition, imputed_replicate) %>%
  
  summarize(n_observations = n()) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(gene_ref, condition), names_from = imputed_replicate, values_from = n_observations, values_fill = 0) %>% 
  mutate(percent_observed = observed / 6 * 100)
```




#--------------------------------------------

#10. FOLD CHANGE IMPUTED
###__a. missingness and diff abundance
redo missingness and diff abundance with imputed all reps missing to 10 SD = 1; rnorm SD = avg SD ~ 0.68 and mean of measured observations.
```{r}
longer_imputed_intensities_wSD <- matrix_ascore_gene_imputed_wSD_wider %>% 
  pivot_longer(cols = c(EGF15min_rep1:EGF3min_rep6)) %>% 
  rename(imputed_intensities = value) %>% 
  separate(col = name, into = c("condition", "replicate"), sep = "_")



longer_imputed_intensities_wSD_for_diff <- longer_imputed_intensities_wSD %>%
  mutate(sample_id = paste(condition, replicate, sep = "_")) %>% 
  assign_missingness(
    sample = sample_id,
    condition = condition, 
    grouping = gene_ref,
    intensity = imputed_intensities, 
    ref_condition = "all" )


foldchange_imputed_wSD <- longer_imputed_intensities_wSD_for_diff %>%
  calculate_diff_abundance(
    sample = sample_id,
    condition = condition,
    grouping = gene_ref,
    intensity_log2 = imputed_intensities,
    missingness = missingness,
    comparison = comparison) %>% 
  mutate(
    diff = case_when(
      comparison == "EGF0min_vs_EGF1min" ~ -diff,
      comparison == "EGF0min_vs_EGF3min" ~ -diff,
      comparison == "EGF0min_vs_EGF5min" ~ -diff,
      TRUE ~ diff),
    comparison = case_when(
      comparison == "EGF0min_vs_EGF1min" ~ "EGF1min_vs_EGF0min",
      comparison == "EGF0min_vs_EGF3min" ~ "EGF3min_vs_EGF0min",
      comparison == "EGF0min_vs_EGF5min" ~ "EGF5min_vs_EGF0min",
      TRUE ~ comparison))
  


##can add clusters here too!

```
###__b. stats and metrics of regulated pY sites
following imputation including SD in rnorm distribution.
####___i. List of regulated pY sites from imputation with SD
list of regulated pY sites from imputation with SD
```{r}
regulated_pYsites_wimputation_wSD <- foldchange_imputed_wSD %>%
  filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>% 
  distinct(comparison, diff, adj_pval, gene_ref) %>%
  filter(adj_pval < 0.05) %>% 
  filter(diff < -1 | diff > 1)
```




####___ii. total regulated p-sites after imputation
```{r}
net_regulated_psites_wSD <- foldchange_imputed_wSD %>%
                filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>% 
                distinct(comparison, diff, adj_pval, gene_ref) %>%
                group_by(comparison) %>%
                mutate(total_psites = n_distinct(gene_ref)) %>%
                ungroup() %>%
                mutate(
                  regulated_psite = case_when(
                    adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
                    TRUE ~ "not regulated")) %>% 
  filter(regulated_psite == "regulated") %>% 
  distinct(gene_ref) %>% 
  summarize(
    n_regulated_psites_between_min_1_duration = n() )
```
78% of well measured pY sites showed a significant intensity change in at least one treatment duration (878 of 1122 pY sites)

####___iii. percent up/down regulated 

```{r}
percent_psite_regulated_imputed_wSD <- foldchange_imputed_wSD %>%
  filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>%
  distinct(comparison, diff, adj_pval, gene_ref) %>%
  group_by(comparison) %>%
  mutate(total_psites = n_distinct(gene_ref)) %>%
  ungroup() %>%
  mutate(
    regulated_psite = case_when(
      adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
      TRUE ~ "not_regulated"),
    regulated_psite_dir = case_when(
      regulated_psite == "regulated" & diff >= 1 ~ "up",
      regulated_psite == "regulated" & diff <= -1 ~ "down",
      regulated_psite == "not_regulated" ~ "not_regulated")) %>%
  group_by(comparison, regulated_psite_dir) %>%
  mutate(n_regulated_psites = n()) %>%
  ungroup() %>%
  distinct(comparison, total_psites, regulated_psite, n_regulated_psites, regulated_psite_dir) %>%
  pivot_wider(id_cols= c(comparison, total_psites), names_from = regulated_psite_dir, values_from = n_regulated_psites) %>%
  group_by(comparison) %>%
  mutate(percent_upregulated = up / total_psites*100,
         percent_downregulated = down / total_psites*100) %>%
  ungroup() %>%
  mutate(
    total_regulated_pYsites = up + down,
    pct_up_vs_total_regulated = up / total_regulated_pYsites *100,
    pct_down_vs_total_regulated = down / total_regulated_pYsites*100,
    percent_regulated = total_regulated_pYsites / total_psites*100,
    percent_not_regulated = not_regulated / total_psites*100) %>%

  #annotation positions for volcano plot
  mutate(
    x_downreg_position = -12,
    x_upreg_position = 12,
    y_position = 6)


percent_psite_regulated_imputed_wSD
```







__Xa. dataframe
redo missingness and diff abundance with imputed all reps missing to 10 SD = 1; rnorm SD = avg SD ~ 0.68 and mean of measured observations.
```{r}
# longer_imputed_intensities_wSD <- matrix_ascore_gene_imputed_wSD_wider %>% 
#   pivot_longer(cols = c(EGF15min_rep1:EGF3min_rep6)) %>% 
#   rename(imputed_intensities = value) %>% 
#   separate(col = name, into = c("condition", "replicate"), sep = "_")
# 
# 
# longer_imputed_intensities_for_diff_wSD <- longer_imputed_intensities_wSD %>%
#   mutate(sample_id = paste(condition, replicate, sep = "_")) %>% 
#   assign_missingness(
#     sample = sample_id,
#     condition = condition, 
#     grouping = gene_ref,
#     intensity = imputed_intensities, 
#     ref_condition = "all" )
# 
# 
# foldchange_imputed_wSD <- longer_imputed_intensities_for_diff_wSD %>%
#   calculate_diff_abundance(
#     sample = sample_id,
#     condition = condition,
#     grouping = gene_ref,
#     intensity_log2 = imputed_intensities,
#     missingness = missingness,
#     comparison = comparison) %>% 
#   mutate(
#     diff = case_when(
#       comparison == "EGF0min_vs_EGF1min" ~ -diff,
#       comparison == "EGF0min_vs_EGF3min" ~ -diff,
#       comparison == "EGF0min_vs_EGF5min" ~ -diff,
#       TRUE ~ diff),
#     comparison = case_when(
#       comparison == "EGF0min_vs_EGF1min" ~ "EGF1min_vs_EGF0min",
#       comparison == "EGF0min_vs_EGF3min" ~ "EGF3min_vs_EGF0min",
#       comparison == "EGF0min_vs_EGF5min" ~ "EGF5min_vs_EGF0min",
#       TRUE ~ comparison))
#   
# 
# 
# 
# ##can add clusters here too!

```

__Xi. total regulated p-sites after imputation
```{r}
# net_regulated_psites_wSD <- foldchange_imputed_wSD %>%
#                 filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>% 
#                 distinct(comparison, diff, adj_pval, gene_ref) %>%
#                 group_by(comparison) %>%
#                 mutate(total_psites = n_distinct(gene_ref)) %>%
#                 ungroup() %>%
#                 mutate(
#                   regulated_psite = case_when(
#                     adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
#                     TRUE ~ "not regulated")) %>% 
#   filter(regulated_psite == "regulated") %>% 
#   distinct(gene_ref) %>% 
#   summarize(
#     n_regulated_psites_between_min_1_duration = n() )
```
78% of well measured pY sites showed a significant intensity change in at least one treatment duration (878 of 1122 pY sites)

__Xii. percent up/down regulated 
```{r}
percent_psite_regulated_imputed_wSD <- foldchange_imputed_wSD %>%
  filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>%
  distinct(comparison, diff, adj_pval, gene_ref) %>%
  group_by(comparison) %>%
  mutate(total_psites = n_distinct(gene_ref)) %>%
  ungroup() %>%
  mutate(
    regulated_psite = case_when(
      adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
      TRUE ~ "not_regulated"),
    regulated_psite_dir = case_when(
      regulated_psite == "regulated" & diff >= 1 ~ "up",
      regulated_psite == "regulated" & diff <= -1 ~ "down",
      regulated_psite == "not_regulated" ~ "not_regulated")) %>%
  group_by(comparison, regulated_psite_dir) %>%
  mutate(n_regulated_psites = n()) %>%
  ungroup() %>%
  distinct(comparison, total_psites, regulated_psite, n_regulated_psites, regulated_psite_dir) %>%
  pivot_wider(id_cols= c(comparison, total_psites), names_from = regulated_psite_dir, values_from = n_regulated_psites) %>%
  group_by(comparison) %>%
  mutate(percent_upregulated = up / total_psites*100,
         percent_downregulated = down / total_psites*100) %>%
  ungroup() %>%
  mutate(
    total_regulated_pYsites = up + down,
    pct_up_vs_total_regulated = up / total_regulated_pYsites *100,
    pct_down_vs_total_regulated = down / total_regulated_pYsites*100,
    percent_regulated = total_regulated_pYsites / total_psites*100,
    percent_not_regulated = not_regulated / total_psites*100) %>%

  #annotation positions for volcano plot
  mutate(
    x_downreg_position = -12,
    x_upreg_position = 12,
    y_position = 6)


percent_psite_regulated_imputed_wSD
```




__Xb. list of regulated pY sites from imputation with SD
```{r}
# regulated_pYsites_wimputation_wSD <- foldchange_imputed_wSD %>%
#   filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>% 
#   distinct(comparison, diff, adj_pval, gene_ref) %>%
#   filter(adj_pval < 0.05) %>% 
#   filter(diff < -1 | diff > 1)
```

##__c. volcano plot imputed

```{r}
psite_volcano_imputed_wSD <- volcano_plot(
  data = foldchange_imputed_wSD %>%  filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")),
  grouping = gene_ref,
  log2FC = diff,
  significance = pval,
  significance_cutoff = c(0.05, "adj_pval"),
  method = "significant",
  facet_by = comparison)

psite_volcano_imputed_wSD
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psite_volcano_imputed_wSD.png", plot = psite_volcano_imputed_wSD, width = 30, height = 18, scale = 0.4)
```

####___i. 15 min vs. untreated
```{r}
my_psite_volcano_imputed_EGF15min_vs_EGF0min_wSD <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>% 
               # filter(abs(diff) < 1) %>% 
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff < -1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "blue", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(diff > 1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "red", alpha = 0.1, shape =19) +
  #down regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF15min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position, label = paste(round(percent_downregulated, 0), "%", " down",sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF15min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position - 2, label = paste0( down, " pY sites"))) +
  #up regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF15min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position, label = paste(round(percent_upregulated, 0), "%", " up", sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF15min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position -2, label = paste0( up, " pY sites"))) +
  alexis_theme()+
  facet_wrap(facets = vars(comparison)) +
  scale_x_continuous(name = "Log2(fold change)", breaks = seq(-15, 20, 5), limits = c(-15, 20)) +
  scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,30,5), limits = c(0, 30))

my_psite_volcano_imputed_EGF15min_vs_EGF0min_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF15min_vs_EGF0min_wSD.png", plot = my_psite_volcano_imputed_EGF15min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF15min_vs_EGF0min_wSD.pdf", plot = my_psite_volcano_imputed_EGF15min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)
  

```
####___ii. 5 min vs. untreated
```{r}
my_psite_volcano_imputed_EGF5min_vs_EGF0min_wSD <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>% 
               # filter(abs(diff) < 1) %>% 
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>% 
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>%
               filter(diff < -1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "blue", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF5min_vs_EGF0min") %>% 
               filter(diff > 1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "red", alpha = 0.1, shape =19) +
  #down regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF5min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position, label = paste(round(percent_downregulated, 0), "%", " down",sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF5min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position - 2, label = paste0( down, " pY sites"))) +
  #up regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF5min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position, label = paste(round(percent_upregulated, 0), "%", " up", sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF5min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position -2, label = paste0( up, " pY sites"))) +
  alexis_theme()+
  facet_wrap(facets = vars(comparison)) +
  scale_x_continuous(name = "Log2(fold change)", breaks = seq(-15, 20, 5), limits = c(-15, 20)) +
  scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,30,5), limits = c(0, 30))

my_psite_volcano_imputed_EGF5min_vs_EGF0min_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF5min_vs_EGF0min_wSD.png", plot = my_psite_volcano_imputed_EGF5min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF5min_vs_EGF0min_wSD.pdf", plot = my_psite_volcano_imputed_EGF5min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)
  

```



####___iii. 3 min vs. untreated
```{r}
my_psite_volcano_imputed_EGF3min_vs_EGF0min_wSD <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>% 
               # filter(abs(diff) < 1) %>% 
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>% 
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>%
               filter(diff < -1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "blue", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF3min_vs_EGF0min") %>% 
               filter(diff > 1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "red", alpha = 0.1, shape =19) +
  #down regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF3min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position, label = paste(round(percent_downregulated, 0), "%", " down",sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF3min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position - 2, label = paste0( down, " pY sites"))) +
  #up regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF3min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position, label = paste(round(percent_upregulated, 0), "%", " up", sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF3min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position -2, label = paste0( up, " pY sites"))) +
  alexis_theme()+
  facet_wrap(facets = vars(comparison)) +
  scale_x_continuous(name = "Log2(fold change)", breaks = seq(-15, 20, 5), limits = c(-15, 20)) +
  scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,30,5), limits = c(0, 30))

my_psite_volcano_imputed_EGF3min_vs_EGF0min_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF3min_vs_EGF0min_wSD.png", plot = my_psite_volcano_imputed_EGF3min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF3min_vs_EGF0min_wSD.pdf", plot = my_psite_volcano_imputed_EGF3min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)
  

```
####___iv.  1 min vs. untreated
```{r}
my_psite_volcano_imputed_EGF1min_vs_EGF0min_wSD <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>% 
               # filter(abs(diff) < 1) %>% 
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>% 
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>%
               filter(diff < -1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "blue", alpha = 0.1, shape =19) +
  geom_point(data = foldchange_imputed_wSD %>%
               filter(comparison == "EGF1min_vs_EGF0min") %>% 
               filter(diff > 1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "red", alpha = 0.1, shape =19) +
  #down regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF1min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position, label = paste(round(percent_downregulated, 0), "%", " down",sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF1min_vs_EGF0min"),
            mapping = aes(x = x_downreg_position, y = y_position - 2, label = paste0( down, " pY sites"))) +
  #up regulated / total sites
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF1min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position, label = paste(round(percent_upregulated, 0), "%", " up", sep = ""))) +
  geom_text(data = percent_psite_regulated_imputed_wSD %>%
              filter(comparison == "EGF1min_vs_EGF0min"),
            mapping = aes(x = x_upreg_position, y = y_position -2, label = paste0( up, " pY sites"))) +
  alexis_theme()+
  facet_wrap(facets = vars(comparison)) +
  scale_x_continuous(name = "Log2(fold change)", breaks = seq(-15, 20, 5), limits = c(-15, 20)) +
  scale_y_continuous(name = "-Log10(adj. p-value)", breaks = seq(0,30,5), limits = c(0, 30))

my_psite_volcano_imputed_EGF1min_vs_EGF0min_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF1min_vs_EGF0min_wSD.png", plot = my_psite_volcano_imputed_EGF1min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_imputed_EGF1min_vs_EGF0min_wSD.pdf", plot = my_psite_volcano_imputed_EGF1min_vs_EGF0min_wSD, width = 10, height = 8, scale = 0.4)
  

```








__Xc. master df w/ sig. FC & 2xDB annotations
```{r}
# psite_diff_abundance_gene_2xDB_imputed_forvolcano <- foldchange_imputed_wSD %>%
#   # filter(gene_ref %in% gt3_obs_for_FC) %>% 
#   separate(gene_ref, into= c("gene", "mod_residue"), sep = "_", remove = FALSE) %>% 
#   rename(psite = mod_residue) %>% 
#   mutate(mod_res = str_sub(psite, end = 1L),
#          mod_residue = as.numeric(str_sub(psite, start = 2L))) %>% 
#   filter(abs(diff) > 1) %>%
#   filter (adj_pval <= 0.05) %>%
#   
#   mutate(my_data = TRUE) %>% 
#   full_join(y = overlap_PSP_PTMSEA %>% mutate(DB2x = TRUE), by = c("gene", "mod_residue", "mod_res") ) %>% 
#   mutate(
#     overlap_my_data = case_when(
#       my_data == TRUE & DB2x ==TRUE ~ "both",
#       my_data == TRUE & is.na(DB2x) ~ "this\nstudy",
#       is.na(my_data) & DB2x ==TRUE ~ "DBs\nonly"),
#     overlap_my_data = fct_relevel(overlap_my_data, "both", "this\nstudy", "DBs\nonly"))
# 
# #counts for annotating plot
# sums_psites_overlap_DBs_my_data_imputed_forvolcano <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
#   filter(mod_res == "Y") %>% 
#   group_by(overlap_my_data) %>%
#   mutate(n_sites = n()) %>%
#   ungroup() %>% 
#   distinct(overlap_my_data, n_sites) %>% 
#   mutate(n_sites_char = as.character(n_sites),
#          overlap_num = case_when(
#            overlap_my_data == "both" ~ 1,
#            overlap_my_data == "this\nstudy" ~ 2,
#            overlap_my_data == "DBs\nonly" ~ 3))

```





##__d. MASTER DF w/ sig. FC & 2xDB annotation
this dataframe only has gene going into it. Thinking if it is going to be okay to join by just gene, or if I need to backtrack and keep reference along too (or I can actually just retroactively attach reference to gene via human_fasta_2024)
```{r}
intermediate_DB_joining_df_imputedwSD_sigFC <- foldchange_imputed_wSD %>%
  filter(abs(diff) > 1) %>%
  filter (adj_pval <= 0.05) %>%

  #keep only comparisons relative to untreated HeLa cells. (difference of a few pY sites)
  filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>% 
  
  
  #get gene name out of the gene_ref for joining.
  separate(gene_ref, into= c("gene", "psite"), sep = "_", remove = FALSE) %>%
  mutate(
    mod_res = str_sub(psite, end = 1L),
    mod_residue = as.numeric(str_sub(psite, start = 2L))) %>% 
  
  # left_join(y = human_fasta_2024 %>% 
  #             separate(gene, into = c("gene", "organism_del"), sep = "_") %>%
  #             select(-organism_del) %>% 
  #                        distinct(gene, reference), by = "gene") %>%
  left_join(y = master_FASTA, by = "gene") %>% #or gene?
  filter(reference %in% (ascore %>% distinct(reference))$reference) %>%
  filter(str_sub(full_protein_sequence, start = mod_residue, end = mod_residue) == "Y") %>% 
   distinct() %>% 
  # left_join(ascore_gene_noImputation %>%
  #             rename(mod_residue = psite) %>% 
  #             mutate(mod_residue = as.numeric(str_sub(mod_residue, start = 2L))) %>% 
  #             distinct(gene, mod_res, mod_residue, reference, ref, full_protein_sequence),
  #           by = c("reference", "gene", "mod_res", "mod_residue")) %>%  #get reference and ref into master dataframe.
  mutate(my_data = TRUE) %>%
  full_join(y = PSP_vs_PTMSigDB_EGF_matches, by = c("gene", "mod_res", "mod_residue"))
  # full_join(y = overlap_PSP_PTMSEA %>% mutate(DB2x = TRUE) %>% select(reference, gene,  mod_residue, mod_res,   PSP, PTM_SEA,DB2x, overlap), by = c("reference", "mod_residue", "mod_res") ) %>% 
  # #do genes match purely after matching on reference?
  # mutate(
  #   genes_match = case_when(
  #     gene.x == gene.y ~ "match",
  #     gene.x != gene.y& my_data == TRUE ~ "not_match",
  #     is.na(gene.x) ~ "DB only",
  #     is.na(gene.y) ~ "my_data_only") ) %>% 
  # #there are no gene names that differ between matching references. However, there may still be gene names that have multiple references, one of which could match my data, while the other gene and sites are duplicates assigned to a different protein group. Therefore, to keep the analysis at pY site level, I will remove duplicate references per gene name in DB only sites where I went in knowing duplicates occured to give best possible chance of matching to my data.
  # group_by(gene.y, mod_res, mod_residue) %>% 
  # mutate(
  #   n_references_per_gene = n_distinct(reference)) %>% 
  # ungroup()


# #COLLAPSE -----------------------------------------    
# #remove the DB only entries, collapse to one reference per gene name, mod_res, and mod_residue then add back via Rbind.
# DB_only_collapse_refs_to_gene_psite_imputedSD_sigFC <- intermediate_DB_joining_df_imputedwSD_sigFC %>% 
#   filter(genes_match == "DB only") %>% 
#   group_by(mod_res, mod_residue, gene.y) %>% 
#   filter(row_number() == 1) %>% 
#   ungroup() %>% 
#   # distinct(mod_res, mod_residue, gene.y, PTM_SEA, DB2x, overlap, genes_match) %>% 
#   
#   # check for duplicate references per gene again after collapsing to gene
#   group_by(gene.y, mod_res, mod_residue) %>% 
#   mutate(
#     n_references_per_gene = n_distinct(reference)) %>% 
#   ungroup()

#REJOIN (MASTER DF HERE) -----------------------------------------  
#rbind the DB set collapsed to single reference per gene.:
psite_diff_abundance_gene_2xDB_imputed_forvolcano <- intermediate_DB_joining_df_imputedwSD_sigFC %>%
  # filter(genes_match != "DB only") %>% #remove the DB sites to enable rbind without duplicating rows.
  # rbind(DB_only_collapse_refs_to_gene_psite_imputedSD_sigFC) %>%
  # #COMBINE 'GENES.X' AND 'GENES.Y' INTO 'GENES'
  # mutate(
  #   gene = case_when(
  #     is.na(gene.x) == TRUE ~ gene.y,
  #     is.na(gene.y) == TRUE ~ gene.x,
  #     gene.x == gene.y ~ gene.x,
  #     TRUE ~ "what happened here")) %>%  #all good, no 'what happened here's.
  # select(-c(gene.x, gene.y)) %>% 
  # 
  # #TEST FOR DUPLICATE REFERENCES AGAIN
  # select(-n_references_per_gene) %>% 
  # group_by(comparison, gene, mod_res, mod_residue) %>% 
  # mutate(
  #   n_references_per_gene = n_distinct(reference)) %>% #successful collapse of multiple references to single gene name.
  # ungroup() %>% 
 #ASSIGN OVERLAPS FOR SUBSEQUENT ANALYSIS:
  
    mutate(
    overlap_my_data = case_when(
      my_data == TRUE & !is.na(DB_overlap) ~ "both",
      my_data == TRUE & is.na(DB_overlap) ~ "this\nstudy",
      is.na(my_data) & !is.na(DB_overlap) ~ "DBs\nonly"),
    overlap_my_data = fct_relevel(overlap_my_data, "both", "this\nstudy", "DBs\nonly"))
#comparisons kept separate, filtered locally for some plots, but want to be able to separate out comparisons such as for volcano plots.
  
  
  
  
  
  
  
#COUNTS FOR PLOTS AND TEXT--------------------------------------

#counts for annotating plot - collapsed comparisons to unique site level
sums_psites_overlap_DBs_my_data_imputed_forvolcano <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  filter(mod_res == "Y") %>%
  distinct(gene, mod_res, mod_residue, overlap_my_data) %>%
  group_by(overlap_my_data) %>%
  mutate(n_sites = n()) %>%
  ungroup() %>%
  distinct(overlap_my_data, n_sites) %>%
  mutate(n_sites_char = as.character(n_sites),
         overlap_num = case_when(
           overlap_my_data == "both" ~ 1,
           overlap_my_data == "this\nstudy" ~ 2,
           overlap_my_data == "DBs\nonly" ~ 3))

```



#### . . .  . write to csv
```{r}
write_csv(x = psite_diff_abundance_gene_2xDB_imputed_forvolcano, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psite_diff_abundance_gene_2xDB_imputed_forvolcano.csv")
```

#### . . . . list of sig reg pY sites
```{r}
sig_reg_pYsites_imputedwSD <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  filter(overlap_my_data != "DBs\nonly") %>% 
  distinct(gene, mod_res, mod_residue, overlap_my_data) %>% 
  mutate(gene_ref = paste0(gene, "_", mod_res, mod_residue))
  
```

### REF LIST of regulated vs. not regulated for App and other uses
```{r}
# 
# ######################
# DB_overlap <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
#   filter(!is.na(reference)) %>% #join in DB only that was lacking reference below, added above.
#              distinct(reference, gene, mod_res, mod_residue, overlap_my_data) %>%
# 
#   rename(position = mod_residue)
# 
# 
# #####################
# #genes to convert via uniprot or toher for reference
# genes_to_convert_to_uniprot <- DB_overlap %>% distinct(gene)
# 
# 
# 
# # Connect to the Ensembl BioMart
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
# 
# # Example gene list
# genes <- genes_to_convert_to_uniprot$gene
# 
# # Query: gene name ??? UniProt accession
# mapping <- getBM(
#   attributes = c("hgnc_symbol", "uniprotswissprot"),  # SwissProt is reviewed entries
#   filters = "hgnc_symbol",
#   values = genes,
#   mart = ensembl
# )
# 
# mapping <- mapping %>% filter(str_length(uniprotswissprot) > 0) %>% rename(gene = hgnc_symbol) %>% rename(reference = uniprotswissprot)
# 
# 
# ######################
# DB_overlap_DBonly <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
#   filter(is.na(reference)) %>%
#    distinct( gene, mod_res, mod_residue, overlap_my_data) %>%
#   left_join(y = mapping, by = "gene") %>%
# 
# 
#   rename(position = mod_residue) %>%
#   # rename(acc = reference) %>%
#   rename(residue = mod_res)
# 
# #######################
# DB_overlap <-  DB_overlap %>%  rbind(DB_overlap_DBonly)
# 
# 
# 
# 
# 
# 
# #####################
# list_regulated_psites_wSD <- foldchange_imputed_wSD %>%
#                 filter (comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min")) %>%
#                 distinct(comparison, diff, adj_pval, gene_ref) %>%
#                 group_by(comparison) %>%
#                 mutate(total_psites = n_distinct(gene_ref)) %>%
#                 ungroup() %>%
#                 mutate(
#                   regulated_psite = case_when(
#                     adj_pval <= 0.05 & abs(diff) >= 1 ~ "regulated",
#                     TRUE ~ "not regulated")) %>%
#   distinct(gene_ref, regulated_psite) %>%
#   separate(gene_ref, into = c("gene", "position"), sep= "_Y", remove = FALSE) %>%
#   mutate(position = as.numeric(position)) %>%
#   left_join(y = DB_overlap) %>%
#   left_join(y = master_FASTA , by = c("gene","reference"))
# 
# 
# 
# write_csv(x = list_regulated_psites_wSD, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/master_list_REG_vs_NOTREG_pY.csv")
```

#### . . .  . barplot DB2x vs. my data
plot database overlaps
comparisons considered separately
```{r}
overlap_imputedwSD_2xDB <- ggplot() +
  geom_bar(data = psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
             distinct(mod_res, mod_residue, gene, overlap_my_data),
           mapping = aes(x= overlap_my_data, fill = mod_res), color = "black", size = 1) +
  geom_text(data = sums_psites_overlap_DBs_my_data_imputed_forvolcano, aes(x = overlap_num, y = n_sites + 20, label = n_sites_char)) +
  scale_fill_viridis_d(direction = -1) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, lineheight = 0.5, vjust = 1),
        axis.text.y = element_text( size = 12),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 14)) +
  scale_y_continuous(limits = c(0, 1000),breaks = c(seq(0, 1000, 200)), expand = c(0, 0)) +
  ylab("unique phosphosites") +
  xlab("database overlap")

overlap_imputedwSD_2xDB

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlap_imputedwSD_2xDB_uniquepYsites.png", plot = overlap_imputedwSD_2xDB, width = 10, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlap_imputedwSD_2xDB_uniquepYsites.pdf", plot = overlap_imputedwSD_2xDB, width = 10, height = 10, scale = 0.4)
```

####. . . ___ PUB colors
DB2x vs. my data
```{r}
overlap_2xDB_mydata_imputed <- ggplot() +
  geom_bar(data = psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
             distinct(gene, mod_res, mod_residue, overlap_my_data), #only significant changing sites
           # mapping = aes(x= overlap_my_data, fill = mod_res, color = overlap_my_data),
           mapping = aes(x= overlap_my_data, fill = overlap_my_data),
           alpha = 0.8,
           color = "black",
           width = 0.75,
           size = 0.75,
           show.legend = FALSE) +
  geom_text(data = sums_psites_overlap_DBs_my_data_imputed_forvolcano, aes(x = overlap_num, y = n_sites -50, label = n_sites_char), size = 5) +
  # scale_fill_viridis_d(direction = -1) +
  # scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 12, lineheight = 0.5, vjust = 1),
        axis.text.y = element_text( size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 14)) +
  scale_y_continuous(limits = c(0, 750), breaks = c(seq(0, 700, 100)), expand = c(0, 0)) +
  ylab("unique pY sites") +
  xlab("annotation intersects")

overlap_2xDB_mydata_imputed

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_sites_2databases_mydata_imputed_wSD.png", plot = overlap_2xDB_mydata_imputed, width = 8, height = 12, scale = 0.3)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_sites_2databases_mydata_imputed_wSD.pdf", plot = overlap_2xDB_mydata_imputed, width = 7, height = 10, scale = 0.3)
```
this is when imputed median norm intensity of 9 for any conditions without any observations as well as imputing by mean intensity for any replicates with partial measurements. The risk of this is overinflating changes to mis-localized p-sites and imputing out their abundances across replicates. This are likely measured in only 1 replicate.

I could perhaps just remove psites identified in only 1 replicate and treat them as not measured at all in that condition. AS a result, if they are measured in different replicates we will get a fold change. Otherwise, if they are not measured in other reps more than once, all will be at intensity of 9 and fold change 0/ insignificant. 








####___i. volcano painted with database coverage
imputed based on mean + SD where MAR use mean of other observations and observed average standard deviation ~ 0.67. 
In contrast, missing not at random (i.e. observations missing in all 6/6 replicates) were imputed with mean of 10 and SD = 1 using rnorm.
```{r}
imputed_diff_wSD_forFC_all <- foldchange_imputed_wSD %>% 
  ungroup() %>% 
  mutate(
    comparison = fct_relevel(comparison, "EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"),
    comparison_strip = case_when(
      comparison == "EGF1min_vs_EGF0min" ~ "EGF 1min",
      comparison == "EGF3min_vs_EGF0min" ~ "EGF 3min",
      comparison == "EGF5min_vs_EGF0min" ~ "EGF 5min",
      comparison == "EGF15min_vs_EGF0min" ~ "EGF 15min"),
    comparison_strip = fct_relevel(comparison_strip, "EGF 1min","EGF 3min","EGF 5min","EGF 15min"))


imputed_diff_wSD_forFC <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>% 
  ungroup() %>%
  filter(overlap_my_data != "DBs\nonly") %>%
  mutate(
    comparison = fct_relevel(comparison, "EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"),
    comparison_strip = case_when(
      comparison == "EGF1min_vs_EGF0min" ~ "EGF 1min",
      comparison == "EGF3min_vs_EGF0min" ~ "EGF 3min",
      comparison == "EGF5min_vs_EGF0min" ~ "EGF 5min",
      comparison == "EGF15min_vs_EGF0min" ~ "EGF 15min"),
    comparison_strip = fct_relevel(comparison_strip, "EGF 1min","EGF 3min","EGF 5min","EGF 15min"),
    overlap_my_data = case_when(
      overlap_my_data == "this\nstudy" ~ "this study\nonly",
      overlap_my_data == "both"   ~ "this study\n& DB"))


my_psite_volcano_plot_2xDB_imputedwSD <- ggplot() +
  geom_vline(xintercept = c(-1, 1), color = "darkgrey", alpha = 0.5, size =1, linetype = 2)+
  geom_hline(yintercept = -log10(0.05), color = "darkgrey", alpha = 0.5, size = 1, linetype = 2) +
  geom_point(data = imputed_diff_wSD_forFC_all %>%
               # filter(gene_ref %in% gt3_obs_for_FC) %>%
               filter(grepl("EGF0min", comparison) == TRUE) %>% 
               distinct(comparison,comparison_strip, diff, adj_pval, gene_ref) %>% 
               # filter(comparison == "EGF15min_vs_EGF0min") %>% 
               # filter(abs(diff) < 1) %>% 
               filter(adj_pval >0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = imputed_diff_wSD_forFC_all %>%
               # filter(gene_ref %in% gt3_obs_for_FC) %>%
               filter(grepl("EGF0min", comparison) == TRUE) %>%
               distinct(comparison,comparison_strip, diff, adj_pval, gene_ref) %>%
               # filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(abs(diff) < 1) %>%
               filter(adj_pval <0.05),
             mapping = aes(x = diff, y = -log10(adj_pval)), color = "grey", alpha = 0.3, shape =19) +
  geom_point(data = imputed_diff_wSD_forFC %>%
               # filter(gene_ref %in% gt3_obs_for_FC) %>%
               filter(grepl("EGF0min", comparison) == TRUE) %>%
               distinct(comparison,comparison_strip, diff, adj_pval, gene_ref, overlap_my_data) %>%
               # filter(comparison == "EGF15min_vs_EGF0min") %>%
               filter(diff < -1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  geom_point(data = imputed_diff_wSD_forFC %>%
               # filter(gene_ref %in% gt3_obs_for_FC) %>%
               filter(grepl("EGF0min", comparison) == TRUE) %>%
               distinct(comparison,comparison_strip, diff, adj_pval, gene_ref, overlap_my_data) %>%
               # filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(diff > 1) %>% 
               filter(adj_pval <= 0.05),
             mapping = aes(x = diff, y = -log10(adj_pval), color = overlap_my_data), alpha = 0.3, shape =19) +
  
  facet_wrap(facets = vars(comparison_strip)) +
  
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_color_brewer(palette = "Dark2") +
  theme(legend.text = element_text(size = 12, lineheight = 0.75, hjust = 0.5, family = "sans"), 
        legend.title = element_text(size = 12, hjust = 1, face = "bold", family = "sans"),
        legend.position = "bottom",
        legend.margin = margin(t = 0, unit='cm')) +
  guides(color = guide_legend( 
    override.aes=list(size = 4))) +
  labs(color = "annotation\nintersect") +
  scale_x_continuous(name = expression("Log"[2]*"(fold change)"), breaks = seq(-15, 20, 5), limits = c(-15, 20)) +
  scale_y_continuous(name = expression("-Log"[10]*"(adj. p-value)"), breaks = seq(0,30,10), limits = c(0, 30))

my_psite_volcano_plot_2xDB_imputedwSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_2xDB_imputedwSD.png", plot = my_psite_volcano_plot_2xDB_imputedwSD, width = 14, height = 12, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/my_psite_volcano_plot_2xDB_imputedwSD.pdf", plot = my_psite_volcano_plot_2xDB_imputedwSD, width = 14, height = 12, scale = 0.4)
```
SD = 1 (not 0.67 which is avg SD per psite within a timepoint.)


However, the significance of down regulated sites upon stimulation looks quite high. I am not sure if this is thanks to imputing fully missing sites in a condition or for smaller SD and more measurements.

Also, I could paint by sites on the same protein already annotated... this can help me to identify proteins thougth to be involved but without regulatory information.

#####____ a. boxplot fold change distribution
```{r}
boxplot_foldchange_distribution_imputed_wSD <- ggplot(data = imputed_diff_wSD_forFC %>%
               # filter(gene_ref %in% gt3_obs_for_FC) %>%
               filter(grepl("EGF0min", comparison) == TRUE) %>%
               distinct(comparison,comparison_strip, diff, adj_pval, gene_ref, overlap_my_data) %>%
               # filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(diff > 1 | diff > 1) %>% 
               filter(adj_pval <= 0.05)) + 
  geom_boxplot(mapping = aes(x = overlap_my_data, y = diff, fill = overlap_my_data), alpha = 0.5) +
  facet_wrap(facets = vars(comparison_strip)) +
  
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_fill_brewer(palette = "Dark2") +
  theme(legend.text = element_text(size = 12, lineheight = 0.75, hjust = 0.5, family = "sans"), 
        legend.title = element_text(size = 12, hjust = 1, face = "bold", family = "sans"),
        legend.position = "bottom",
        legend.margin = margin(t = 0, unit='cm'),
        strip.text = element_text(size = 14, face = "bold", family = "sans"),
        axis.title.y = element_text(size = 16, face = "bold", family = "sans"),
        axis.text.x = element_text(size = 10,  family = "sans")) +
  guides(color = guide_legend( 
    override.aes=list(size = 4))) +
  labs(fill = "annotation\nintersect") +
  xlab("p-site annotation intersect") +
  scale_y_continuous(name = expression("Log"[2]*"(fold change)"), breaks = seq(0,16,4), limits = c(0, 16), expand = c(0, 0.1))


boxplot_foldchange_distribution_imputed_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/boxplot_foldchange_distribution_imputed_wSD.png", plot = boxplot_foldchange_distribution_imputed_wSD, width = 6, height = 6, scale = 0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/boxplot_foldchange_distribution_imputed_wSD.pdf", plot = boxplot_foldchange_distribution_imputed_wSD, width = 6, height = 8, scale = 0.4)

```

#####____ b. boxplot adj p-val distribution
```{r}
boxplot_pval_distribution_imputed_wSD <- ggplot(data = imputed_diff_wSD_forFC %>%
               # filter(gene_ref %in% gt3_obs_for_FC) %>%
               filter(grepl("EGF0min", comparison) == TRUE) %>%
               distinct(comparison,comparison_strip, diff, adj_pval, gene_ref, overlap_my_data) %>%
               # filter(comparison == "EGF15min_vs_EGF0min") %>% 
               filter(diff > 1 | diff > 1) %>% 
               filter(adj_pval <= 0.05)) + 
  geom_boxplot(mapping = aes(x = overlap_my_data, y = -log10(adj_pval), fill = overlap_my_data), alpha = 0.5) +
  facet_wrap(facets = vars(comparison_strip)) +
  
  alexis_theme() +
  coord_cartesian(clip = 'off') +
  scale_fill_brewer(palette = "Dark2") +
  theme(legend.text = element_text(size = 12, lineheight = 0.75, hjust = 0.5, family = "sans"), 
        legend.title = element_text(size = 12, hjust = 1, face = "bold", family = "sans"),
        legend.position = "bottom",
        legend.margin = margin(t = 0, unit='cm'),
        strip.text = element_text(size = 14, face = "bold", family = "sans"),
        axis.title.y = element_text(size = 16, face = "bold", family = "sans"),
        axis.text.x = element_text(size = 10,  family = "sans")) +
  guides(color = guide_legend( 
    override.aes=list(size = 4))) +
  labs(fill = "annotation\nintersect") +
  xlab("p-site annotation intersect") +
  scale_y_continuous(name = expression("-Log"[10]*"(adj. p-value)"), breaks = seq(0,30,10), limits = c(0, 30), expand = c(0, 0.1))


boxplot_pval_distribution_imputed_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/boxplot_pval_distribution_imputed_wSD.png", plot = boxplot_pval_distribution_imputed_wSD, width = 6, height = 6, scale = 0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/boxplot_pval_distribution_imputed_wSD.pdf", plot = boxplot_pval_distribution_imputed_wSD, width = 6, height = 8, scale = 0.4)

```



###__e. TOTAL PROTEOME VS. pY CHANGES
```{r}
#proteins showing differential abundance at proteome level
changing_proteins_TP_df <- read_csv("raw_data/MainFig3to6_SuppFig9to15/Proteome/proteins_diff_abundance_less.csv") %>% 
  mutate(comparison = case_when(
    comparison == "0_vs_15" ~ "EGF15min_vs_EGF0min",
    comparison == "0_vs_5" ~ "EGF5min_vs_EGF0min",
    comparison == "0_vs_3" ~ "EGF3min_vs_EGF0min",
    comparison == "0_vs_1" ~ "EGF1min_vs_EGF0min"),
    diff = -diff)
unique_changing_proteins <-  distinct(changing_proteins_TP_df, gene)$gene


#join pY with total proteome dataframes
overlap_pY_regulated_w_TP <- regulated_pYsites_wimputation_wSD %>%
  mutate(CHG_YP = "YP") %>% 
  rename(diff_pYsite = diff) %>% 
  separate(gene_ref, into = c("gene", "psite"), sep =  "_", remove = FALSE) %>% 
  full_join(y = changing_proteins_TP_df %>%
              mutate(CHG_TP = "TP") %>%
              rename(diff_proteome = diff) %>% distinct(gene, comparison, CHG_TP, diff_proteome), by = c("gene", "comparison")) %>% 
  mutate(adjusted_proteome_foldchange = diff_pYsite - diff_proteome)
  
```

Only GOLIM4 protein matches the pY proteins. The GOLIM4 protein increases in abundance by 1.3 to 1.4 fold at 5 min and 15 min, respectively. Despite the abundance increase, the pY site abundance decreases drastically by 2^8.8 and 2^8.3 fold.



#11. DATABASE ANNOTATION JOIN
This code chunk assesses how many of the pY sites match database annotations from PSP, PTMSigDB and Phosphopedia (only adds BCAR1).
 

### . .GENE (PROTEIN)
####. . . ___ dataframe 
```{r}
gene_diff_abundance_gene_2xDB_imputed <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%  
  distinct(gene,overlap_my_data)

#counts for annotating plot
sums_gene_overlap_DBs_my_data_imputed <- gene_diff_abundance_gene_2xDB_imputed %>%
  # filter(mod_res == "Y") %>% 
  group_by(overlap_my_data) %>%
  mutate(n_genes = n()) %>%
  ungroup() %>% 
  distinct(overlap_my_data, n_genes) %>% 
  mutate(n_genes_char = as.character(n_genes),
         overlap_num = case_when(
           overlap_my_data == "both" ~ 1,
           overlap_my_data == "this\nstudy" ~ 2,
           overlap_my_data == "DBs\nonly" ~ 3))
sums_gene_overlap_DBs_my_data_imputed

```

####. . . ___ plot 
DB2x vs. my data
```{r}
overlap_2xDB_mydata_imputed_gene <- ggplot() +
  geom_bar(data = gene_diff_abundance_gene_2xDB_imputed ,
           # mapping = aes(x= overlap_my_data, fill = mod_res, color = overlap_my_data),
           mapping = aes(x= overlap_my_data, fill = overlap_my_data),
           alpha = 0.8,
           color = "black",
           width = 0.75,
           size = 0.75,
           show.legend = FALSE) +
  geom_text(data = sums_gene_overlap_DBs_my_data_imputed, aes(x = overlap_num, y = n_genes -20, label = n_genes_char), size = 5) +
  # scale_fill_viridis_d(direction = -1) +
  # scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 12, lineheight = 0.5, vjust = 1),
        axis.text.y = element_text( size = 14),
        axis.title = element_text(size = 14),
        legend.title = element_text(size = 14)) +
  scale_y_continuous(limits = c(0, 600), expand = c(0, 0)) +
  ylab("unique genes with pY") +
  xlab("annotation intersects")

overlap_2xDB_mydata_imputed_gene

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_genes_2databases_mydata_imputed_wSD.png", plot = overlap_2xDB_mydata_imputed_gene, width = 8, height = 12, scale = 0.3)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_genes_2databases_mydata_imputed_wSD.pdf", plot = overlap_2xDB_mydata_imputed_gene, width = 6, height = 10, scale = 0.3)
```



##__ii. GENE joined (3x DB, PSP, PTMSigDB, WP437)
START OF GENE LEVEL DATABASE ANNOTATION COMPARISON
### . . . . plot just DB overlaps, none of my data yet
look at agreement at protein level between databases. 
```{r}
#combine all three databases of genes annotated to be EGF responsive ------------
WP437 <- c('NOS3','COX2','SHC1','STAT5A','RALA','NEDD4','ELK4','MAPK1','MAPK8','ARHGEF1','STMN1','STAT1','EPS15L1','SH3GL3','EGF','INPP5D','PTPN5','ATF1','GRB10','ERRFI1','GRIM19','MAP3K1','PTK6','RPS6KA2','CSK','PCNA','KRAS','LIMK2','RASA1','ARF6','IQGAP1','EGFR','SP1','BRAF','DOK2','PTPRR','CRK','SH2D2A','MAPK9','RPS6KA3','RIN1','CAV2','E2F1','VAV2','SOS2','PTPN12','MTOR','NCK2','MAP3K3','RALGDS','VAV3','CAMK2A','STAT3','MAPK3','SOS1','GAB2','RAP1A','JAK1','CDC42','NCOA3','ATXN2','RAB5A','RPS6KB1','MAPK14','ASAP1','SYNJ1','MAP2K1','RAF1','EPN1','NCK1','STAMBP','CAV1','STAM2','HGS','MAP2K2','CREB1','PLCG1','ERBB2','SPRY2','INPPL1','EIF4EBP1','MAP4K1','RICTOR','USP6NL','RPS6KA5','PTK2B','PIK3R2','PLD2','EPS8','RAC1','ABI1','PLSCR1','PIK3R1','MEF2D','GAB1','PLCE1','PLD1','DNM1','JUN','PIAS3','SH3GL2','RPS6KA1','ROCK1','MAP3K4','PRKCD','AP2B','AKT1','FOXO1','VAV1','PRKCZ','RALB','FOS','PRKCI','PRKCA','SRC','ITCH','ABL1','RALBP1','MAPK7','REPS2','JUND','GRB2','EPS15','USP8','AP2A1', 'AP2B1', 'HRAS','PDPK1','IQSEC1','PEBP1','SH3KBP1','TNK2','PTPN11','AP2S1','PRKCB','FOXO4','FOSB','PTEN','NEDD8','STAM','GJA1','CRKL','JAK2','MAP2K5','BCAR1','MAP3K2','ELK1','STAT5B','PIK3C2B','STXBP1','CBLB','CBL','CBLC','PAK1','CFL1','PTK2','AP2M1','MEF2A','PXN','MEF2C')

#turn wiki pathways into a dataframe
WP437_gene_df <- data.frame("gene" = WP437, "WP437" = TRUE)

#combine genes from all four database sources into a single dataframe
gene_3xDB_overlap <-  PSP_vs_PTMSigDB_EGF %>% 
  distinct(gene, mod_res, mod_residue, PSP, PTM_SEA) %>% 
 #get rid of reference, just join by gene name, as WP437 is gene only. This step using distinct removes duplicate references.
 
              full_join(y = WP437_gene_df, by = "gene") %>% 
              distinct(gene, PSP, PTM_SEA,  WP437) %>% 
  pivot_longer(cols = c(PSP, PTM_SEA,  WP437), names_to = "DB") %>% 
  rename(present_in_DB = value) %>%
  filter(present_in_DB == TRUE)
  
  
  #df for Upset plot ------------------------------
gene_3xDB_overlap_upset_df <-  PSP_vs_PTMSigDB_EGF %>% 
  distinct(gene, mod_res, mod_residue, PSP, PTM_SEA) %>% 
              full_join(y = WP437_gene_df, by = "gene") %>% 
              distinct(gene, PSP, PTM_SEA,  WP437) %>% 
  # pivot_longer(cols = c(PSP, PTM_SEA, PPDIA, WP437), names_to = "DB") %>% 
  # rename(present_in_DB = value) %>%
  # filter(present_in_DB == TRUE) %>%
    mutate(PSP_upset = case_when(
      PSP == TRUE ~ 1, 
      TRUE ~ 0),
      PTM_SEA_upset = case_when(
      PTM_SEA == TRUE ~ 1, 
      TRUE ~ 0),
      # PPDIA_upset = case_when(
      # PPDIA == TRUE ~ 1, 
      # TRUE ~ 0),
      WP437_upset = case_when(
      WP437 == TRUE ~ 1, 
      TRUE ~ 0)) %>% 
  dplyr::select(gene, PSP_upset, PTM_SEA_upset,  WP437_upset) %>% 
  dplyr::rename(PSP = PSP_upset) %>% 
  dplyr::rename(PTM_SEA =  PTM_SEA_upset) %>% 
  # rename(PPDIA= PPDIA_upset) %>% 
  dplyr::rename(WP437 = WP437_upset) %>% 
  dplyr::select(PSP, PTM_SEA, WP437) %>% 
  dplyr::mutate(across(everything(), as.numeric)) %>%  
  as.matrix() %>% 
  as.data.frame()

upset(gene_3xDB_overlap_upset_df, nsets = 4, nintersects = 20, text.scale = 2)
```

plot
```{r}
gene_overlaps_just_DB <- ggplot(data = gene_3xDB_overlap) +
  geom_bar(mapping = aes(x = DB  )) +
  alexis_theme() +
  ylab("unique genes in EGF signature") +
  xlab("database shorthand")

gene_overlaps_just_DB
```
PSP has far more genes annotated with EGF than PTM SEA or WP437. This may explain the discrepancy. 

### . . .  . dataframe
compare genes on which we detect pY in this study relative to 4 databases of EGF stimulation responses
```{r}


gene_diff_abundance_3xDB <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>% 
 #  foldchange_imputed_wSD %>%
 #  separate(gene_ref, into = c("gene", "mod_residue"), sep = "_", remove = FALSE) %>%
 # mutate(mod_res = str_sub(mod_residue, end = 1L),
 #         mod_residue = str_sub(mod_residue, start = 2L)) %>%  #this doesn't matter here because distinct(gene) below
 #  filter(mod_res == "Y") %>%
 #  filter(abs(diff) > 1) %>%
 #  filter (adj_pval <= 0.05) %>%
 #  distinct(gene) %>%
 #  mutate(my_data = TRUE) %>%
  full_join(y = gene_3xDB_overlap %>% mutate(DB3x = TRUE), by = "gene") %>%
  # full_join(y = overlap_PSP_PTMSEA %>%
  #             filter(mod_res == "Y") %>% # filter for only proteins with pY observed when possible. WP437 lacks site info
  #             full_join(y = WP437_gene_df, by = "gene") %>%
  #             distinct(gene) %>%
  #             mutate(DB4x = TRUE), by = c("gene") ) %>%
  mutate(
    overlap_my_data_3xDB = case_when(
      my_data == TRUE & DB3x ==TRUE ~ "both",
      my_data == TRUE & is.na(DB3x) ~ "this\nstudy",
      is.na(my_data) & DB3x ==TRUE ~ "3xDBs\nonly"),
    overlap_my_data_3xDB = fct_relevel(overlap_my_data_3xDB, "both", "this\nstudy", "3xDBs\nonly"))

#counts for annotating plot
sums_genes_overlap_3XDBs_my_data <- gene_diff_abundance_3xDB %>%
  #already only pY sites
  group_by(overlap_my_data_3xDB) %>%
  mutate(n_sites = n(),
         n_genes = n_distinct(gene)) %>%
  ungroup() %>%
  distinct(overlap_my_data_3xDB, n_sites,  n_genes) %>%
  mutate(n_sites_char = as.character(n_sites),
         n_genes_char = as.character(n_genes),
         overlap_num = case_when(
           overlap_my_data_3xDB == "both" ~ 1,
           overlap_my_data_3xDB == "this\nstudy" ~ 2,
           overlap_my_data_3xDB == "3xDBs\nonly" ~ 3))


#only proteins with pY found -----------------------------------------------
#COMMENTED OUT BECAUSE THIS IS ESSENTIALLY THE SAME ANALYSIS AS GENE(PROTEIN) ABOVE SINCE ALL OF THOSE GENES IN 2X DB ARE NOW ALREADY FILTERED FOR pY SITES.
# gene_diff_abundance_3xDB_pYfound <- foldchange_imputed_wSD %>%
#   separate(gene_ref, into = c("gene", "mod_residue"), sep = "_", remove = FALSE) %>% 
#   mutate(mod_res = str_sub(mod_residue, end = 1L),
#          mod_residue = str_sub(mod_residue, start = 2L)) %>%  #this doesn't matter here because distinct(gene) below
#   filter(mod_res == "Y") %>% 
#   filter(abs(diff) > 1) %>%
#   filter (adj_pval <= 0.05) %>%
#   
#   mutate(my_data = TRUE) %>%
#   # full_join(y = gene_3xDB_overlap %>% mutate(DB4x = TRUE), by = "gene") %>% 
#   full_join(y = overlap_PSP_PTMSEA %>%
#               filter(mod_res == "Y") %>% # filter for only proteins with pY observed when possible. WP437 lacks site info
#               # full_join(y = WP437_gene_df, by = "gene") %>%
#               distinct(gene) %>%
#               mutate(DB3x = TRUE), by = c("gene") ) %>%
#   mutate(
#     overlap_my_data = case_when(
#       my_data == TRUE & DB3x ==TRUE ~ "both",
#       my_data == TRUE & is.na(DB3x) ~ "this\nstudy",
#       is.na(my_data) & DB3x ==TRUE ~ "DBs\nonly"),
#     overlap_my_data = fct_relevel(overlap_my_data, "both", "this\nstudy", "DBs\nonly"))
# 
# 
# #counts for annotating plot
# sums_genes_overlap_DBs_my_data_pYfound <- gene_diff_abundance_3xDB_pYfound %>%
#   #already only pY sites 
#   group_by(overlap_my_data) %>%
#   mutate(n_sites = n(),
#          n_genes = n_distinct(gene)) %>%
#   ungroup() %>% 
#   distinct(overlap_my_data, n_sites,  n_genes) %>% 
#   mutate(n_sites_char = as.character(n_sites),
#          n_genes_char = as.character(n_genes),
#          overlap_num = case_when(
#            overlap_my_data == "both" ~ 1,
#            overlap_my_data == "this\nstudy" ~ 2,
#            overlap_my_data == "DBs\nonly" ~ 3))

```
### . . .  . write to csv
```{r}
write_csv(x = gene_diff_abundance_3xDB, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/gene_diff_abundance_3xDB.csv")
```

```{r}
# write_csv(x = gene_diff_abundance_3xDB_pYfound, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/gene_diff_abundance_3xDB_pYfound.csv")
```


### . . .   barplot DB3x vs. my data at protein level
plot database overlaps at the shared gene level.
```{r}
overlap_3xDB_mydata_gene <- ggplot() +
  geom_bar(data = gene_diff_abundance_3xDB %>% distinct(gene, overlap_my_data_3xDB),
           mapping = aes(x= overlap_my_data_3xDB, fill = overlap_my_data_3xDB), color = "black", size = 1, show.legend = FALSE) +
  geom_text(data = sums_genes_overlap_3XDBs_my_data, aes(x = overlap_num, y = n_genes - 20, label = n_genes_char), size = 4) +
  scale_fill_brewer(palette = "Dark2") +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, lineheight = 0.75, vjust = 1),
        axis.text.y = element_text( size = 12),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 14)) +
  scale_y_continuous(limits = c(0, 500), expand = c(0, 0)) +
  ylab("unique genes") +
  xlab("database overlap") +
  ggtitle ("Gene overlap: this study vs. 3 databases")

overlap_3xDB_mydata_gene

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_genes_3databases_mydata.png", plot = overlap_3xDB_mydata_gene, width = 5, height = 8, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/overlaps_EGFR_genes_3databases_mydata.pdf", plot = overlap_3xDB_mydata_gene, width = 5, height = 8, scale = 0.4)
```
This shows number of genes in any of 4 EGF response signatures (databases = PSP, PTMSigDB, PhosphopeDIA (ErbB), and Wikipathway 437 (EGF/EGFR signaling)). 
The green bar shows numbers of genes with a pY site detected in our study and a gene in any of 4 annotated the EGF stimulation signatures. 
The orange bar is very exciting because this shows the number of genes for which a protein with a significantly regulated pY site in our study has not been detected in any of the 4 annotation databases. 
The purple bar indicates genes on which we did not detect pY in this study but in which are annotated in any of the four databases as either pSTY or just gene level involved in the pathway. The genes unique to WP437 are known to be involved in the EGF signaling response but without phosphosites annotated by PSP or PTMSigDB.



#------------------------------------------------------------------
#12. MOTIF ANALYSIS
by cluster
by annotation
start with by cluster

Update Jan 25, 2024:
I will switch from df: psite_diff_abundance_gene_2xDB_imputed_forvolcano _to df: psite_diff_abundance_gene_Imputation_wSD_2xDB_ due to the former dataframe retaining many different references/entries for the same gene. Perhaps this stems from phosphosite plus using both new and old references for backward compatibility with uniprot ids. However, without the exact full protein sequence in the databases, it is hard to know which protein sequence the contributing studies actually referred to for a database dataset that large.

 
####---function to extract padded and centered motif
no special formatting, just centered mod residue, +/-7 aa. Saved as a .txt file without header for direct upload to Phosphosite.org motif or sequence logo tool.
```{r}
extract_centered_string <- function(long_string, center_index, side_length = 7) {
  # Calculate the total length of the substring to extract
  total_length <- 2 * side_length + 1
  
  # Calculate start and end indices for the substring
  start_index <- max(center_index - side_length, 1)
  end_index <- min(center_index + side_length, nchar(long_string))
  
  # Extract the substring
  extracted_string <- substr(long_string, start_index, end_index)
  
  # Calculate padding needed on left and right
  left_padding <- max(0, side_length - (center_index - 1))
  right_padding <- max(0, side_length - (nchar(long_string) - center_index))
  
  # Pad the extracted substring
  padded_string <- paste0(strrep("_", left_padding), extracted_string, strrep("_", right_padding))
  
  
  return(padded_string)
}

# # Example usage
# long_string <- "This is an example long string for testing."
# center_index <- 10
# 
# centered_string <- extract_centered_string(long_string, center_index)
# print(centered_string)
```


###---use mapply to mutate on the padded centered phosphosites
commented out the join to data_clustered_reps which allows calculating motifs based on cluster assignment. The issue is cluster assignment happens in code below, after imputation without SD. I could move all the motif analysis code to below the imputation without SD, however, I ended up just computing motifs based on database overlap, so this is no longer necessary, and I am lazy, but more importantly this clarifies on which dataset the motif analysis depends on.
```{r}
#extract 15 amino acid lengths with phospho amino acid centered for motif analysis

flanked_psite_regulated <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  # left_join(y = master_FASTA, by = "reference") %>%
  distinct(gene,  gene_ref, overlap_my_data, mod_res, mod_residue) %>% 

  # left_join((data_clustered_reps_df %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%  #add in cluster for filtering
  # filter(cluster == 4) %>% #update cluster!
  # filter(overlap_my_data == "this\nstudy" | overlap_my_data == "both") %>%
  # filter(overlap_my_data == "this\nstudy") %>%
  filter(overlap_my_data == "DBs\nonly") %>%
  left_join(y = master_FASTA, by = "gene") %>% 
  filter(str_sub(full_protein_sequence, start = mod_residue, end = mod_residue) == "Y") %>%
  distinct(gene_ref, mod_residue, full_protein_sequence) %>%
  mutate(
    # mod_loc = as.numeric(mod_loc),
    aa_motif_15 = mapply(extract_centered_string, long_string = full_protein_sequence, center_index = mod_residue)) %>%
  distinct(aa_motif_15)%>%
  #still have some off-length motifs. seemingly derived from different references of same gene. I think protein group vs. psite mapping could be off after several joining steps... but not certain this is the root cause.
  filter(str_length(aa_motif_15) == 15)



```

#####--- write_csv padded centered sites

```{r}
#update cluster in file name according to above filter.
write_delim(x = (flanked_psite_regulated), file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/flanked_psite_regulated_DBsonly_15mers.txt", col_names = FALSE)
```
Modified above filters and saved txt file with a new name each time.

####---no Y function
remove central Y in motifs ot improve amino acid resolution in sequence logos.
```{r}
extract_centered_string_noY <- function(long_string, center_index, side_length = 7) {
  # Calculate the total length of the substring to extract
  total_length <- 2 * side_length + 1
  
  # Calculate start and end indices for the substring
  start_index <- max(center_index - side_length, 1)
  end_index <- min(center_index + side_length, nchar(long_string))
  
  # Extract the substring
  extracted_string <- substr(long_string, start_index, end_index)
  
  # Calculate padding needed on left and right
  left_padding <- max(0, side_length - (center_index - 1))
  right_padding <- max(0, side_length - (nchar(long_string) - center_index))
  
  # Pad the extracted substring
  padded_string <- paste0(strrep("_", left_padding), extracted_string, strrep("_", right_padding))
  
  #remove Y
  padded_string_noY <- paste(str_sub(padded_string, start = 1L, end = 7L), " ", str_sub(padded_string, start = 9L), sep = "")
  
  return(padded_string_noY)
}

```

###---no Y dataframe/ vector
 - modified filters, this time copy pasting code chunks for each data overlap type.
 - Again, commented out 'data_clustered_reps_df'because not using cluster motif analysis. To use, move this code below cmeans clustering section below.
```{r}
#extract 15 amino acid lengths with phospho amino acid centered for motif analysis

#this study only ---------------------------
flanked_psite_regulated_noY_this_study <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  # left_join(y = master_FASTA, by = "reference") %>%
  # distinct(reference, gene_ref, overlap_my_data, mod_res, mod_residue, full_protein_sequence) %>%
  distinct(overlap_my_data, gene_ref, mod_residue, full_protein_sequence) %>%
  # filter(!is.na(full_protein_sequence)) %>% 

    # left_join((data_clustered_reps_df %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%  #add in cluster for filtering
  # filter(cluster == 4) %>% #update cluster!
  # filter(overlap_my_data == "this\nstudy" | overlap_my_data == "both") %>%
  filter(overlap_my_data == "this\nstudy") %>%
  # filter(overlap_my_data == "both") %>%
  group_by(gene_ref) %>% 
  mutate(n_sequences = n_distinct(full_protein_sequence)) %>% 
  
  distinct(gene_ref, mod_residue, full_protein_sequence) %>%
  mutate(

    aa_motif_15 = mapply(extract_centered_string_noY, long_string = full_protein_sequence, center_index = mod_residue)) %>% 
  distinct(aa_motif_15)


#both this study and databases -----------
flanked_psite_regulated_noY_both <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  # left_join(y = master_FASTA, by = "reference") %>%
  distinct(reference, gene_ref, overlap_my_data, mod_res, mod_residue, full_protein_sequence) %>% 

  # left_join((data_clustered_reps_df %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%  #add in cluster for filtering
  # filter(cluster == 4) %>% #update cluster!
  # filter(overlap_my_data == "this\nstudy" | overlap_my_data == "both") %>%
  # filter(overlap_my_data == "this\nstudy") %>%
  filter(overlap_my_data == "both") %>%
  
  distinct(gene_ref, mod_residue, full_protein_sequence) %>%
  mutate(

    aa_motif_15 = mapply(extract_centered_string_noY, long_string = full_protein_sequence, center_index = mod_residue)) %>% 
  distinct(aa_motif_15)



#databases only-----------
flanked_psite_regulated_noY_DBs <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  # left_join(y = master_FASTA, by = "reference") %>%
  distinct(gene,  gene_ref, overlap_my_data, mod_res, mod_residue) %>% 

  # left_join((data_clustered_reps_df %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%  #add in cluster for filtering
  # filter(cluster == 4) %>% #update cluster!
  # filter(overlap_my_data == "this\nstudy" | overlap_my_data == "both") %>%
  # filter(overlap_my_data == "this\nstudy") %>%
  filter(overlap_my_data == "DBs\nonly") %>%
  left_join(y = master_FASTA, by = "gene") %>% 
  filter(str_sub(full_protein_sequence, start = mod_residue, end = mod_residue) == "Y") %>%
  distinct(gene_ref, mod_residue, full_protein_sequence) %>%
  mutate(

    aa_motif_15 = mapply(extract_centered_string_noY, long_string = full_protein_sequence, center_index = mod_residue)) %>% 
  distinct(aa_motif_15)


```

2025-01-25: Fixed the inconsistencies between pY sites and motif vectors. Turns out there was multiple references per gene name and the 2 databases compared to had the many entries for back compatibility. See above. stopping about here this evening 11pm. 



#####--- ggseqlogo
simple sequence logo in units of bits which indicate site conservation.
```{r}
logo_this_study_noY <- ggplot() +
  geom_logo( flanked_psite_regulated_noY_this_study$aa_motif_15, method = "bits" ) +
  theme_logo()+ 
  theme(legend.position = 'none', axis.text.x = element_blank())+
  ggtitle("regulated pY not in EGF databases") +
  scale_y_continuous(limits = c(0, 0.7), breaks = c(0, 0.2, 0.4, 0.6), expand = c(0,0))

logo_both_noY <- ggplot() +
  geom_logo( flanked_psite_regulated_noY_both$aa_motif_15, method = "bits" ) +
  theme_logo()+ 
  theme(legend.position = 'none', axis.text.x = element_blank()) +
  ggtitle("regulated pY shared with EGF databases") +
  scale_y_continuous(limits = c(0, 0.7), breaks = c(0, 0.2, 0.4, 0.6), expand = c(0,0))

logo_DBs_only_noY <- ggplot() +
  geom_logo( flanked_psite_regulated_noY_DBs$aa_motif_15, method = "bits" ) +
  theme_logo()+ 
  theme(legend.position = 'none', axis.text.x = element_blank())+
  ggtitle("EGF databased pY sites not detected in this study") +
  scale_y_continuous(limits = c(0, 0.7), breaks = c(0, 0.2, 0.4, 0.6), expand = c(0,0))

 p <- gridExtra::grid.arrange(logo_this_study_noY, logo_both_noY, logo_DBs_only_noY)

pdf("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/bits_motif_thisstudy_vs_both_vs_DBs.pdf", width = 7, height = 8) # Open a new pdf file
gridExtra::grid.arrange(logo_this_study_noY, logo_both_noY, logo_DBs_only_noY) # Write the grid.arrange in the file
dev.off() # Close the file


ggsave("output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/bits_motif_thisstudy_vs_both_vs_DBs.png", p, width = 4, height = 12)
```
Even after fixing up the DB matching, the logos and numbers are pretty much the same. I will need to update 1-26-2025.

Closer look at individual logos to see if P at -2 is enriched in sequences captured in this study to see if the reagent is capable of grabbing Proline at -2, despite not a statistically enriched motif according to MotifAll algorithm.
```{r}
logo_this_study_noY <- ggplot() +
  geom_logo( flanked_psite_regulated_noY_this_study$aa_motif_15, method = "bits" ) +
  theme_logo()+ 
  theme(legend.position = 'none', axis.text.x = element_blank())+
  ggtitle("regulated pY not in EGF databases") +
  scale_y_continuous(limits = c(0, 0.7), breaks = c(0, 0.2, 0.4, 0.6), expand = c(0,0))
logo_this_study_noY

logo_both_noY <- ggplot() +
  geom_logo( flanked_psite_regulated_noY_both$aa_motif_15, method = "bits" ) +
  theme_logo()+ 
  theme(legend.position = 'none', axis.text.x = element_blank()) +
  ggtitle("regulated pY shared with EGF databases") +
  scale_y_continuous(limits = c(0, 0.7), breaks = c(0, 0.2, 0.4, 0.6), expand = c(0,0))
logo_both_noY


logo_DBs_only_noY <- ggplot() +
  geom_logo( flanked_psite_regulated_noY_DBs$aa_motif_15, method = "bits" ) +
  theme_logo()+ 
  theme(legend.position = 'none', axis.text.x = element_blank())+
  ggtitle("EGF databased pY sites not detected in this study") +
  scale_y_continuous(limits = c(0, 0.4), breaks = c(0, 0.2, 0.4), expand = c(0,0))
logo_DBs_only_noY

```



compare example of with and without Y in logo. 
I like without Y better for visualization.
```{r}

# ggplot() + geom_logo( flanked_psite_regulated$aa_motif_15, method = "bits" ) + theme_logo()
# 
# ggplot() + geom_logo( flanked_psite_regulated_noY$aa_motif_15, method = "bits" ) + theme_logo()
```

###motifs from PSP
Combine the outputs from the PSP motif tool into a single csv file. Input into the PSP tool were the centered motif txt files above. 
the motif enrichment tool returns a pvalue, z-score, fold change, foreground and background matches. For motifs with p-value of 0, I turned p-value 1e-15 to be just slightly lower than the lowest pvalue.
```{r}
combined_motifs <- read_csv("raw_data/MainFig3to6_SuppFig9to15/TyrPhospho/PSP_motif_analysis_tool/this_study_vs_shared_with_databases/combined_motifs.csv") %>%
  clean_names() %>%
  mutate(ratio_found = foreground_matches/ foreground_size,
         motif = str_replace_all(motif, "\\.", " . "))
#I changed the pvalues of 0e0 to 0.000000000000001 in order to have them not plot as gray since they are very significant.

#axes option 0 -------------
barplot_motifs0 <- ggplot(data = combined_motifs ) +
  geom_col(mapping = aes(x = foreground_matches, y = motif, fill = -log10(p_value))) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5),
        axis.text.y = element_text(angle = 0, hjust = 0.5)) +
  scale_fill_viridis_c(option = "C") +
  # facet_wrap(~overlap_my_data, scales = "free_y")
  facet_wrap(~overlap_my_data, scales = "fixed")

barplot_motifs0

#axes option 1 -------------
barplot_motifs1 <- ggplot(data = combined_motifs %>% mutate(motif = fct_reorder(motif, -log10(p_value)))) +
  geom_col(mapping = aes(x = foreground_matches, y = motif, fill = -log10(p_value))) +
  alexis_theme() +
  scale_fill_viridis_c(option = "C") +
  facet_wrap(~overlap_my_data, scales = "free_y")

barplot_motifs1



#different axes option 2 ----------
barplot_motifs2 <- ggplot(data = combined_motifs%>% mutate(motif = fct_reorder(motif, -log10(p_value)))) +
  geom_col(mapping = aes(x = z_score, y = motif, fill = -log10(p_value))) +
  alexis_theme() +
  scale_fill_viridis_c(option = "C") +
  facet_wrap(~overlap_my_data, scales = "free_y")

barplot_motifs2

#different axes option 3 ----------
barplot_motifs3 <- ggplot(data = combined_motifs%>% mutate(motif = fct_reorder(motif, -log10(p_value)))) +
  geom_col(mapping = aes(x = ratio_found, y = motif, fill = -log10(p_value))) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5),
        axis.text.y = element_text(angle = 0, hjust = 0.5)) +
  scale_fill_viridis_c(option = "C") +
  # facet_wrap(~overlap_my_data, scales = "free_y")
  facet_wrap(~overlap_my_data, scales = "fixed")

barplot_motifs3


#different axes option 4 ----------
barplot_motifs4 <- ggplot(data = combined_motifs %>% mutate(overlap_my_data = fct_relevel(overlap_my_data, "this study", "both", "DBs only"))) +
  geom_col(mapping = aes(x = ratio_found, y = motif, fill = -log10(p_value)), color = "black", size = 0.75) +
  alexis_theme() +
  theme(
    legend.position = "bottom",
    legend.text = element_text(size = 12, family = "sans", angle = -60, vjust = 0.8, hjust = 0),
    legend.title = element_text(size = 14, family = "sans", face = "bold"),
    axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5),
        axis.text.y = element_text(angle = 0, hjust = 0.5),
    strip.text = element_text(size = 14, family = "sans", face = "bold")) +
  scale_fill_viridis_c(option = "C", name = expression("-Log"[10]*"(p-value)")) +
  # facet_wrap(~overlap_my_data, scales = "free_y")
  facet_wrap(~overlap_my_data, scales = "fixed") +
  scale_x_continuous(expand = c(0,0), limits = c(0, 0.25), breaks = c(seq(0, 0.2, by = 0.1))) +
  geom_vline(xintercept = 0, linewidth = 0.75, color = "black") +
  xlab("ratio motif matches / all regulated pY sites")

barplot_motifs4


ggsave(filename = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/PSP_motif_analysis_tool/this_study_vs_shared_with_databases/DBs_only_pY_EGF_sites/combined_motifs_ratiofound_option4.png", plot = barplot_motifs4, width = 8, height = 7, scale = 0.8)

ggsave(filename = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/PSP_motif_analysis_tool/this_study_vs_shared_with_databases/DBs_only_pY_EGF_sites/combined_motifs_ratiofound_option4.pdf", plot = barplot_motifs4, width = 9, height = 6, scale = 0.8)
```
I need to feed in the flanked sequences again, particularly for the DB only sites which were cut down from 568 to 462.


#KSEA analysis
2025-02-04: I commented out the KSEA analysis code due to code incompatabilities that must be updated in the same fastion as motif analysis code above. The issue arose during code reorganization and fixing of the gene/protein ID matching of the database only sites. The KSEA analysis was not used in the paper and thus is lower priority.

####---function to extract padded and centered motif with asterisk
```{r}
extract_centered_string_KSEA <- function(long_string, center_index, side_length = 7) {
  # Calculate the total length of the substring to extract
  total_length <- 2 * side_length + 1
  
  # Calculate start and end indices for the substring
  start_index <- max(center_index - side_length, 1)
  end_index <- min(center_index + side_length, nchar(long_string))
  
  # Extract the substring
  extracted_string <- substr(long_string, start_index, end_index)
  
  # Calculate padding needed on left and right
  left_padding <- max(0, side_length - (center_index - 1))
  right_padding <- max(0, side_length - (nchar(long_string) - center_index))
  
  # Pad the extracted substring
  padded_string <- paste0(strrep("_", left_padding), extracted_string,  strrep("_", right_padding))
  padded_string_asterisk <- paste0(str_sub(padded_string, start = 1L, end = 8L), "*", str_sub(padded_string, start = 9L))
  return(padded_string_asterisk)
}

```


###---use mapply to mutate on the padded centered phosphosites

```{r}
#extract 15 amino acid lengths with phospho amino acid centered for motif analysis

# flanked_psite_regulated_KSEA <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
#   # mutate(mod_loc = as.numeric(str_sub(mod_residue, start = 2L))) %>% 
#   # left_join(y = ascore_gene_noImputation %>% distinct(gene, reference), by = "gene" ) %>% 
#   left_join(y = fasta_gene_names %>% rename(full_protein_sequence = sequence) %>% rename(reference = entry), by = c("reference")) %>%
#   # left_join((data_clustered_reps_df %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%  #add in cluster for filtering
#   filter(overlap_my_data == "this\nstudy" | overlap_my_data == "both") %>% 
#  
#   # filter(cluster == 4) %>% #update cluster!
#   mutate(
#     # mod_loc = as.numeric(mod_loc),
#     aa_motif_15 = mapply(extract_centered_string_KSEA, long_string = full_protein_sequence, center_index = mod_residue)) %>% 
#   distinct(aa_motif_15)
#     # aa_motif_15 = str_sub(full_protein_sequence, start= (mod_res-7), end = (mod_res +7)))



```

#####--- write_csv padded centered sites

```{r}
# #update cluster in file name according to above filter.
# write_delim(x = (flanked_psite_regulated_KSEA), file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/flanked_psite_regulated_KSEA_cluster4.txt", col_names = FALSE)
```

#KSEA FC analysis
```{r}
# #extract 15 amino acid lengths with phospho amino acid centered for motif analysis
# 
# flanked_psite_regulated_KSEA_FC <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
#   mutate(mod_loc = as.numeric(str_sub(mod_residue, start = 2L))) %>% 
#   # left_join(y = ascore_gene_noImputation %>% distinct(gene, reference), by = "gene" ) %>% 
#   left_join(y = fasta_gene_names %>% rename(full_protein_sequence = sequence) %>% rename(reference = entry), by = c("reference")) %>%
#   left_join((data_clustered_reps_df %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%  #add in cluster for filtering
#   filter(overlap_my_data == "this\nstudy" | overlap_my_data == "both") %>% 
#  
#   # filter(cluster == 4) %>% #update cluster!
#   mutate(
#     # mod_loc = as.numeric(mod_loc),
#     aa_motif_15 = mapply(extract_centered_string_KSEA, long_string = full_protein_sequence, center_index = mod_residue)) %>% 
#   distinct(aa_motif_15, diff, adj_pval)
#     # aa_motif_15 = str_sub(full_protein_sequence, start= (mod_res-7), end = (mod_res +7)))



```


#####--- write_csv padded centered sites

```{r}
# #update cluster in file name according to above filter.
# write_delim(x = flanked_psite_regulated_KSEA_FC, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/flanked_psite_regulated_KSEA_FC_allclusters.txt", delim = "\t", col_names = FALSE)
```




#-------------------------------------------------------------------

#13. REPLICATE COVERAGE

#####---psites per replicate coverage X DB annoation
for text to support Figure 4 and conjecture about use of 6 replicates rather than 3 replicates helping improve site detection.

```{r}
sig_reg_pYsites_imputedwSD <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>% 
  distinct(gene_ref)
```


```{r}
plot_sites_per_replicate_count <- ggplot(data = ascore_gene_noImputation_overlap_my_data_df %>%
                                           mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
                                           filter(gene_ref %in% sig_reg_pYsites_imputedwSD$gene_ref) %>%
                                           distinct(gene_ref, n_obs_per_condition, overlap_my_data)) +
  geom_bar(mapping = aes(x = n_obs_per_condition, fill = overlap_my_data), alpha = 0.6, color = "black", size = 0.75) + 
  facet_wrap(facets = vars(overlap_my_data)) +
  alexis_theme() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        axis.text.x = element_text(vjust = 1)) + 
  scale_fill_brewer(palette = "Dark2", name = "database\noverlap") +
  scale_x_continuous(limits = c(0.5, 6.5), breaks = c(seq(1, 6, 1))) +
  scale_y_continuous(limits = c(0, 300), breaks = c(seq(0, 300, 50)), expand = c(0,0)) +
  xlab("replicate coverage per pY site") +
  ylab("unique regulated pY sites")

plot_sites_per_replicate_count

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_sites_per_replicate_count.png", plot = plot_sites_per_replicate_count, width = 9, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_sites_per_replicate_count.pdf", plot = plot_sites_per_replicate_count, width = 9, height = 6, scale = 0.4)
```
#######----ratio psites per repcliate coverage X DB overlap
```{r}
plot_sites_per_replicate_ratio <- ggplot(data = ascore_gene_noImputation_overlap_my_data_df %>%
                                           mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
                                           filter(gene_ref %in% sig_reg_pYsites_imputedwSD$gene_ref) %>%
                                           distinct(gene_ref, n_obs_per_condition, overlap_my_data)) +
  geom_bar(mapping = aes(x = overlap_my_data, fill = fct_rev(as.factor(n_obs_per_condition))), alpha = 0.6, color = "black", size = 0.75, position = "fill") + 
  # facet_wrap(facets = vars(overlap_my_data), scales= "free_x") +
  alexis_theme() +
  theme(legend.title = element_text(size = 12, lineheight = 0.75),
        axis.text.x = element_text(vjust = 0.5, lineheight = 0.6),
        axis.title.y = element_text(hjust = 0)) + 
  scale_fill_manual(values = c( "#807DBC", "#9E9AC8", "#0570B0","#74A9CF", "grey90", "grey98" ), name = "Replicates\nper pY site") +
  # scale_fill_brewer(palette = "Purples", name = "Replicates\nper pY site") +
  scale_y_continuous(limits = c(0, 1.1), breaks = c(seq(0, 1, 0.25)), expand = c(0,0)) +
  xlab("annotation status") +
  # xlab("replicate coverage per pY site") +
  ylab("ratio of regulated pY sites")
  # ylab("ratio of EGF-regulated pY sites")

# "#FFF7FB" "#ECE7F2" "#D0D1E6" "#A6BDDB" "#74A9CF" "#3690C0" "#0570B0" "#045A8D" "#023858"
# "#FCFBFD" "#EFEDF5" "#DADAEB" "#BCBDDC" "#9E9AC8" "#807DBC" "#6A51A3" "#54278F" "#3F007D"
plot_sites_per_replicate_ratio

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_sites_per_replicate_ratio.png", plot = plot_sites_per_replicate_ratio, width = 8, height = 8, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_sites_per_replicate_ratio.pdf", plot = plot_sites_per_replicate_ratio, width = 8, height = 8, scale = 0.4)
```
 Numbers to support above plot: 
 
```{r}
replicates_per_psite_DBoverlap_df <- ascore_gene_noImputation_overlap_my_data_df %>%
                                           mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
                                           filter(gene_ref %in% sig_reg_pYsites_imputedwSD$gene_ref) %>%
                                           distinct(gene_ref, n_obs_per_condition, overlap_my_data) %>% 
  group_by(overlap_my_data) %>% 
  mutate(
    total_psites_per_overlap = n()) %>% 
  ungroup() %>% 
  group_by(overlap_my_data, n_obs_per_condition) %>% 
  mutate(
    num_psites_per_replicate_coverage_per_overlap = n() ,
    ratio_psites_per_replicate_coverage = (num_psites_per_replicate_coverage_per_overlap /  total_psites_per_overlap )) %>% 
  ungroup() %>% 
  distinct(overlap_my_data, n_obs_per_condition,total_psites_per_overlap,
           ratio_psites_per_replicate_coverage, num_psites_per_replicate_coverage_per_overlap)

replicates_per_psite_DBoverlap_df
```
 



##===============================
##===============================
##===============================


#14. IMPUTATION 
## WITHOUT STANDARD DEVIATION


###_a. define sd and mean intensities
```{r}
# # set.seed(15)
# # #get SDs for condition and global to use in imputation
mean_intensities_noSD <- ascore_gene_noImputation %>%
  filter(!is.nan((median_norm_intensity))) %>%
  filter(!is.na(median_norm_intensity)) %>%
  filter(!is.infinite(median_norm_intensity)) %>%
  # mutate(all_sd = sd(median_norm_intensity, na.rm = TRUE)) %>%
  # group_by(condition) %>%
  # mutate(condition_sd = sd(median_norm_intensity, na.rm = TRUE)) %>%
  # ungroup() %>%
  group_by(condition, gene_ref) %>%
  mutate(condition_gene_ref_mean_intensity = mean(median_norm_intensity, na.rm = TRUE)) %>%
  ungroup() %>%
  distinct(condition, gene_ref, condition_gene_ref_mean_intensity)
```

###_b. imputation and pivoting
```{r}
#imputation using normal distributions happens here:
matrix_ascore_gene_imputed_t_2_again_noSD <- ascore_gene_noImputation %>%
  pivot_wider(id_cols = c("gene_ref", "condition"),
              names_from = replicate,
              values_from =  median_norm_intensity,
              values_fill = NA) %>%
  pivot_longer(cols = c(rep1:rep6), names_to = "replicate") %>% 
  rename(median_norm_intensity = value) %>% 
  mutate(ref_condition = paste(gene_ref, condition, sep = " "),
         median_norm_intensity = case_when(is.infinite(median_norm_intensity) ~ NA,
                                           is.na(median_norm_intensity) ~ NA,
                                           TRUE ~ median_norm_intensity)) %>%
  left_join(y = mean_intensities_noSD, by = c("condition", "gene_ref" )) %>%
  group_by(condition, gene_ref) %>% 
  
  mutate(
    num_missing_obs = sum(is.na(median_norm_intensity))) %>% 
  
  ungroup() %>%
  group_by(condition, gene_ref, replicate) %>% 
  mutate(imputed_intensity = case_when(
    !is.na(median_norm_intensity) ~median_norm_intensity,
    is.na(median_norm_intensity) & num_missing_obs < 6 ~  condition_gene_ref_mean_intensity,
    is.na(median_norm_intensity) & num_missing_obs  == 6 ~ 10),
    imputed_replicate = case_when(
      is.na(median_norm_intensity) ~ "imputed",
      !is.na(median_norm_intensity) ~ "observed")) %>%  #going with bottom 5% of signal still seems too high; instead use min signal 
  ungroup() %>% 
  mutate(
      
      # 6 here is equivalent to adding in 'num_missing_obs' to choose vector size from normal distribution
      
      
      #add in column to backcalculate imputed measurements
      imputed_gt_3_reps = case_when(
        num_missing_obs > 3 ~ "imputed",
        num_missing_obs <= 3 ~ "observed at least 3 reps" ))
      #can use above dataframe to look at distributions of psite missingness by plotting histogram of num_missing observations.
  



##PIVOT WIDER TO COMPARE TRENDS ACROSS ALL TIME POINTS AND REPS
##FEEDS INTO ZSCORE AND CLUSTERING
  #separate dataframe for pivoting. 
  matrix_ascore_gene_imputed_t_3_noSD <- matrix_ascore_gene_imputed_t_2_again_noSD %>%
    ungroup() %>% 
    distinct(condition, gene_ref, replicate,  imputed_replicate, imputed_gt_3_reps, imputed_intensity) %>% 
    mutate(gene_ref = str_replace_all(gene_ref, pattern = " ", replacement = "_"),
           sample_id = paste(condition, replicate, sep = "_")) %>% 
    
  #now identify psites missing completely at one time point but measured in others.
  pivot_wider(id_cols = c("gene_ref"),
              names_from = sample_id,
              values_from = imputed_intensity,
              values_fill = NA) %>% 
    pivot_longer(cols = contains("EGF"), names_to = "sample_id") %>% 
    rename(imputed_intensity = value) %>% 
    group_by(gene_ref, sample_id) %>%  #to allow for different value sampling during imputation in next step
    mutate(imputed_intensity = case_when(
      !is.na(imputed_intensity) ~ imputed_intensity,
      is.na(imputed_intensity) ~ 10)) %>% #impute to minimum signal for conditions lacking observations at all
    ungroup() %>% 
    #chose n = 24 to account for some cases where all 4 conditions X 6 reps were not measured. sampling to size = 1 means to keep one value.
    pivot_wider(id_cols = c("gene_ref"),
              names_from = sample_id,
              values_from = imputed_intensity,
              values_fill = NA) %>% 
    #KEEP ONLY SIGNIFICANTLY CHANGING pY SITES PER DIFF ABUNDANCE WITH SD
    filter(gene_ref %in% ((regulated_pYsites_wimputation_wSD %>% distinct(gene_ref))$gene_ref))
    
              
  
  
  
  
  
  # values_fill = sample(x = rnorm(n = 6, mean = 6, sd = 2.9), size =1, replace = FALSE, prob = NULL))
              # values_fill = replace_na(sample(x = rnorm(n = 6, mean = 9, sd = 3), size =1, replace = FALSE, prob = NULL)))
  
  #likely do not need the values fill argument here because I handled sampling along a normal distribution above.
```


###_c. categorize imputations and generate annotations for heatmap
```{r}


#to join with dataframe below for completely missing datapoints
data_completeness_wider_to_rbind_noSD <- matrix_ascore_gene_imputed_t_2_again_noSD %>% 
  distinct(gene_ref, condition, replicate, median_norm_intensity, imputed_intensity, imputed_gt_3_reps, imputed_replicate) %>% 
  mutate(gene_ref = str_replace_all(gene_ref, " ", "_"),
         sample_id = paste(condition, replicate, sep = "_")) %>%
  pivot_wider(id_cols = c("gene_ref"),
              names_from = sample_id,
              values_from = imputed_intensity,
              values_fill = NA) %>% 
    pivot_longer(cols = contains("EGF"), names_to = "sample_id") %>% 
    rename(imputed_intensity = value) %>% 
  mutate(imputed_replicate = case_when(
    is.na(imputed_intensity) ~ "imputed",
    !is.na(imputed_intensity) ~ "maybe observed to discard")) %>% 
  filter(imputed_replicate == "imputed") %>% 
  
  separate(sample_id, into = c("condition", "replicate"), sep = "_") %>% 
  select(condition, replicate, gene_ref, imputed_replicate)


##CATEGORIZE IMPUTATION PER PSITE AND CONDITION
data_completeness_noSD <- matrix_ascore_gene_imputed_t_2_again_noSD %>% 
  distinct(gene_ref, condition, replicate, median_norm_intensity, imputed_intensity, imputed_gt_3_reps, imputed_replicate)


data_completeness_summary_noSD <- matrix_ascore_gene_imputed_t_2_again_noSD %>% 
  distinct(gene_ref, condition, replicate, median_norm_intensity, imputed_intensity, imputed_gt_3_reps, imputed_replicate) %>% 
  mutate(gene_ref = str_replace_all(gene_ref, " ", "_"),
         sample_id = paste(condition, replicate, sep = "_")) %>%
  distinct(gene_ref, condition, replicate, imputed_replicate) %>% 
  rbind(data_completeness_wider_to_rbind) %>% 
  group_by(gene_ref, condition, imputed_replicate) %>%
  
  summarize(n_observations = n()) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = c(gene_ref, condition), names_from = imputed_replicate, values_from = n_observations, values_fill = 0) %>% 
  mutate(percent_observed = observed / 6 * 100) 






#plots -----------------------------------------
imputed_data_analysis_intensity_noSD <- ggplot(data = data_completeness_noSD) +
  geom_boxplot(mapping = aes(x = imputed_gt_3_reps, y = imputed_intensity)) +
  alexis_theme()

imputed_data_analysis_intensity_noSD



imputed_data_analysis_count_noSD <- ggplot(data = data_completeness_noSD %>% distinct(gene_ref, condition, imputed_gt_3_reps)) +
  geom_bar(mapping = aes(x = imputed_gt_3_reps)) +
  alexis_theme()

imputed_data_analysis_count_noSD
```



###_d. pivot to matrix and z-score
```{r}
#9 is added if no p-sites were detected in all 6 replicates for a given time point for a specific psite.

colnames_for_zscore_matrix_noSD <- colnames(matrix_ascore_gene_imputed_t_3_noSD %>% select(-gene_ref))


cmeans_clustering_input_matrix_reps_noSD <- as.matrix(matrix_ascore_gene_imputed_t_3_noSD[,2:31])

rownames(cmeans_clustering_input_matrix_reps_noSD) <- as.matrix(matrix_ascore_gene_imputed_t_3_noSD[,1])

zscore_cmeans_clustering_matrix_reps_noSD <- apply(cmeans_clustering_input_matrix_reps_noSD, 1, scale) %>% t()
colnames(zscore_cmeans_clustering_matrix_reps_noSD) <- colnames_for_zscore_matrix_noSD

zscore_cmeans_clustering_matrix_reps_noSD[is.nan(zscore_cmeans_clustering_matrix_reps_noSD)] <- 0
```


##================================


#15. C-MEANS CLUSTERING




###_a. find optimal number of clusters with kmeans clustering

```{r}

# #2 clusters ------------------------------

kmm2 <- kmeans(zscore_cmeans_clustering_matrix_reps_noSD, 2, nstart = 50, iter.max = 15)

# kmm2

# Within cluster sum of squares by cluster:
# [1] 6408.170 6383.134
#  (between_SS / total_SS =  35.2 %)
# 
# 

# #3 clusters ------------------------------

kmm3 <- kmeans(zscore_cmeans_clustering_matrix_reps_noSD, 3, nstart = 50, iter.max = 15)
# kmm3
# Within cluster sum of squares by cluster:
# [1] 4426.434 3053.659 2464.965
#  (between_SS / total_SS =  49.6 %)
# 
# 
#4 clusters ------------------------------
kmm4 <- kmeans(zscore_cmeans_clustering_matrix_reps_noSD, 4, nstart = 50, iter.max = 15)
# kmm4
# Within cluster sum of squares by cluster:
# [1] 1660.076 2382.375 2806.658 1306.560
#  (between_SS / total_SS =  58.7 %)
# 
# #4 clusters is decent. Even 5 could work but 5 or 6 clusters begins showing slowing of explaning data variability.
# 
# #5 clusters ------------------------------
kmm5 <- kmeans(zscore_cmeans_clustering_matrix_reps_noSD, 5, nstart = 50, iter.max = 15)
# kmm5
# Within cluster sum of squares by cluster:
# [1] 1379.8900 1168.0353  963.0887 1587.0097 2311.5487
#  (between_SS / total_SS =  62.5 %)
# 
# #6 clusters ------------------------------
kmm6 <- kmeans(zscore_cmeans_clustering_matrix_reps_noSD, 6, nstart = 50, iter.max = 15)
# kmm6
# Within cluster sum of squares by cluster:
# [1] 1560.7995  643.2392 1766.8740  701.3740  881.0339 1298.7777
#  (between_SS / total_SS =  65.3 %)
```
I could try other methods to back up the number of clusters chosen as in this linK: https://www.r-bloggers.com/2017/02/finding-optimal-number-of-clusters/
But, 4 clusters is good for now and can do further supporting if needed later. 
I could also see how clustering looks if I require more observations per p-site, for example 6 obs instead of 3 or more observations to remove overfitting sparse data.



###_b. actual clustering function call
I ended up imputing because 0 for missing values throws off clustering immensely.

Try less fuzzification (m = 1.2 instead of 2). With more stringent filters it seems less fuzzification is beneficial.

need to set seed!! cmeans reorders clusters every time :(

```{r}
set.seed(15)
fcm_result_reps <- cmeans(zscore_cmeans_clustering_matrix_reps_noSD, centers = 4, m = 1.2)

# fcm_result <- cmeans(cmeans_clustering_input_matrix, centers = 6, m = 2)

# print(fcm_result_reps)
```



####__i. extract membership values
I want to color plot below by membership correlation and not just one color per p-site
```{r}
# Extract the cluster membership matrix
membership_values <- fcm_result_reps$membership

#show the membership values with simple print
# print(membership_values)

#optionally, convert the matrix to a dataframe for easier viewing
membership_df <- as.data.frame(membership_values)

#optionally, I can add clusters to the dataframe
membership_df$cluster <- apply(membership_values, 1, which.max) #get the cluster with highest membership

membership_df$cluster <- as.factor(membership_df$cluster) #convert to double or factor if desired

#update row and column names for dataframe
membership_df <- membership_df %>% 
  rownames_to_column(var = "ref")
colnames(membership_df) <- c("ref", "membership_cluster_1","membership_cluster_2","membership_cluster_3","membership_cluster_4", "cluster")

#pivot dataframe to have one correlation per psite
membership_df_long <- membership_df %>%
  pivot_longer(cols= c("membership_cluster_1","membership_cluster_2","membership_cluster_3","membership_cluster_4"), names_to = "potential_clusters", values_to = "membership_correlation")

#filter to keep only most correlated cluster per p-site
membership_df_long_less <- membership_df_long %>%
  mutate(potential_clusters = as.factor(str_sub(potential_clusters, start = -1L))) %>% 
  group_by(ref) %>% 
  filter(cluster == potential_clusters) %>% ungroup() %>% 
  select(-potential_clusters)

#now I can join the cluster membership correlation (membership_df_long_less) to the graph below for better coloration!
```



####__ii. format dataframe, assign clusters by max correlation, join with membership correlations, and reorder clusters
I re-ordered cluster assignments such that cluster 1 has the most member pY sites while cluster 4 has the least cluster pY sites.
```{r}
data_clustered_reps <- data.frame(zscore_cmeans_clustering_matrix_reps_noSD)
# data_clustered <- data.frame(cmeans_clustering_input_matrix)

#assign to most correlated cluster
data_clustered_reps$cluster <- as.factor(apply(fcm_result_reps$membership, 1, which.max))

data_clustered_reps$gene_ref <- rownames(data_clustered_reps)

data_clustered_reps_df <- as.data.frame(data_clustered_reps) %>%
  pivot_longer(cols = c(EGF15min_rep1:EGF3min_rep6), names_to = c("timepoint")) %>%
  separate(timepoint, into =c("condition", "replicate"), sep = "_") %>%

  mutate(minute = case_when(
    condition == "EGF15min" ~ 15,
    condition == "EGF5min" ~ 5,
    condition == "EGF3min" ~ 3,
    condition == "EGF1min" ~ 1,
    condition == "EGF0min" ~ 0)) %>%
  select(-condition) %>%
  rename(mean_condition_intensity = value) %>%
  # group_by(gene_ref) %>%
  # mutate(
  #   ref_time_0 = mean_condition_intensity[minute == 0],
  #   fold_change_time0 = mean_condition_intensity - ref_time_0) %>%
  # ungroup() %>%
  # group_by(cluster) %>%
  separate(gene_ref, into = c("gene", "psite" ), sep = "_", remove = FALSE) %>%
  rename(cluster_unordered = cluster) %>% #rename to allow reordering safely
  mutate(
    cluster = case_when(
      cluster_unordered == 1 ~ 2,
      cluster_unordered == 2 ~ 4,
      cluster_unordered == 3 ~ 3,
      cluster_unordered == 4 ~ 1))


 data_clustered_reps_df <- data_clustered_reps_df %>% 
  left_join(y = membership_df_long_less %>% rename(gene_ref = ref) %>% rename(cluster_unordered = cluster), by = c("cluster_unordered", "gene_ref")) %>% 
  mutate(membership_correlation = as.factor(membership_correlation))
```


####__iii. plot all observations per cluster, colored by membership correlation
```{r}

cluster_membership_plot1_reps <- ggplot((data_clustered_reps_df ), aes(x = minute, y = mean_condition_intensity, color = membership_correlation )) + 
  scale_color_viridis_d() +
  geom_line(size = 0.5, show.legend = FALSE) +
 alexis_theme() +
  facet_wrap(facets = vars(cluster))

cluster_membership_plot1_reps

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_reps.png", plot = cluster_membership_plot1_reps, width = 16, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_reps.pdf", plot = cluster_membership_plot1_reps, width = 16, height = 10, scale = 0.4)

#-------------------------------------------------------------------------------------------
#make just a legend to save for image.
legend <- ggplot(data = data.frame(cluster_membership = c(0.3,0.27, 0.98,1), mean_condition_intensity = c(0, 0.25, 0.5,1), minute = c("a", "b", "c", "d") )) +
  geom_line(mapping = aes(x = minute, y = mean_condition_intensity , color = cluster_membership)) +
  scale_color_viridis_c() + 
  theme(legend.ticks = element_line(linewidth = 0.25, color = "white"),
        legend.ticks.length = unit(1.5, "mm"))
        # legend.frame = element_rect(color = "black"))

legend
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_reps_legend.png", plot = legend, width = 3, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_reps_legend.pdf", plot = legend, width = 3, height = 6, scale = 0.4)
```

####__iv. plot mean intensity of clusters
used to simply show cluster trends
```{r}

#mean intensity of clusters -------------------------------------
cluster_membership_plot2 <- ggplot((data_clustered_reps_df %>%
                                     group_by(cluster, minute) %>%
                                     summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>%
                                      ungroup()), aes(x = minute, y = mean_intensity, color = count_obs )) +
  scale_color_viridis_c() +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  geom_point(size = 2, show.legend = TRUE) +
  geom_line(size = 2, show.legend = TRUE, alpha = 0.4) +
  geom_point(size = 6, alpha = 0.4, show.legend = TRUE) +
  alexis_theme() +
  scale_y_continuous(limits = c(-1, 2.5), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  facet_wrap(facets = vars(cluster))

cluster_membership_plot2

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2b.png", plot = cluster_membership_plot2, width = 16, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2b.pdf", plot = cluster_membership_plot2, width = 16, height = 10, scale = 0.4)
```
####___ . . color trends by cluster
```{r}

#mean intensity of clusters -------------------------------------
cluster_membership_plot2c <- ggplot((data_clustered_reps_df %>%
                                     group_by(cluster, minute) %>%
                                     summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>%
                                      ungroup()), aes(x = minute, y = mean_intensity, color = as.factor(cluster))) +
  scale_color_manual(values = c("#081D58","#225EA8","#41B6C4", "#C7E9B4")) +
  # scale_color_brewer(palette = "Dark2") +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_point(size = 2, show.legend = FALSE) +
  geom_line(size = 2, show.legend = FALSE, alpha = 0.4) +
  geom_point(size = 6, alpha = 0.4, show.legend = FALSE) +
  alexis_theme() +
  scale_y_continuous(limits = c(-1, 2.5), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  facet_wrap(facets = vars(cluster)) +
  theme(
    # strip.background = element_rect(fill = cluster, alpha = 0.7),
        strip.text = element_text(face = "bold", family = "sans", size = 14))

cluster_membership_plot2c

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c.png", plot = cluster_membership_plot2c, width = 16, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c.pdf", plot = cluster_membership_plot2c, width = 16, height = 10, scale = 0.4)
```


##### - - - my labeller function
```{r}
#custom labeller function
my_labeller <- function(labels) {
  # labels is a data frame with columns = facet variables
  if ("cluster" %in% names(labels)) {
    labels$cluster <- paste("Cluster", labels$cluster)
  }
  labels
}
```


####___ . . . cluster 1

```{r}

#mean intensity of clusters -------------------------------------
cluster_membership_plot2c_cluster1 <- ggplot((data_clustered_reps_df %>%
                                                group_by(cluster, minute) %>%
                                                summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>%
                                                ungroup() %>%
                                                mutate(text_position_x = 12, text_position_y = 2) %>%
                                                filter(cluster == 1)),
                                             aes(x = minute, y = mean_intensity)) +
  # scale_color_brewer(palette = "Dark2") +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_point(size = 2, show.legend = FALSE) +
  geom_line(size = 2, show.legend = FALSE, alpha = 0.8, color = "#081D58") +
  geom_point(size = 4, alpha = 1, show.legend = FALSE, color = "#081D58") +
  alexis_theme() +
  scale_y_continuous(limits = c(-1, 2.5), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  geom_text(mapping = aes(x = text_position_x, y = text_position_y, label = paste("n = ", count_obs, "\nobservations" ,sep = "")),
            size = 3, color= "black", lineheight = 0.75) +
  # geom_text(tibble(x = 12, y = -0.15, label = "L.O.D", cluster = 1), mapping = aes(x = x, y = y, label = label), 
  #           color = "gray30", inherit.aes = FALSE, size= 3) +
  facet_wrap(facets = vars(cluster), labeller = my_labeller) +
  theme(
    strip.background = element_rect(fill =adjustcolor( "#081D58", alpha.f = 0.3)),
        strip.text = element_text(face = "bold", family = "sans", size = 14)) +
  ylab("avg. scaled intensity") +
  xlab("EGF (minute)")

cluster_membership_plot2c_cluster1

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster1.png", plot = cluster_membership_plot2c_cluster1, width = 6, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster1.pdf", plot = cluster_membership_plot2c_cluster1, width = 6, height = 6, scale = 0.4)
```

####___ . . . cluster 2

```{r}


#mean intensity of clusters -------------------------------------
cluster_membership_plot2c_cluster2 <- ggplot((data_clustered_reps_df %>%
                                                group_by(cluster, minute) %>%
                                                summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>%
                                                ungroup() %>%
                                                mutate(text_position_x = 12, text_position_y = 2) %>%
                                                filter(cluster == 2)),
                                             aes(x = minute, y = mean_intensity)) +
  # scale_color_brewer(palette = "Dark2") +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_point(size = 2, show.legend = FALSE) +
  geom_line(size = 2, show.legend = FALSE, alpha = 0.8, color = "#225EA8") +
  geom_point(size = 4, alpha = 1, show.legend = FALSE, color = "#225EA8") +
  alexis_theme() +
  scale_y_continuous(limits = c(-1, 2.5), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  geom_text(mapping = aes(x = text_position_x, y = text_position_y, label = paste("n = ", count_obs, "\nobservations" ,sep = "")),
            size = 3, color= "black", lineheight = 0.75) +
  # geom_text(tibble(x = 12, y = -0.15, label = "L.O.D", cluster = 2), mapping = aes(x = x, y = y, label = label), 
  #           color = "gray30", inherit.aes = FALSE, size= 3) +
  facet_wrap(facets = vars(cluster), labeller = my_labeller) +
  theme(
    strip.background = element_rect(fill =adjustcolor( "#225EA8", alpha.f = 0.3)),
        strip.text = element_text(face = "bold", family = "sans", size = 14)) +
  ylab("avg. scaled intensity") +
  xlab("EGF (minute)")

cluster_membership_plot2c_cluster2

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster2.png", plot = cluster_membership_plot2c_cluster2, width = 6, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster2.pdf", plot = cluster_membership_plot2c_cluster2, width = 6, height = 6, scale = 0.4)
```



####___ . . . cluster 3

```{r}

#mean intensity of clusters -------------------------------------
cluster_membership_plot2c_cluster3 <- ggplot((data_clustered_reps_df %>%
                                                group_by(cluster, minute) %>%
                                                summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>%
                                                ungroup() %>%
                                                mutate(text_position_x = 12, text_position_y = 2) %>%
                                                filter(cluster == 3)),
                                             aes(x = minute, y = mean_intensity)) +
  # scale_color_brewer(palette = "Dark2") +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_point(size = 2, show.legend = FALSE) +
  geom_line(size = 2, show.legend = FALSE, alpha = 0.8, color = "#41B6C4") +
  geom_point(size = 4, alpha = 1, show.legend = FALSE, color = "#41B6C4") +
  alexis_theme() +
  scale_y_continuous(limits = c(-1, 2.5), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  geom_text(mapping = aes(x = text_position_x, y = text_position_y - 1, label = paste("n = ", count_obs, "\nobservations" ,sep = "")),
            size = 3, color= "black", lineheight = 0.75) +
  # geom_text(tibble(x = 12, y = -0.15, label = "L.O.D", cluster = 3), mapping = aes(x = x, y = y, label = label), 
  #           color = "gray30", inherit.aes = FALSE, size= 3) +
  facet_wrap(facets = vars(cluster), labeller = my_labeller) +
  theme(
    strip.background = element_rect(fill =adjustcolor( "#41B6C4", alpha.f = 0.3)),
        strip.text = element_text(face = "bold", family = "sans", size = 14)) +
  ylab("avg. scaled intensity") +
  xlab("EGF (minute)")

cluster_membership_plot2c_cluster3

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster3.png", plot = cluster_membership_plot2c_cluster3, width = 6, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster3.pdf", plot = cluster_membership_plot2c_cluster3, width = 6, height = 6, scale = 0.4)
```


####___ . . . cluster 4

```{r}

#mean intensity of clusters -------------------------------------
cluster_membership_plot2c_cluster4 <- ggplot((data_clustered_reps_df %>%
                                                group_by(cluster, minute) %>%
                                                summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>%
                                                ungroup() %>%
                                                mutate(text_position_x = 12, text_position_y = 2) %>%
                                                filter(cluster == 4)),
                                             aes(x = minute, y = mean_intensity)) +
  # scale_color_brewer(palette = "Dark2") +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_point(size = 2, show.legend = FALSE) +
  geom_line(size = 2, show.legend = FALSE, alpha = 0.8, color = "#C7E9B4") +
  geom_point(size = 4, alpha = 1, show.legend = FALSE, color = "#C7E9B4") +
  alexis_theme() +
  scale_y_continuous(limits = c(-1, 2.5), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  geom_text(mapping = aes(x = text_position_x, y = text_position_y, label = paste("n = ", count_obs, "\nobservations" ,sep = "")),
            size = 3, color= "black", lineheight = 0.75) +
  # geom_text(tibble(x = 12, y = -0.15, label = "L.O.D", cluster = 4), mapping = aes(x = x, y = y, label = label), 
  #           color = "gray30", inherit.aes = FALSE, size= 3) +
  facet_wrap(facets = vars(cluster), labeller = my_labeller) +
  theme(
    strip.background = element_rect(fill =adjustcolor( "#C7E9B4", alpha.f = 0.5)),
        strip.text = element_text(face = "bold", family = "sans", size = 14)) +
  ylab("avg. scaled intensity") +
  xlab("EGF (minute)")

cluster_membership_plot2c_cluster4

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster4.png", plot = cluster_membership_plot2c_cluster4, width = 6, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2c_cluster4.pdf", plot = cluster_membership_plot2c_cluster4, width = 6, height = 6, scale = 0.4)
```




####__v. annotate ascore_gene_noImputation with clusters
ascore_gene_clusters_Imputation_noSD df includes clusters
this adds linking cmeans clustering to other analyses such as heatmap volcano plot.
```{r}
ascore_gene_clusters_Imputation_noSD <- ascore_gene_noImputation %>% 
  left_join(y = data_clustered_reps_df %>%
              mutate(condition = case_when(
                minute == 0 ~ "EGF0min",
                minute == 1 ~ "EGF1min",
                minute == 3 ~ "EGF3min",
                minute == 5 ~ "EGF5min",
                minute == 15 ~ "EGF15min")) %>%
              select(-c( minute,  gene_ref)),
            by = c("psite", "gene",  "condition", "replicate")) #%>% 
  # mutate(median_norm_intensity = case_when(
  #                 is.infinite(median_norm_intensity) ~ 8,
  #                 TRUE ~ median_norm_intensity))
```

#####___i. key-pair to link 'reference' to ascore_gene_cluster
to link cluster annotations to dataframes using only reference + psite (aka 'ref'), I need to make a conversion key-dict.
This also serves to add underscore in gene_ref for compatibility with other dataframes.
gene conversion with psite & cluster
```{r}
conversion <- ascore_gene_clusters_Imputation_noSD %>% #all ascore > 13 completeness filtered, no differential abundance testing or imputation.
  distinct(gene_ref, ref, cluster) %>% 
  mutate(gene_ref = str_replace_all(gene_ref, pattern = " ", replacement = "_"))

```


## _c .HEATMAP ordered by clusters (mean w/o SD imputed + zscored)

###____row annotation colors
gene level
```{r}
#row annotation colors
my_colour = list(
    mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
    cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
    # EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    depth = c("0" = "green", "1" = "green4","2" =  "darkgreen","3" =  "yellow","4" =  "yellow4","5" =  "orange", "6" = "darkorange2", "7" = "darkgoldenrod" ,"8" = "darkorange4" ,"9" = "red4", "10" = "darkmagenta" ,"11" = "#891BF2","12" =  "#7918F3","13" =  "#6A15F5","14" =  "#5B12F6" ,"15" = "#4C0FF7", "16" = "#3C0CF9", "17" =  "#1E06FC"),
    overlap_my_data = c("both" = "#22A884FF", "this study" = "#D95F02"))

# depth_colors <- colorRampPalette(c("grey", "purple", "blue"))
# depth_colors(22)
```

site level should be same colors as for gene level, so comment out this assignment of colors. use above.
```{r}
# #row annotation colors
# 
# 
# my_colour = list(
#     mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
#     cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
#     # EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
#     # EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
#     # EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
#     # EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
#     # EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
#     depth = c("0" = "green", "1" = "green4","2" =  "darkgreen","3" =  "yellow","4" =  "yellow4","5" =  "orange", "6" = "darkorange2", "7" = "darkgoldenrod" ,"8" = "darkorange4" ,"9" = "red4", "10" = "darkmagenta" ,"11" = "#891BF2","12" =  "#7918F3","13" =  "#6A15F5","14" =  "#5B12F6" ,"15" = "#4C0FF7", "16" = "#3C0CF9", "17" =  "#1E06FC"),
#     overlap_my_data = c("both" = "#22A884FF", "this study" = "#D95F02"))
# 
# # depth_colors <- colorRampPalette(c("grey", "purple", "blue"))
# # depth_colors(22)
```


####___i. without data completeness summary
##### . . . gene level

```{r}
set.seed(15)


#annotation matrix
zscore_cmeans_clustering_matrix_reps_ordered_df_gene <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>% 
  left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  
  #add in EGF node depths here via left join column = depth
  # left_join(y = WP437_EGFR_node_depths %>%
  #             mutate(depth = as.character(depth)),
  #           by = c("gene")) %>% 
  
  #add in previous database annotations
  left_join(y = gene_diff_abundance_3xDB %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              mutate(overlap_my_data = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, overlap_my_data),
            by = "gene") %>%
  
  
  filter(!is.na(overlap_my_data)) %>%  #remove psites not significantly regulated
  
  # select(gene_ref, contains("min"), everything()) %>% 
  distinct(gene, gene_ref, cluster, overlap_my_data) %>% 
  arrange(-desc(cluster), overlap_my_data) 
  
  # mutate(
  #   mod_res = str_sub(psite, end = 1L)) %>% 
   #all pY and depth is hard to interpret in figure. Therefore, just overlap_my_data w/ 2 colors.
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data)



#pull out annotations from columns I want
row_annotations_gene <- zscore_cmeans_clustering_matrix_reps_ordered_df_gene %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
  distinct(gene, gene_ref, cluster, overlap_my_data) %>%
  arrange(cluster, overlap_my_data) %>% 
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data) %>%
  select( cluster, overlap_my_data) %>%    #get rid of depth and mod_res annotations
  # select( cluster, mod_res, depth) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations_gene) <- zscore_cmeans_clustering_matrix_reps_ordered_df_gene$gene_ref
row_annotations_gene <- as.data.frame(row_annotations_gene)
```


```{r}
set.seed(15)

# reorder columns
zscore_cmeans_clustering_matrix_reps_ordered_df1_gene <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  left_join((conversion %>%
               filter(!is.na(cluster)) %>% 
               distinct(gene_ref, cluster)), by = "gene_ref") %>%
  
  #pull out gene from gene_ref for joining
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  distinct() %>% 
  # #add in previous database annotations joined by gene level
  left_join(y = gene_diff_abundance_3xDB %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              mutate(overlap_my_data = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, overlap_my_data),
            by = "gene", relationship = "many-to-many") %>%

  
  filter(!is.na(overlap_my_data)) %>%  #remove psites not significantly regulated
  distinct() %>% 
  arrange(cluster, overlap_my_data) %>% 
  select(gene_ref, contains("min"), everything()) 

   


#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_cmeans_clustering_matrix_reps_ordered_matrix_gene <- as.matrix(zscore_cmeans_clustering_matrix_reps_ordered_df1_gene[,2:31])

rownames(zscore_cmeans_clustering_matrix_reps_ordered_matrix_gene) <- zscore_cmeans_clustering_matrix_reps_ordered_df1_gene[,1]
### I think there is an issue here in that row names cannot be duplicated thus they get a decimal point.


#PHEATMAP
zscore_pheatmap_gene <- pheatmap(zscore_cmeans_clustering_matrix_reps_ordered_matrix_gene ,
                            cluster_cols = F, cluster_rows = F,
                            cutree_rows = 4, cutree_cols = 5,
                            colorRampPalette(
                              c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
                            fontsize_row = 2,
                            annotation_row = row_annotations_gene,
                            annotation_colors = my_colour,
                            treeheight_row = 0) 

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_gene2.pdf", plot = zscore_pheatmap_gene , width = 20, height = 60, scale =0.8)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_gene2.png", plot = zscore_pheatmap_gene , width = 8, height = 20, scale = 0.8, limitsize = FALSE)
```
the ordering will take some work, I think the issue is with having unique row names when putting into a matrix. I think this messes with things.

##### . . . site level
```{r}
set.seed(15)


#annotation matrix
zscore_cmeans_clustering_matrix_reps_ordered_df <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>% 
  left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  
  #add in EGF node depths here via left join column = depth
  # left_join(y = WP437_EGFR_node_depths %>%
  #             mutate(depth = as.character(depth)),
  #           by = c("gene")) %>% 
  
  # #add in previous database annotations
  # left_join(y = gene_diff_abundance_3xDB %>%
  #             filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
  #             mutate(overlap_my_data = case_when(
  #               overlap_my_data == "this\nstudy" ~ "this study",
  #               overlap_my_data == "both" ~ "both", 
  #               TRUE ~ overlap_my_data)) %>% 
  #             distinct(gene, overlap_my_data),
  #           by = "gene") %>% 
  
  #add in previous database annotations
  left_join(y = (psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>% #this will keep only psites that are significantly regulated according to fold change tests using standard deviation during imputation.
              #formatting for legend
              mutate(overlap_my_data = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both", 
                TRUE ~ overlap_my_data)) %>% 
              distinct(gene, gene_ref,mod_residue, overlap_my_data)),
            by = c("gene", "gene_ref")) %>% 
  
  filter(!is.na(overlap_my_data)) %>%  #remove psites not significantly regulated
  
  select(gene_ref, contains("min"), everything()) %>% 
  arrange(-desc(cluster), overlap_my_data) %>% 
  
  mutate(
    mod_res = str_sub(psite, end = 1L)) %>% 
  distinct(gene_ref, cluster, overlap_my_data) #all pY and depth is hard to interpret in figure. Therefore, just overlap_my_data w/ 2 colors.
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data)



#pull out annotations from columns I want
row_annotations <- zscore_cmeans_clustering_matrix_reps_ordered_df %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
  distinct(gene_ref, cluster, overlap_my_data) %>%
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data) %>%
  select( cluster, overlap_my_data) %>%    #get rid of depth and mod_res annotations
  # select( cluster, mod_res, depth) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations) <- zscore_cmeans_clustering_matrix_reps_ordered_df$gene_ref
row_annotations <- as.data.frame(row_annotations)



#write to csv for shiny
write.csv(x = row_annotations, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/heatmap_row_annotations.csv")
```


```{r}
set.seed(15)

# reorder columns
zscore_cmeans_clustering_matrix_reps_ordered_df1 <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%
  
  #pull out gene from gene_ref for joining
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  
  # #add in previous database annotations joined by gene level
  # left_join(y = gene_diff_abundance_gene_3xDB_imputed %>%
  # # left_join(y = gene_diff_abundance_3xDB %>%
  #             filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
  #             mutate(overlap_my_data = case_when(
  #               overlap_my_data == "this\nstudy" ~ "this study",
  #               overlap_my_data == "both" ~ "both", 
  #               TRUE ~ overlap_my_data)) %>% 
  #             distinct(gene, overlap_my_data),
  #           by = "gene") %>% 

  
  #add in previous database annotations
  left_join(y = psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>% 
              #also keeps only sig chg sites w/ Imputation using SD
              
              mutate(overlap_my_data = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both", 
                TRUE ~ overlap_my_data)) %>% 
              
              distinct(gene, gene_ref,mod_residue, overlap_my_data),
            by = c("gene", "gene_ref")) %>% 
  
  filter(!is.na(overlap_my_data)) %>%  #remove psites not significantly regulated
  
  select(gene_ref, contains("min"), everything()) %>%
  
  arrange(-desc(cluster), overlap_my_data) 


#write csv for shiny--------------------------------------------------------------
write_csv(x = zscore_cmeans_clustering_matrix_reps_ordered_df1, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/SHINY_heatmap_df.csv")
#---------------------------------------------------------------------------------

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_cmeans_clustering_matrix_reps_ordered_matrix <- as.matrix(zscore_cmeans_clustering_matrix_reps_ordered_df1[,2:31])

rownames(zscore_cmeans_clustering_matrix_reps_ordered_matrix) <- zscore_cmeans_clustering_matrix_reps_ordered_df1[,1]

#save for shiny
write.csv(zscore_cmeans_clustering_matrix_reps_ordered_matrix, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/SHINY_zscore_cmeans_clustering_matrix_reps_ordered_matrix.csv")


#PHEATMAP
zscore_pheatmap <- pheatmap(zscore_cmeans_clustering_matrix_reps_ordered_matrix ,
                            cluster_cols = F, cluster_rows = F,
                            cutree_rows = 4, cutree_cols = 5,
                            colorRampPalette(
                              c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
                            fontsize_row = 2,
                            annotation_row = row_annotations,
                            annotation_colors = my_colour,
                            treeheight_row = 0) 

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_psite.pdf", plot = zscore_pheatmap , width = 8, height = 20, scale =0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_psite.png", plot = zscore_pheatmap , width = 8, height = 20, scale = 0.8, limitsize = FALSE)
```
#######------distribution of pY sites per DB overlap in heatmap
```{r}
df_percent_cluster_membership_vs_DBoverlaps <- zscore_cmeans_clustering_matrix_reps_ordered_df %>%
                                distinct(gene_ref, cluster, overlap_my_data) %>% 
                                group_by(cluster) %>% 
                                mutate(
                                  total_pY_sites_per_cluster = n()) %>% 
                                  # total_genes_per_cluster = n_distinct(gene_ref)) %>% 
                                ungroup() %>% 
                                group_by(cluster, overlap_my_data) %>% 
                                mutate(
                                  n_pYsites_per_annotation_type = n(), 
                                  percent_pYsites_per_cluster = n_pYsites_per_annotation_type / total_pY_sites_per_cluster * 100) %>% 
                                  ungroup() %>% 
                                distinct(overlap_my_data, cluster, n_pYsites_per_annotation_type, percent_pYsites_per_cluster,
                                         total_pY_sites_per_cluster) %>%
                                  group_by(cluster) %>%  
                                  mutate(text_position_x = case_when(
                                    overlap_my_data == "both" ~ (cluster- 0.23),
                                    overlap_my_data == "this study" ~ (cluster + 0.23))) %>% 
                                  ungroup()
```

--just counts
```{r}
# plot_cluster_membership_pYsites_counts <- ggplot(data = df_percent_cluster_membership_vs_DBoverlaps) +
#   geom_col(mapping = aes(x= cluster, y = n_pY_sites_per_annotation_type, fill = overlap_my_data), show.legend = TRUE, position = "dodge", alpha = 0.8 , color = "black") +
#   alexis_theme() +
#   guides(fill=guide_legend(title="pY site annotation type")) +
#   scale_fill_brewer(palette = "Dark2")+
#   # scale_fill_manual(values =c( "lightblue", "darkblue")) +
#   ylab("unique pY sites")


```



this is the plot I want for matching to site level join of PSP/PTMSigDB sites for heatmap.
```{r}

plot_cluster_membership_vs_DBoverlaps <- ggplot(data =  df_percent_cluster_membership_vs_DBoverlaps)+
  geom_col(mapping = aes(x = as.factor(cluster), y = n_pYsites_per_annotation_type,fill = overlap_my_data), show.legend = TRUE, position = "dodge", alpha = 0.8, color = "black") +
  alexis_theme() +
  guides(fill=guide_legend(title="pY site\nannotation")) +
  theme(legend.title = element_text(hjust = 1, size = 12, family = "sans"),
        legend.position = "top",
        legend.text = element_text(size = 14)) +
  scale_fill_brewer(palette = "Dark2")+
  geom_text (mapping = aes(x = text_position_x, y = n_pYsites_per_annotation_type - 8, label = n_pYsites_per_annotation_type), show.legend = FALSE, size = 4) +
  # geom_text(data = tibble(x = c(1, 2, 3, 4), y = c(95, 95, 95, 95), label = c("cluster 1", "cluster 2", "cluster 3", "cluster 4")), mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, face = "bold", family = "sans") +
   geom_text (mapping = aes(x = cluster, y = 275, label = paste("cluster ", cluster ,"\nn = ", total_pY_sites_per_cluster,"\npY sites", sep = "")), show.legend = FALSE, size =3.75, lineheight = 0.75) +
  # scale_fill_manual(values =c( "lightblue", "darkblue")) +
  ylab("unique pY sites") +
  xlab("cluster") +
  scale_y_continuous(expand = c(0,0), limits = c(0, 300), breaks= c(seq(0, 250, 50))) 
  # scale_y_continuous(expand = c(0,0.1), limits = c(0, 225))


plot_cluster_membership_vs_DBoverlaps

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cluster_membership_vs_DBoverlaps.png", 
       plot = plot_cluster_membership_vs_DBoverlaps, width = 10, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cluster_membership_vs_DBoverlaps.pdf", plot = plot_cluster_membership_vs_DBoverlaps, width = 10, height = 10, scale = 0.4)
```

--percentages
_(PUB, Figure S8)_
```{r}



plot_percent_cluster_membership_vs_DBoverlaps <- ggplot(data =  df_percent_cluster_membership_vs_DBoverlaps)+
  geom_col(mapping = aes(x = as.factor(cluster), y = percent_pYsites_per_cluster, fill = overlap_my_data), show.legend = TRUE, position = "dodge", alpha = 0.8, color = "black") +
  geom_text (mapping = aes(x = text_position_x, y = percent_pYsites_per_cluster - 5, label = paste(round(percent_pYsites_per_cluster), "%", sep = "")), show.legend = FALSE, size = 3.7) +
  # geom_text(data = tibble(x = c(1, 2, 3, 4), y = c(95, 95, 95, 95), label = c("cluster 1", "cluster 2", "cluster 3", "cluster 4")), mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, face = "bold", family = "sans") +
   geom_text (mapping = aes(x = cluster, y = 98, label = paste("cluster ", cluster ,"\nn = ", total_pY_sites_per_cluster,"\npY sites", sep = "")), show.legend = FALSE, size =4, lineheight = 0.75) +
  # geom_text (mapping = aes(x = cluster, y = 78, label = paste("\nn = ", total_genes_per_cluster,"\ngenes", sep = "")), show.legend = FALSE, size =4, lineheight = 0.75) +
  alexis_theme() +
  guides(fill=guide_legend(title="pY site\nannotation")) +
  theme(legend.title = element_text(hjust = 0.5, size = 12, family = "sans")) +
  scale_fill_brewer(palette = "Dark2") +
  # scale_fill_manual(values =c( "lightblue", "darkblue")) +
  # scale_color_manual(values =c( "black", "black")) +
  ylab("percent pY sites per cluster") +
  xlab("cluster") +
  
  scale_y_continuous(expand = c(0,0), limits = c(0, 110), breaks= c(seq(0, 100, 25))) 


plot_percent_cluster_membership_vs_DBoverlaps

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_percent_cluster_membership_vs_DBoverlaps.png", 
       plot = plot_percent_cluster_membership_vs_DBoverlaps, width = 12, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_percent_cluster_membership_vs_DBoverlaps.pdf", plot = plot_percent_cluster_membership_vs_DBoverlaps, width = 12, height = 12, scale = 0.4)

```


####___ii. with completeness coloring
ordered rows by cmeans fuzzy clusters and columns by time series. - not euclidean clusters.
cmeans fuzzy clusters actually look better than euclidean or any of the other kmeans cluster algorithms within pheatmap (euclidean, manhattan, minkowski, binary...)
```{r}
set.seed(15)
# 
# #vector of psites only observed 3 or more times across all 30 measurments
# well_observed_psites <- (psites_obs_gt_3 %>%
#   distinct(gene_ref, well_observed) %>%
#   filter(well_observed == TRUE))$gene_ref

#annotation matrix
zscore_cmeans_clustering_matrix_reps_ordered_df2 <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>% 
  left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  mutate(membership_correlation = as.factor(str_sub(membership_correlation, end = 4L)))%>% #reduce decimals
  
  #add in EGF node depths here via left join column = depth
  left_join(y = WP437_EGFR_node_depths %>% mutate(depth = as.character(depth)), by = c("gene")) %>% 
  
  # #add in previous database annotations
  # left_join(y = gene_diff_abundance_4xDB %>%
  #             filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
  #             mutate(overlap_my_data = case_when(
  #               overlap_my_data == "this\nstudy" ~ "this study",
  #               overlap_my_data == "both" ~ "both", 
  #               is.na(overlap_my_data) ~ "n.s.",
  #               TRUE ~ overlap_my_data)) %>% 
  #             distinct(gene, overlap_my_data),
  #           by = "gene") %>% 
#add in previous database annotations
  left_join(y = gene_diff_abundance_3xDB %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              mutate(overlap_my_data = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, overlap_my_data),
            by = "gene") %>%
  
  arrange(-desc(cluster), overlap_my_data) %>%
  
  mutate(
    mod_res = str_sub(psite, end = 1L)) %>% 
  distinct(gene_ref, cluster, membership_correlation,
           # mod_res, depth, #remove these, all pY and depth is too difficult to parse visually.
           overlap_my_data)

#pull out annotations from columns I want
row_annotations2 <- zscore_cmeans_clustering_matrix_reps_ordered_df2 %>%
  left_join(y = data_completeness_summary %>%
              pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
              distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min) %>% 
              ungroup() %>% 
              group_by(gene_ref) %>% 
              mutate(sum_obs = as.character(sum(EGF0min, EGF1min, EGF3min, EGF5min, EGF15min))) %>% 
              ungroup(),
            by = "gene_ref") %>% 
  distinct(gene_ref, cluster, overlap_my_data, membership_correlation,
           # mod_res, depth,
           EGF0min, EGF1min, EGF3min, EGF5min, EGF15min, sum_obs) %>% 
  # filter(gene_ref %in% well_observed_psites) %>% 
  select( cluster, overlap_my_data, membership_correlation,
          # mod_res, depth,
          EGF15min, EGF5min, EGF3min, EGF1min, EGF0min, sum_obs) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations2) <- zscore_cmeans_clustering_matrix_reps_ordered_df2$gene_ref
row_annotations2 <- as.data.frame(row_annotations2) %>% 
  mutate(membership_correlation = as.numeric(membership_correlation))

#row annotation colors
my_colour2 = list(
    mod_res = c("S" = "#440154FF", "T" = "#22A884FF", "Y" = "#FDE725FF"),
    cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
    EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    depth = c("0" = "green", "1" = "green4","2" =  "darkgreen","3" =  "yellow","4" =  "yellow4","5" =  "orange", "6" = "darkorange2", "7" = "darkgoldenrod" ,"8" = "darkorange4" ,"9" = "red4", "10" = "darkmagenta" ,"11" = "#891BF2","12" =  "#7918F3","13" =  "#6A15F5","14" =  "#5B12F6" ,"15" = "#4C0FF7", "16" = "#3C0CF9", "17" =  "#1E06FC"),
    overlap_my_data = c("both" = "#22A884FF", "this study" = "#D95F02", "n.s." = "white"),  #based on imputed data if in study.
    sum_obs = c("0" = "grey100", "1" = "grey98", "2" = "grey95", "3" = "grey90", "4" = "grey85","5" = "grey80","6" = "grey75","7" = "grey70","8" = "grey65","9" = "grey64","10"= "grey63","11" = "grey62","12" = "grey61","13" = "grey60","14" = "grey59","15" = "grey58","16" = "grey57","17" = "grey56","18" = "grey55","19" = "grey50","20" = "grey45","21" = "grey40","22" = "grey35","23" = "grey30","24" = "grey25","25" = "grey20","26" = "grey15","27" = "grey10","28" = "grey9","29" = "grey8","30" = "grey7"),
    
    membership_correlation = c("0.35 "= "#FF0000","0.36 "= "#FF0707","0.37 "= "#FF0F0F","0.38 "= "#FF1717","0.39 "= "#FF1F1F","0.4 "= "#FF2727","0.41 "= "#FF2F2F","0.42 "= "#FF3737","0.43 "= "#FF3F3F","0.44 "= "#FF4747","0.45 "= "#FF4F4F","0.46 "= "#FF5757","0.47 "= "#FF5F5F","0.48 "= "#FF6767","0.49 "= "#FF6F6F","0.5 "= "#FF7777","0.51 "= "#FF7F7F","0.52 "= "#FF8787","0.53 "= "#FF8F8F","0.54 "= "#FF9797","0.55 "= "#FF9F9F","0.56 "= "#FFA7A7","0.57 "= "#FFAFAF","0.58 "= "#FFB7B7","0.59 "= "#FFBFBF","0.6 "= "#FFC7C7","0.61 "= "#FFCFCF","0.62 "= "#FFD7D7","0.63 "= "#FFDFDF","0.64 "= "#FFE7E7","0.65 "= "#FFEFEF","0.66 "= "#FFF7F7","0.67 "= "#FFFFFF","0.68 "= "#F7FAF7","0.69 "= "#EFF5EF","0.7 "= "#E7F0E7","0.71 "= "#DFEBDF","0.72 "= "#D7E6D7","0.73 "= "#CFE1CF","0.74 "= "#C7DDC7","0.75 "= "#BFD8BF","0.76 "= "#B7D3B7","0.77 "= "#AFCEAF","0.78 "= "#A7C9A7","0.79 "= "#9FC49F","0.8 "= "#97C097","0.81 "= "#8FBB8F","0.82 "= "#87B687","0.83 "= "#7FB17F","0.84 "= "#77AC77","0.85 "= "#6FA76F","0.86 "= "#67A267","0.87 "= "#5F9E5F","0.88 "= "#579957","0.89 "= "#4F944F","0.9 "= "#478F47","0.91 "= "#3F8A3F","0.92 "= "#378537","0.93 "= "#2F812F","0.94 "= "#277C27","0.95 "= "#1F771F","0.96 "= "#177217","0.97 "= "#0F6D0F","0.98 "= "#076807","0.99 "= "#006400"))
    
    
    # membership_correlation = c("0.35 "= "#FFFFFF","0.36 "= "#FBFCFB","0.37 "= "#F7FAF7","0.38 "= "#F3F7F3","0.39 "= "#EFF5EF","0.4 "= "#EBF2EB","0.41 "= "#E7F0E7","0.42 "= "#E3EEE3","0.43 "= "#DFEBDF","0.44 "= "#DBE9DB","0.45 "= "#D7E6D7","0.46 "= "#D3E4D3","0.47 "= "#CFE1CF","0.48 "= "#CBDFCB","0.49 "= "#C7DDC7","0.5 "= "#C3DAC3","0.51 "= "#BFD8BF","0.52 "= "#BBD5BB","0.53 "= "#B7D3B7","0.54 "= "#B3D0B3","0.55 "= "#AFCEAF","0.56 "= "#ABCCAB","0.57 "= "#A7C9A7","0.58 "= "#A3C7A3","0.59 "= "#9FC49F","0.6 "= "#9BC29B","0.61 "= "#97C097","0.62 "= "#93BD93","0.63 "= "#8FBB8F","0.64 "= "#8BB88B","0.65 "= "#87B687","0.66 "= "#83B383","0.67 "= "#7FB17F","0.68 "= "#7BAF7B","0.69 "= "#77AC77","0.7 "= "#73AA73","0.71 "= "#6FA76F","0.72 "= "#6BA56B","0.73 "= "#67A267","0.74 "= "#63A063","0.75 "= "#5F9E5F","0.76 "= "#5B9B5B","0.77 "= "#579957","0.78 "= "#539653","0.79 "= "#4F944F","0.8 "= "#4B924B","0.81 "= "#478F47","0.82 "= "#438D43","0.83 "= "#3F8A3F","0.84 "= "#3B883B","0.85 "= "#378537","0.86 "= "#338333","0.87 "= "#2F812F","0.88 "= "#2B7E2B","0.89 "= "#277C27","0.9 "= "#237923","0.91 "= "#1F771F","0.92 "= "#1B741B","0.93 "= "#177217","0.94 "= "#137013","0.95 "= "#0F6D0F","0.96 "= "#0B6B0B","0.97 "= "#076807","0.98 "= "#036603","0.99 "= "#006400"))
    
    # membership_correlation = c("0.35 "= "#BEBEBE","0.36 "= "#BDBFBD","0.37 "= "#BDC1BD","0.38 "= "#BDC2BD","0.39 "= "#BCC4BC","0.4 "= "#BCC5BC","0.41 "= "#BCC7BC","0.42 "= "#BBC8BB","0.43 "= "#BBCABB","0.44 "= "#BBCBBB","0.45 "= "#BACDBA","0.46 "= "#BACEBA","0.47 "= "#BAD0BA","0.48 "= "#B9D1B9","0.49 "= "#B9D3B9","0.5 "= "#B9D4B9","0.51 "= "#B9D6B9","0.52 "= "#B8D7B8","0.53 "= "#B8D9B8","0.54 "= "#B8DAB8","0.55 "= "#B7DCB7","0.56 "= "#B7DDB7","0.57 "= "#B7DFB7","0.58 "= "#B6E0B6","0.59 "= "#B6E2B6","0.6 "= "#B6E3B6","0.61 "= "#B5E5B5","0.62 "= "#B5E6B5","0.63 "= "#B5E8B5","0.64 "= "#B4E9B4","0.65 "= "#B4EBB4","0.66 "= "#B4ECB4","0.67 "= "#B4EEB4","0.68 "= "#B6EEB3","0.69 "= "#B8EFB2","0.7 "= "#BBEFB1","0.71 "= "#BDF0B0","0.72 "= "#BFF0AF","0.73 "= "#C2F1AE","0.74 "= "#C4F1AE","0.75 "= "#C6F2AD","0.76 "= "#C9F2AC","0.77 "= "#CBF3AB","0.78 "= "#CDF3AA","0.79 "= "#D0F4A9","0.8 "= "#D2F4A9","0.81 "= "#D4F5A8","0.82 "= "#D7F5A7","0.83 "= "#D9F6A6","0.84 "= "#DBF7A5","0.85 "= "#DEF7A4","0.86 "= "#E0F8A3","0.87 "= "#E2F8A3","0.88 "= "#E5F9A2","0.89 "= "#E7F9A1","0.9 "= "#E9FAA0","0.91 "= "#ECFA9F","0.92 "= "#EEFB9E","0.93 "= "#F0FB9E","0.94 "= "#F3FC9D","0.95 "= "#F5FC9C","0.96 "= "#F7FD9B","0.97 "= "#FAFD9A","0.98 "= "#FCFE99","0.99 "= "#FFFF99"))
    
    
#     membership_correlation =  c("0.35 "= "#BEBEBE",
# "0.36 "= "#BDB9BF","0.37 "= "#BCB4C1","0.38 "= "#BBAFC2","0.39 "= "#BAAAC4","0.40 "= "#B9A5C5","0.41 "= "#B8A0C7","0.42 "= "#B79BC8","0.43 "= "#B696CA","0.44 "= "#B591CC","0.45 "= "#B48CCD","0.46 "= "#B387CF","0.47 "= "#B282D0","0.48 "= "#B17DD2","0.49 "= "#B078D3","0.50 "="#AF73D5","0.51 "= "#AF6FD7","0.52 "= "#AE6AD8","0.53 "= "#AD65DA","0.54 "= "#AC60DB","0.55 "= "#AB5BDD","0.56 "= "#AA56DE","0.57 "="#A951E0","0.58 "= "#A84CE1","0.59 "= "#A747E3","0.60 "= "#A642E5","0.61 "= "#A53DE6","0.62 "= "#A438E8","0.63 "= "#A333E9","0.64 "="#A22EEB","0.65 "= "#A129EC","0.66 "= "#A024EE","0.67 "= "#A020F0","0.68 "= "#9B1FF0","0.69 "= "#961EF0","0.70 "= "#911DF1","0.71 "="#8C1CF1","0.72 "= "#871BF2","0.73 "= "#821AF2","0.74 "= "#7D19F3","0.75 "= "#7818F3","0.76 "= "#7317F4","0.77 "= "#6E16F4","0.78 "="#6915F5","0.79 "= "#6414F5","0.80 "= "#5F13F6","0.81 "= "#5912F6","0.82 "= "#5511F7","0.83 "= "#5010F7","0.84 "= "#4B0FF7","0.85 "="#460EF8","0.86 "= "#410DF8","0.87 "= "#3C0CF9","0.88 "= "#370BF9","0.89 "= "#310AFA","0.90 "= "#2C09FA","0.91 "= "#2808FB","0.92 "="#2307FB","0.93 "= "#1E06FC","0.94 "= "#1805FC","0.95 "= "#1304FD","0.96 "= "#0F03FD","0.97 "= "#0902FE","0.98 "= "#0501FE","0.99 "="#0000FF"))


# reorder columns
zscore_cmeans_clustering_matrix_reps_ordered_df12 <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>%

  left_join(y = (data_completeness_summary %>%
              pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
              distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min) %>% 
              ungroup() %>% 
              group_by(gene_ref) %>% 
              mutate(sum_obs = sum(EGF0min, EGF1min, EGF3min, EGF5min, EGF15min)) %>% 
              ungroup() %>% 
              distinct(gene_ref, sum_obs)),
            by = "gene_ref") %>%
  #also organize by overlap_my_data. To do so, need to add in the overlap annotations. must pull out gene from gene_ref first
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>% 
  
  left_join(y = psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              #formatting how the legend looks
              mutate(overlap_my_data = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                overlap_my_data == "n.s." ~ "n.s.",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, gene_ref,mod_residue, overlap_my_data),
            by = c("gene", "gene_ref")) %>%
  
  
  #add in previous database annotations joined by gene level
  # left_join(y = gene_diff_abundance_gene_2xDB_imputed %>%
  # left_join(y = gene_diff_abundance_3xDB %>%
  #             filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
  #             mutate(overlap_my_data = case_when(
  #               overlap_my_data == "this\nstudy" ~ "this study",
  #               overlap_my_data == "both" ~ "both",
  #               TRUE ~ overlap_my_data)) %>%
  #             distinct(gene, overlap_my_data),
  #           by = "gene") %>%
  left_join(y = data_clustered_reps_df %>% select(gene_ref, membership_correlation), by = "gene_ref") %>%
  mutate(membership_correlation = as.character(str_sub(membership_correlation, end = 4L)))%>% #reduce decimals
  
  
  select(gene_ref, contains("min"), everything()) %>% 
  arrange(-desc(cluster), overlap_my_data, desc(sum_obs)) %>% 
  mutate(sum_obs = as.character(sum_obs))

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_cmeans_clustering_matrix_reps_ordered_matrix2 <- as.matrix(zscore_cmeans_clustering_matrix_reps_ordered_df12[,2:31])

rownames(zscore_cmeans_clustering_matrix_reps_ordered_matrix2) <- zscore_cmeans_clustering_matrix_reps_ordered_df12[,1]



zscore_pheatmap2 <- pheatmap(zscore_cmeans_clustering_matrix_reps_ordered_matrix2 ,legend_labels = "z-score", cluster_cols = F, cluster_rows = F,
         cutree_rows = 4, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         # clustering_distance_rows = "euclidean",
         
         fontsize_row = 2, annotation_row = row_annotations2, annotation_colors = my_colour2,
         treeheight_row = 0)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_withcompleteness.pdf", plot = zscore_pheatmap2 , width = 20, height = 60, scale =0.8)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_withcompletenesslegend.pdf", plot = zscore_pheatmap2 , width = 8, height = 20, scale =0.8)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_withcompleteness.png", plot = zscore_pheatmap2 , width = 10, height = 20, scale = 0.8, limitsize = FALSE)
```
Okay, so with less observations, I needed to decrease the fuzzification parameter.


write_csv
```{r}
write_csv(x = zscore_cmeans_clustering_matrix_reps_ordered_df2, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_cmeans_clustering_matrix_reps_ordered_df2.csv")
```



membership correlation coloring
```{r}

# # membership_colors <- colorRampPalette(c("white","lightyellow", "cornsilk2" ,"thistle2",  "plum", "orchid", "darkorchid", "purple", "slateblue", "royalblue", "mediumblue",  "darkblue"))
# 
# # membership_colors <- colorRampPalette(c("darkblue", "royalblue", "slateblue", "purple", "orchid", "plum", "thistle",
# #                                         "darkseagreen", "darkseagreen2",  "yellowgreen","greenyellow", "#CCFF66", "#FFFF99", "yellow"))
# 
# membership_colors <- colorRampPalette(c("red", "white", "darkgreen"))
# membership_color_vector<- membership_colors(65)
# membership_color_vector
# #___________________________
# 
# membership_correlation_colors <- row_annotations2 %>%
#   distinct(membership_correlation) %>% 
#   mutate(membership_correlation_numeric = as.numeric(membership_correlation)) %>% 
#   arrange(membership_correlation_numeric) %>% 
#   mutate(membership_correlation = paste0("\"",membership_correlation, " \"= " )) %>% 
#   select(-membership_correlation_numeric)
# membership_correlation_colors$color <- paste0("\"", membership_color_vector, "\"")
# 
# vector_membership_annotation_colors <- membership_correlation_colors %>% 
#   mutate(color_to_corr = str_c(membership_correlation, color, sep = "")) %>% 
#   select(color_to_corr)
# rownames(vector_membership_annotation_colors) <- NULL
# 
# vector_membership_annotation_colors <- vector_membership_annotation_colors %>%
#   mutate(color_vec =  str_flatten(color_to_corr, collapse = ","))


```

##_d. PLOT INDIVIDUAL pY SITES PER CLUSTER
actual measured psites boxplots w points, saved per cluster

I think I might want to filter for n_obs > 3 for this clustering of profiles because some profiles may seem defined by the sparsity of data.

I think I need to normalize the intensities prior to clustering because I am also getting clusters based on relative intensities it seems.



###__i. function to iterate through my data
```{r}
# boxplot_gene_psite_function <- function(vector_gene_refs, dataframe, output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/", condition = condition, sample_id = sample_id, strip_color = "gray80", strip_text_color = "black"){
# 
#   #create output directory if it doesn't exist already
#   if (!dir.exists(output_dir)){
#     dir.create(output_dir)}
#   
#   for (gene_var in vector_gene_refs) {
#     if(gene_var %in% dataframe$gene_ref) {
#       
#       #create boxplot for any sites in each gene
#       p <- ggplot() + 
#         geom_boxplot(data = dataframe %>% filter(gene_ref == gene_var),
#                mapping = aes(x = condition, y = median_norm_intensity), show.legend = FALSE, alpha = 0.3, outlier.color = NA, width = 0.5) +
#         geom_point(data = dataframe %>% filter(gene_ref == gene_var),
#                    mapping = aes(x = condition, y = median_norm_intensity),
#                    fill = "grey",
#                    mod_residue = position_jitter( width = 0.15, height = 0), shape = 21, alpha = 0.5, size = 1.5, show.legend = FALSE) +
#         geom_text(data = dataframe %>%
#         filter(gene_ref == gene_var) %>%
#           mutate(max_intensity_condition = max(median_norm_intensity)) %>% 
#         distinct(condition, gene_ref, n_obs,max_intensity_condition),
#         aes(x = condition, y = max_intensity_condition + 1, label = n_obs),size = 4, show.legend = FALSE, fontface = "bold") +
#         alexis_theme() +
#         
#         facet_wrap(facets = vars(gene_ref), nrow = 4) +
#         scale_y_continuous(name = expression("Log" [2]* "(intensity)"), expand = c(0.05,0.2))  +
#         scale_x_discrete(
#           "EGF treatment duration\n(minutes)",
#           drop = FALSE,
#           # limits = c("untreated", "1 min", "3 min", "5 min", "15 min"),
#           labels = c("0", "1", "3", "5", "15")) +
#         # theme(axis.text.x = element_text(angle = -90, hjust = 0.5, vjust = 0.5)) +
#         theme(
#           
#           strip.background = element_rect(fill = adjustcolor( strip_color, alpha.f = 0.3)),
#           strip.text = element_text(size = 16, face = "bold", family = "sans", color = strip_text_color)) #+
#         # expand_limits(y = c(15, 35)) 
#       
#       # save the plot as PNG & PDF
#       ggsave(filename = file.path(output_dir, paste0(gene_var, "_boxplot_points1.png")), plot = p, width = 8, height = 8, scale = 0.4)
#       ggsave(filename = file.path(output_dir, paste0(gene_var, "_boxplot_points1.pdf")), plot = p, width = 8, height = 8, scale = 0.4)
#       
#     } else { 
#       message (paste("Gene", gene_var, "not found in the dataframe."))
#       
#       }
#     }
# }

```

##### ====== write for shiny boxplots ====== 
```{r}
# Write for shiny boxplots covering only regulated pY sites

write_csv(ascore_gene_clusters_Imputation_noSD, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/SHINY_boxplot_input_dataframe.csv")
```

###__ii. run function to plot many PNGs
####___i.  cluster 1
```{r}

# boxplot_gene_psite_function( vector_gene_refs = (ascore_gene_clusters_Imputation_noSD %>% filter(cluster ==1) %>% distinct(gene_ref))$gene_ref,
#                              strip_text_color = "black",
#                              dataframe = ascore_gene_clusters_Imputation_noSD %>%
#                                distinct(gene, gene_ref, condition, replicate, sample_id, median_norm_intensity, cluster, n_obs) %>% mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")), output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster1/", strip_color = "#081D58")


```
facet_colors_cluster <- c("1" = "#1B9E77", "2" = "#D95F02", "3" = "#7570B3", "4" = "#E7298A") 
####___ii. cluster 2

```{r}
# boxplot_gene_psite_function( vector_gene_refs = (ascore_gene_clusters_Imputation_noSD %>% filter(cluster ==2) %>% distinct(gene_ref))$gene_ref, strip_text_color = "black",
#                              dataframe = ascore_gene_clusters_Imputation_noSD  %>% distinct(condition,replicate, sample_id,gene,  gene_ref, median_norm_intensity, cluster, n_obs)%>% mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")), output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster2/", strip_color = "#225EA8")

```


####___iii. cluster 3

```{r}
# boxplot_gene_psite_function( vector_gene_refs = (ascore_gene_clusters_Imputation_noSD %>% filter(cluster ==3) %>% distinct(gene_ref))$gene_ref,strip_text_color = "black",
#                              dataframe = ascore_gene_clusters_Imputation_noSD %>%  distinct(condition, sample_id,gene,  gene_ref, median_norm_intensity, cluster, n_obs)%>% mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")), output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster3/", strip_color = "#41B6C4")

```

####___iv. cluster 4

```{r}
# boxplot_gene_psite_function( vector_gene_refs = (ascore_gene_clusters_Imputation_noSD %>% filter(cluster ==4) %>% distinct(gene_ref))$gene_ref, strip_text_color = "black",
#                              dataframe = ascore_gene_clusters_Imputation_noSD  %>% distinct(condition, sample_id,gene,  gene_ref, median_norm_intensity, cluster, n_obs)%>% mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")), output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster4/", strip_color = "#C7E9B4")

```

###__iii. EGFR pathway errorbar plots
####___i. function to iterate through my data
```{r}
# boxplot_gene_psite_function <- function(vector_gene_refs, dataframe, output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/", condition = condition, sample_id = sample_id, strip_color = "gray80", strip_text_color = "black"){
# 
#   #create output directory if it doesn't exist already
#   if (!dir.exists(output_dir)){
#     dir.create(output_dir)}
#   
#   for (gene_var in vector_gene_refs) {
#     if(gene_var %in% dataframe$gene_ref) {
#       
#       #create boxplot for any sites in each gene
#       p <- ggplot() + 
#         geom_boxplot(data = dataframe %>% filter(gene_ref == gene_var),
#                mapping = aes(x = condition, y = median_norm_intensity), show.legend = FALSE, alpha = 0.3, outlier.color = NA, width = 0.5) +
#         geom_point(data = dataframe %>% filter(gene_ref == gene_var),
#                    mapping = aes(x = condition, y = median_norm_intensity),
#                    fill = "grey",
#                    mod_residue = position_jitter( width = 0.15, height = 0), shape = 21, alpha = 0.5, size = 1.5, show.legend = FALSE) +
#         geom_text(data = dataframe %>%
#         filter(gene_ref == gene_var) %>%
#           mutate(max_intensity_condition = max(median_norm_intensity)) %>% 
#         distinct(condition, gene_ref, n_obs,max_intensity_condition),
#         aes(x = condition, y = max_intensity_condition + 1, label = n_obs),size = 4, show.legend = FALSE, fontface = "bold") +
#         alexis_theme() +
#         
#         facet_wrap(facets = vars(gene_ref), nrow = 4) +
#         scale_y_continuous(name = expression("Log" [2]* "(intensity)"), expand = c(0.1,0.2))  +
#         scale_x_discrete(
#           "EGF treatment duration\n(minutes)",
#           drop = FALSE,
#           # limits = c("untreated", "1 min", "3 min", "5 min", "15 min"),
#           labels = c("0", "1", "3", "5", "15")) +
#         # theme(axis.text.x = element_text(angle = -90, hjust = 0.5, vjust = 0.5)) +
#         theme(
#           
#           strip.background = element_rect(fill = adjustcolor( strip_color, alpha.f = 0.3)),
#           strip.text = element_text(size = 16, face = "bold", family = "sans", color = strip_text_color)) #+
#         # expand_limits(y = c(15, 35)) 
#       
#       # save the plot as PNG & PDF
#       ggsave(filename = file.path(output_dir, paste0(gene_var, "_boxplot_points1.png")), plot = p, width = 8, height = 8, scale = 0.4)
#       ggsave(filename = file.path(output_dir, paste0(gene_var, "_boxplot_points1.pdf")), plot = p, width = 8, height = 8, scale = 0.4)
#       
#     } else { 
#       message (paste("Gene", gene_var, "not found in the dataframe."))
#       
#       }
#     }
# }


```


###__ii. run function to plot many PNGs
####___ii.  EGFR pathway proteins CST

```{r}
CST_EGFR_proteins <- c("P00533","P42336","Q9Y243","P42345","P23443","P15498","P63000","Q13153","Q13233","P45983","P05412","P01100","Q05397","P56945","P16333","P60953","P15941","P35222","P56539","P49023","P12830","P42226","P46108","P00519","Q9UPR0","P0DP24","Q16566","Q9UQM7","P22681","P62993","Q96J02","O14964","Q07889","O14807","P04049","Q02750","P01112","P28482","P05771","P12931","P01116","P52333","P07947","P43405","Q9UQC2","Q06124","Q99704","Q7L591","P42224","Q18PE1","P31751","P31749","P53779","P45984","Q6FG41","Q14289","P51636","Q03135","P52630","Q14765","P0DP25","Q13557","Q96NX5","P0DP23","Q13555","Q13554","P05129","P23458","Q6PKX4","Q9P104","Q07890","O60496","Q8TEW6","P36507","O60674","P17252","Q9NQ66","P19174","P51178"," Q4KWH8","P16885","O75038","Q00722","Q9UJM3","P52735","Q9UKW4","P15498","P16220","Q02930","O43889","P05771","P17252","P05129", "P19419", "P41970", "P28324")
```


```{r}

# boxplot_gene_psite_function( vector_gene_refs = (ascore_gene_clusters_Imputation_noSD %>%
#                                                    filter(reference %in% c("P19419", "P41970", "P28324")) %>% 
#                                                    # filter(grepl("STAT", gene) ==TRUE) %>% 
#                                                    # filter(reference %in% CST_EGFR_proteins) %>%
#                                                    distinct(gene_ref))$gene_ref,strip_text_color = "black",
#                              dataframe = ascore_gene_clusters_Imputation_noSD %>% distinct(gene, gene_ref, condition, replicate, sample_id, median_norm_intensity, cluster, n_obs) %>% mutate(condition = fct_relevel(condition, "EGF0min", "EGF1min", "EGF3min", "EGF5min", "EGF15min")), output_dir = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/", strip_color = "pink")


```


##_e. relative intensities of clusters
remove non-clustered p-sites, since they have less than 3 observations.


####___i. t-tests
```{r}
cluster1_intensities <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 1) %>% filter(!is.na(median_norm_intensity)) %>% filter(!is.infinite(median_norm_intensity)))$median_norm_intensity

cluster2_intensities <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 2) %>% filter(!is.na(median_norm_intensity)) %>% filter(!is.infinite(median_norm_intensity)))$median_norm_intensity

cluster3_intensities <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 3) %>% filter(!is.na(median_norm_intensity)) %>% filter(!is.infinite(median_norm_intensity)))$median_norm_intensity

cluster4_intensities <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 4) %>% filter(!is.na(median_norm_intensity)) %>% filter(!is.infinite(median_norm_intensity)))$median_norm_intensity

c1_v_c2 <- t.test(cluster1_intensities, cluster2_intensities, alternative = "two.sided", paired = FALSE, var.equal = FALSE)
# 	Welch Two Sample t-test
# 
# data:  cluster1_intensities and cluster2_intensities
# t = 15.146, df = 17689, p-value < 2.2e-16
# alternative hypothesis: true difference in means is not equal to 0
# 95 percent confidence interval:
#  0.6040061 0.7835783
# sample estimates:
# mean of x mean of y 
#  19.87518  19.18138 
c1_v_c3 <- t.test(cluster1_intensities, cluster3_intensities, alternative = "two.sided", paired = FALSE, var.equal = FALSE)
c1_v_c4 <- t.test(cluster1_intensities, cluster4_intensities, alternative = "two.sided", paired = FALSE, var.equal = FALSE)
c2_v_c3 <- t.test(cluster2_intensities, cluster3_intensities, alternative = "two.sided", paired = FALSE, var.equal = FALSE)
c2_v_c4 <- t.test(cluster2_intensities, cluster4_intensities, alternative = "two.sided", paired = FALSE, var.equal = FALSE)
c3_v_c4 <- t.test(cluster3_intensities, cluster4_intensities, alternative = "two.sided", paired = FALSE, var.equal = FALSE)

print("cluster 1 versus cluster 2")
c1_v_c2

print("cluster 1 versus cluster 3")
c1_v_c3

print("cluster 1 versus cluster 4")
c1_v_c4

print("cluster 2 versus cluster 3")
c2_v_c3
print("cluster 2 versus cluster 4")
c2_v_c4
print("cluster 3 versus cluster 4")
c3_v_c4



c1_v_c2$p.value
c1_v_c3$p.value
c1_v_c4$p.value
c2_v_c3$p.value
c2_v_c4$p.value
c3_v_c4$p.value



  ###NOTE: I think I need to only dived by 6 since I perform 6 different tests/comparisons.
adj_pvalue_threshold <-  0.05 / 6
adj_pvalue_threshold


# #spit out pvalues to compare to Bonferroni corrected threshold of 0.05 alpha (sig threshold) / 6 tests



#significance testing, TRUE or FALSE
c1_v_c2result <- c1_v_c3$p.value <= adj_pvalue_threshold & c1_v_c2$p.value <= adj_pvalue_threshold

c1_v_c3result <- c1_v_c3$p.value <= adj_pvalue_threshold & c1_v_c3$p.value <= adj_pvalue_threshold

c1_v_c4result <- c1_v_c4$p.value <= adj_pvalue_threshold & c1_v_c4$p.value <= adj_pvalue_threshold

c2_v_c3result <- c2_v_c3$p.value <= adj_pvalue_threshold & c2_v_c3$p.value <= adj_pvalue_threshold
c2_v_c4result <- c2_v_c4$p.value <= adj_pvalue_threshold & c2_v_c4$p.value <= adj_pvalue_threshold
c3_v_c4result <- c3_v_c4$p.value <= adj_pvalue_threshold & c3_v_c4$p.value <= adj_pvalue_threshold

c1_v_c2result #cluster 1 is significantly more intense than cluster 2
c1_v_c3result #cluster 1 is significantly more intense than cluster 3

c1_v_c4result #cluster 1 is significantly more intense than cluster 4

c2_v_c3result #cluster 2 is NOT significantly more intense than cluster 3
c2_v_c4result #cluster 2 is significantly more intense than cluster 4
c3_v_c4result #cluster 3 is significantly more intense than cluster 4
```

custom fill scale
```{r}
#Create a custom color scale
# library(RColorBrewer)
# myfills <- brewer.pal(5,"Dark2")
myfills <- c("#081D58",  "#225EA8", "#41B6C4",  "#C7E9B4")
names(myfills) <- levels((ascore_gene_clusters_Imputation_noSD %>%
                                           filter(!is.na(cluster)) %>%
                                           mutate(cluster = as.factor(cluster)))$cluster)

fillScale <- scale_fill_manual(name = "cluster",values = myfills)
```


####___ii. plot
```{r}

#semgent and labels positions ------------------------------
segment_positions <- data.frame(x = c(1, 2, 3, 1, 1), xend = c(2, 3, 4, 4, 3), y = c(37.8, 34.5, 36, 39,36.5), yend = c(37.8, 34.5, 36, 39, 36.5), significance = c("***", "n.s.", "***", "***", "***"), label_positions_x = c(1.5, 2.5, 3.5, 2.5, 2), label_positions_y = c(37.9, 35.4, 36.15, 39.15, 36.65))


#n = dataframe for labeling ------------------------------
counts_df <- data.frame(x =c(1.3, 2.3, 3.3, 4.3) ,
                        y = c(23, 21.3, 21.4, 20.8),
                        label = c(paste0("n=", length(cluster1_intensities)),
                                  paste0("n=", length(cluster2_intensities)),
                                  paste0("n=", length(cluster3_intensities)),
                                  paste0("n=", length(cluster4_intensities)) ))


#plot  -------------------------------------------------
plot_obs_intensities_vs_cluster <-ggplot() +
  geom_boxplot(data = ascore_gene_clusters_Imputation_noSD %>%
                                           filter(!is.na(cluster)) %>%
                                           mutate(cluster = as.factor(cluster)),
               mapping = aes( x = cluster, y = median_norm_intensity, fill = cluster),
               show.legend = FALSE,
               outlier.alpha = 0.1, 
               outlier.shape = 21) +
  fillScale +
  alexis_theme() +
  theme(
    axis.title.y = element_text(hjust = 0.5, size = 12, vjust = 0),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14, vjust = 1),
    axis.text.y = element_text(size = 12),
    axis.title.x  = element_text(size = 14, vjust = 1)) +
  scale_y_continuous(limits = c(10, 40), expand = c(0,0), name = expression("Log"[2]*"(intensity)")) +
  geom_segment(data = segment_positions, mapping = aes(x = x + 0.05, xend = xend-0.05, y = y, yend = yend), inherit.aes = FALSE, linewidth = 0.25) +
  geom_text(data = segment_positions, mapping = aes(x = label_positions_x, y = label_positions_y, label = significance), size = 3.5) +
  geom_text(data = counts_df, mapping = aes(x = x, y = y, label = label), size = 2 )


plot_obs_intensities_vs_cluster

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_obs_intensities_vs_cluster.png", plot = plot_obs_intensities_vs_cluster, scale = 0.4, width = 7, height = 6)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_obs_intensities_vs_cluster.pdf", plot = plot_obs_intensities_vs_cluster, scale = 0.4, width = 7, height = 7)
```

psites with less than 3 observations were not included in cluster vs. intensity analysis.



##_f. GO analysis of clusters

Be sure to update plot name if sources are changed. For example, GO:BP should have plot name of BP, not MF or CC.
Also note, in some cases I defined which terms to compare instead of choosing top terms per cluster. This allows direct comparison of specific terms across clusters. This is at cost of seeing most matched terms per cluster.

####__i. cluster1
```{r}
#input is your vector of protein ids
cluster1_ids <- (ascore_gene_clusters_Imputation_noSD %>%
                   filter(cluster == 1) %>% distinct(reference))$reference
 
#--------------------------------------------------------------------------------------------------------------------------
#if you want to play around interactively with GO terms on the gprofiler2 website, get a link with this code
cluster1_gp_result_link <- gost(query = cluster1_ids, organism = "hsapiens", sources = c("GO:MF"), as_short_link = TRUE) 
                                                                                         # "GO:MF",
                                                                                         #  "GO:CC",
                                                                                         # "REAC"), as_short_link = TRUE)
cluster1_gp_result_link
```


```{r}
#-------------------------------------------------------------------------------------------------------------------------- 
#To map GO terms within R, use this:
 
cluster1_gp_result <- gost(query = cluster1_ids, organism = "hsapiens", sources = c(
                                                                                       "GO:BP"))#,
                                                                                     #"GO:MF"))#,
                                                                                    # "GO:CC",
                                                                                    # "REAC"))
##To filter for more detailed terms, aka not Biological Process, etc...
gost_result_cluster1 <- cluster1_gp_result$result %>%
  filter(term_size < 1000)
 
#you can print the results
print(cluster1_gp_result$result)
 
#you can write results to a csv... I think... just change the path
write_csv(cluster1_gp_result$result, "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/go_enrichment_results_cluster1.csv")
 
#highlight the terms you want to plot, here the top 10 terms
top_terms1 <- (gost_result_cluster1 %>% arrange(p_value, desc(intersection_size)))[1:10,]
top_terms_all1 <- gost_result_cluster1 %>% filter(term_name %in% c("epidermal growth factor receptor signaling pathway",
                                                                  "actin filament organization",
                                                                  "ERBB signaling pathway",
                                                                  "actomyosin structure organization",
                                                                  "regulation of mRNA processing",
                                                                  # "regulation of RNA splicing",
                                                                  "regulation of translation",
                                                                  # "regulation of amide metabolic process",
                                                                  "cytoplasmic translation",
                                                                  "non-membrane-bounded organelle assembly",
                                                                  "cell junction assembly",
                                                                  "vascular endothelial growth factor receptor signaling pathway",
                                                                  "post-Golgi vesicle-mediated transport",
                                                                  "endosomal transport",
                                                                  "RNA catabolic process")) %>% 
  arrange(p_value, desc(intersection_size))
 
#BAR PLOT
cluster1_barplot <- ggplot(top_terms1, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_bar(stat = "identity") +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  # scale_y_continuous(limits = c(0, 40), expand = c(0,0)) +
  theme_bw(12)
 
cluster1_barplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster1_barplot_BP.png", plot = cluster1_barplot, scale = 0.4, width = 16, height = 10)


#BUBBLE PLOT
cluster1_bubbleplot <- ggplot(top_terms1, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_point(mapping = aes(size = precision, color = desc(p_value)), show.legend = FALSE) +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  # scale_y_continuous(limits = c(0, 50), expand = c(0,0)) +
  theme_bw(12)

cluster1_bubbleplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster1_bubbleplot_BP.png", plot = cluster1_bubbleplot, scale = 0.4, width = 16, height = 10)
```



####__ii. cluster2
```{r}
#input is your vector of protein ids
cluster2_ids <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 2))$reference
 
#--------------------------------------------------------------------------------------------------------------------------
#if you want to play around interactively with GO terms on the gprofiler2 website, get a link with this code
cluster2_gp_result_link <- gost(query = cluster2_ids, organism = "hsapiens", sources = c("GO:BP", "GO:MF",
                                                                                          "GO:CC",
                                                                                         "REAC"), as_short_link = TRUE)
cluster2_gp_result_link
```


```{r}
#-------------------------------------------------------------------------------------------------------------------------- 
#To map GO terms within R, use this:
 
cluster2_gp_result <- gost(query = cluster2_ids, organism = "hsapiens", sources = c(
                                                                                      "GO:BP"))#,
                                                                                    # "GO:MF"))#,
                                                                                    # "GO:CC",
                                                                                    # "REAC"))
##To filter for more detailed terms, aka not Biological Process, etc...
gost_result_cluster2 <- cluster2_gp_result$result %>%
  filter(term_size < 1000)
 
#you can print the results
print(cluster2_gp_result$result)
 
#you can write results to a csv... I think... just change the path
write_csv(cluster2_gp_result$result, "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/go_enrichment_results_cluster2.csv")
 
#highlight the terms you want to plot, here the top 10 terms
top_terms2 <- (gost_result_cluster2 %>% arrange(p_value, desc(intersection_size)))[1:10,]
top_terms_all2 <- gost_result_cluster2 %>% filter(term_name %in% c("epidermal growth factor receptor signaling pathway",
                                                                  "actin filament organization",
                                                                  "ERBB signaling pathway",
                                                                  "actomyosin structure organization",
                                                                  "regulation of mRNA processing",
                                                                  # "regulation of RNA splicing",
                                                                  "regulation of translation",
                                                                  # "regulation of amide metabolic process",
                                                                  "cytoplasmic translation",
                                                                  "non-membrane-bounded organelle assembly",
                                                                  "cell junction assembly",
                                                                  "vascular endothelial growth factor receptor signaling pathway",
                                                                  "post-Golgi vesicle-mediated transport",
                                                                  "endosomal transport",
                                                                  "RNA catabolic process")) %>% 
  arrange(p_value, desc(intersection_size)) 

#BAR PLOT
cluster2_barplot <- ggplot(top_terms2, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_bar(stat = "identity") +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  theme_bw(12)
 
cluster2_barplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster2_barplot_BP.png", plot = cluster2_barplot, scale = 0.4, width = 16, height = 10)


#BUBBLE PLOT
cluster2_bubbleplot <- ggplot(top_terms2, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_point(mapping = aes(size = precision, color = desc(p_value)), show.legend = FALSE) +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  # scale_y_continuous(limits = c(0, 40), expand = c(0,0)) +
  theme_bw(12)

cluster2_bubbleplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster2_bubbleplot_BP.png", plot = cluster2_bubbleplot, scale = 0.4, width = 16, height = 10)
```

####__iii. cluster3
```{r}
#input is your vector of protein ids
cluster3_ids <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 3))$reference
 
#--------------------------------------------------------------------------------------------------------------------------
#if you want to play around interactively with GO terms on the gprofiler2 website, get a link with this code
cluster3_gp_result_link <- gost(query = cluster3_ids, organism = "hsapiens", sources = c( "GO:MF"),
# "GO:BP",                                                                                          "GO:CC",
                                                                                         # "REAC"),
as_short_link = TRUE)
cluster3_gp_result_link
```


```{r}
#-------------------------------------------------------------------------------------------------------------------------- 
#To map GO terms within R, use this:
 
cluster3_gp_result <- gost(query = cluster3_ids, organism = "hsapiens", sources = c(
                                                                                       "GO:BP"))#,
                                                                                    # "GO:MF"))#,
                                                                                    # "GO:CC",
                                                                                    # "REAC"))
##To filter for more detailed terms, aka not Biological Process, etc...
gost_result_cluster3 <- cluster3_gp_result$result %>%
  filter(term_size < 1000)
 
#you can print the results
print(cluster3_gp_result$result)
 
#you can write results to a csv... I think... just change the path
write_csv(cluster3_gp_result$result, "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/go_enrichment_results_cluster3.csv")
 
#highlight the terms you want to plot, here the top 10 terms
top_terms3 <- (gost_result_cluster3 %>% arrange(p_value, desc(intersection_size)))[1:10,]
top_terms_all3 <- gost_result_cluster3 %>% filter(term_name %in% c("epidermal growth factor receptor signaling pathway",
                                                                  "actin filament organization",
                                                                  "ERBB signaling pathway",
                                                                  "actomyosin structure organization",
                                                                  "regulation of mRNA processing",
                                                                  # "regulation of RNA splicing",
                                                                  "regulation of translation",
                                                                  # "regulation of amide metabolic process",
                                                                  "cytoplasmic translation",
                                                                  "non-membrane-bounded organelle assembly",
                                                                  "cell junction assembly",
                                                                  "vascular endothelial growth factor receptor signaling pathway",
                                                                  "post-Golgi vesicle-mediated transport",
                                                                  "endosomal transport",
                                                                  "RNA catabolic process")) %>% 
  arrange(p_value, desc(intersection_size)) 


#BAR PLOT
cluster3_barplot <- ggplot(top_terms3, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_bar(stat = "identity") +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  theme_bw(12)
 
cluster3_barplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster3_barplot_BP.png", plot = cluster3_barplot, scale = 0.4, width = 16, height = 10)


#BUBBLE PLOT
cluster3_bubbleplot <- ggplot(top_terms3, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_point(mapping = aes(size = precision, color = desc(p_value)), show.legend = TRUE) +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  # scale_y_continuous(limits = c(4, 10), expand = c(0,0)) +
  theme_bw(12)

cluster3_bubbleplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster3_bubbleplot_BP.png", plot = cluster3_bubbleplot, scale = 0.4, width = 16, height = 10)
```

####__iv. cluster4
```{r}
#input is your vector of protein ids
cluster4_ids <- (ascore_gene_clusters_Imputation_noSD %>% filter(cluster == 4))$reference
 
#--------------------------------------------------------------------------------------------------------------------------
#if you want to play around interactively with GO terms on the gprofiler2 website, get a link with this code
cluster4_gp_result_link <- gost(query = cluster4_ids, organism = "hsapiens", sources = c("GO:BP", "GO:MF",
                                                                                          "GO:CC",
                                                                                         "REAC"), as_short_link = TRUE)
cluster4_gp_result_link
```


```{r}
#-------------------------------------------------------------------------------------------------------------------------- 
#To map GO terms within R, use this:

cluster4_gp_result <- gost(query = cluster4_ids, organism = "hsapiens", sources = c(
                                                                                      "GO:BP"))#,
                                                                                    # "GO:MF"))#,
                                                                                    # "GO:CC",
                                                                                    # "REAC"))
##To filter for more detailed terms, aka not Biological Process, etc...
gost_result_cluster4 <- cluster4_gp_result$result %>%
  filter(term_size < 1000)

#you can print the results
print(cluster4_gp_result$result)

#you can write results to a csv... I think... just change the path
write_csv(cluster4_gp_result$result, "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/go_enrichment_results_cluster4.csv")

#highlight the terms you want to plot, here the top 10 terms
top_terms4 <- (gost_result_cluster4 %>% arrange(p_value, desc(intersection_size)))[1:10,]
top_terms_all4 <- gost_result_cluster4 %>% filter(term_name %in% c("epidermal growth factor receptor signaling pathway",
                                                                  "actin filament organization",
                                                                  "ERBB signaling pathway",
                                                                  "actomyosin structure organization",
                                                                  "regulation of mRNA processing",
                                                                  "regulation of RNA splicing",
                                                                  "regulation of translation",
                                                                  "regulation of amide metabolic process",
                                                                  "cytoplasmic translation",
                                                                  "non-membrane-bounded organelle assembly",
                                                                  "cell junction assembly",
                                                                  "vascular endothelial growth factor receptor signaling pathway",
                                                                  "post-Golgi vesicle-mediated transport",
                                                                  "endosomal transport",
                                                                  "RNA catabolic process")) %>%
  arrange(p_value, desc(intersection_size))

#BAR PLOT
cluster4_barplot <- ggplot(top_terms4, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_bar(stat = "identity") +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  theme_bw(12)

cluster4_barplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster4_barplot_BP.png", plot = cluster4_barplot, scale = 0.4, width = 16, height = 10)


#BUBBLE PLOT
cluster4_bubbleplot <- ggplot(top_terms4, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_point(mapping = aes(size = precision, color = desc(p_value)), show.legend = TRUE) +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  # scale_y_continuous(limits = c(0, 30), expand = c(0,0)) +
  theme_bw(12)

cluster4_bubbleplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster4_bubbleplot_BP.png", plot = cluster4_bubbleplot, scale = 0.4, width = 16, height = 10)
```
epidermal growth factor receptor signaling pathway
actin filament organization
ERBB signaling pathway
actomyosin structure organization
regulation of mRNA processing
regulation of RNA splicing
regulation of translation
regulation of amide metabolic process
cytoplasmic translation
non-membrane bounded organelle assembly
cell junction assembly (or cell-cell junction organization) (or cell-substrate junction assembly)
vascular endothelial growth factor receptor signaling pathway
post-Golgi vesicle-mediated transport
endosomal transport
RNA catabolic process


#####----- a. not regulated pY sites

```{r}
#input is your vector of protein ids
non_reg_pY_site_ids <- (ascore_gene_clusters_Imputation_noSD %>% filter(is.na(cluster)))$reference
 
#--------------------------------------------------------------------------------------------------------------------------
#if you want to play around interactively with GO terms on the gprofiler2 website, get a link with this code
nonreg_gp_result_link <- gost(query = non_reg_pY_site_ids, organism = "hsapiens", sources = c("GO:BP", "GO:MF",
                                                                                          "GO:CC",
                                                                                         "REAC"), as_short_link = TRUE)
nonreg_gp_result_link
```

```{r}
#-------------------------------------------------------------------------------------------------------------------------- 
#To map GO terms within R, use this:

non_reg_gp_result <- gost(query = non_reg_pY_site_ids, organism = "hsapiens", sources = c( "GO:CC"))
                                                                                      # "GO:BP"))#,
                                                                                    # "GO:MF"))#,
                                                                                    # "GO:CC",
                                                                                    # "REAC"))
##To filter for more detailed terms, aka not Biological Process, etc...
gost_result_non_reg <- non_reg_gp_result$result %>%
  filter(term_size < 1000)

#you can print the results
print(non_reg_gp_result$result)

#you can write results to a csv... I think... just change the path
write_csv(non_reg_gp_result$result, "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/go_enrichment_results_non_regCC.csv")

#highlight the terms you want to plot, here the top 10 terms
top_terms4 <- (gost_result_non_reg %>% arrange(p_value, desc(intersection_size)))[1:10,]
# top_terms_all4 <- gost_result_non_reg %>% filter(term_name %in% c("epidermal growth factor receptor signaling pathway",
#                                                                   "actin filament organization",
#                                                                   "ERBB signaling pathway",
#                                                                   "actomyosin structure organization",
#                                                                   "regulation of mRNA processing",
#                                                                   "regulation of RNA splicing",
#                                                                   "regulation of translation",
#                                                                   "regulation of amide metabolic process",
#                                                                   "cytoplasmic translation",
#                                                                   "non-membrane-bounded organelle assembly",
#                                                                   "cell junction assembly",
#                                                                   "vascular endothelial growth factor receptor signaling pathway",
#                                                                   "post-Golgi vesicle-mediated transport",
#                                                                   "endosomal transport",
#                                                                   "RNA catabolic process")) %>%
#   arrange(p_value, desc(intersection_size))

#BAR PLOT
non_reg_barplot <- ggplot(top_terms4, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_bar(stat = "identity") +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  theme_bw(12)

non_reg_barplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/non_reg_barplot_CC.png", plot = non_reg_barplot, scale = 0.4, width = 16, height = 10)


#BUBBLE PLOT
non_reg_bubbleplot <- ggplot(top_terms4, aes(x = reorder(term_name, -p_value), y = -log10(p_value))) +
    geom_point(mapping = aes(size = precision, color = desc(p_value)), show.legend = TRUE) +
    coord_flip() +
    xlab("GO Term") +
    ylab("-log10(p-value)") +
    ggtitle("Top 10 Enriched GO Terms") +
  # scale_y_continuous(limits = c(0, 30), expand = c(0,0)) +
  theme_bw(12)

non_reg_bubbleplot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/non_reg_bubbleplot_CC.png", plot = non_reg_bubbleplot, scale = 0.4, width = 16, height = 10)
```

####__iv.ii protein intersection across clusters
analysis to answer if high overlap between clusters is due to pY sites on the same or different genes
```{r}
cluster1ids_df <- data.frame(reference = cluster1_ids, cluster = c(rep("cluster1", length(cluster1_ids)))) %>% distinct(reference, cluster)
cluster2ids_df <- data.frame(reference = cluster2_ids, cluster = c(rep("cluster2", length(cluster2_ids)))) %>% distinct(reference, cluster)
cluster3ids_df <- data.frame(reference = cluster3_ids, cluster = c(rep("cluster3", length(cluster3_ids)))) %>% distinct(reference, cluster)
cluster4ids_df <- data.frame(reference = cluster4_ids, cluster = c(rep("cluster4", length(cluster4_ids)))) %>% distinct(reference, cluster)
nonreg_ids_df <- data.frame(reference = non_reg_pY_site_ids, cluster = c(rep("non_reg", length(non_reg_pY_site_ids)))) %>% distinct(reference, cluster)


#combined dataframe ------------------
cluster_protein_overlap_df <- rbind(cluster1ids_df, cluster2ids_df, cluster3ids_df, cluster4ids_df, nonreg_ids_df) %>%
  mutate(protein_in_cluster = 1) %>% 
  pivot_wider(id_cols = reference, names_from = cluster, values_from = protein_in_cluster, values_fill = 0) %>% 
  group_by(reference) %>% 
  mutate(num_clusters_protein_in = sum(cluster1, cluster2, cluster3, cluster4, non_reg)) %>% 
  ungroup() %>% 
  left_join(fxns_fasta, by = "reference")

#focused example, clathrin molecular function -----------------
clathrin_pits_vesicles <- cluster_protein_overlap_df %>% 
  filter(reference %in% c("Q07912" ,  "Q12965" , "P00533" , "O15126" , "Q15286", "Q14677" , "O00443" , "O43426" , "Q9P253" , "Q9NVZ3" , "Q9Y5X1" , "P98082" , "P42566" , "Q9UBC2"))
```
clathrin coated pit: 
Q07912 in both clusters 1 and 3: Activated CDC42 kinase 1 (ACK-1) (EC 2.7.10.2) (EC 2.7.11.1) (Tyrosine kinase non-receptor protein 2)
Q12965 Unconventional myosin-Ie (Myosin-Ic) (Unconventional myosin 1E) in both clusters 1 and 2
P00533,O15126,Q15286,Q14677,O00443,O43426,Q9P253,Q9NVZ3,Q9Y5X1,P98082,P42566,Q9UBC2,
Some proteins shared between clusters despite single cluster (i.e. 3) showing enrichment


plot distribution of proteins found per cluster
```{r}
plot_cluster_protein_intersections <- ggplot(data = cluster_protein_overlap_df) +
  geom_bar(mapping = aes(x = num_clusters_protein_in)) + alexis_theme()

plot_cluster_protein_intersections
```

```{r}
# keep only proteins with 3x cluster assignments----------------------------

proteins3clusters <- cluster_protein_overlap_df %>% 
  filter(num_clusters_protein_in == 3) %>% 
  # filter(cluster1 == 1) %>%
  select(reference)
proteins3clusters
write_csv(x = proteins3clusters, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/proteins3clusters.csv")

#EGFR signaling and kinase activity are processes for 


# keep only proteins with 3x cluster assignments-----------------------

proteinsGT1clusters <- cluster_protein_overlap_df %>% 
  filter(num_clusters_protein_in >1) %>% 
  # filter(cluster1 == 1) %>%
  select(reference)
proteinsGT1clusters
write_csv(x = proteinsGT1clusters, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/proteinsGT1clusters.csv")

#EGFR signaling and kinase activity are processes for 


# keep only proteins with single cluster assignment------------------------

cluster1_ids_proteins1cluster <- cluster_protein_overlap_df %>% 
  filter(num_clusters_protein_in == 1) %>% 
  filter(cluster1 == 1) %>%
  select(reference)
cluster1_ids_proteins1cluster
write_csv(x = cluster1_ids_proteins1cluster, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/cluster1_ids_proteins1cluster.csv")

```

focus on nucleocytoplasmic transport to assess cluster distributions of proteins with regulated pY
```{r}
nucleocytoplasmic_transport_GO <- c("P39687","Q86U42","Q86U38","Q92837","Q99567","O60524","O60684","Q9BRK4","Q14012","P22626","P55735","Q9NPJ8","A9QM74","P62258","CPX-1427","Q96EE3","P15336","P35813","Q00987","Q07666","Q9P1T7","Q14703","P52298","P52294","P52292","Q6I9Y2","P82979","A6NF01","Q6P6C2","Q7Z434","Q7Z3J3","Q7Z3B4","Q14974","O75152","Q6P2H8","P35658","Q14181","P14317","P05455","O43301","P62841","P62829","P62826","O43592","O43566","O43525","A6NKT7","P49841","P49815","Q9C0K7","Q9C0E2","A8K855","P49792","P49790","P49768","Q6ICB0","O43865","O43745","O43734","P52594","P25963","Q14153","CPX-1066","CPX-1064","CPX-1063","CPX-1060","CPX-1057","CPX-1055","CPX-1032","CPX-1027","P20749","P12270","O95278","Q5HYJ3","CPX-1941","O43423","P52948","P42771","Q14397","Q14393","P05090","Q53H80","Q15389","Q53FT3","A8CG34","Q92900","Q99666","P31371","P21728","P31947","P31946","Q5S007","P38646","P01137","Q6NXT1","P04637","P31749","Q92621","P11161","P61970","P61960","Q86W42","Q13769","Q9HAV4","Q86V81","Q86US8","P78406","Q86UA6","O15504","Q86WN1","Q9HCE7","P41159","P01584","P01579","P55060","Q7Z4Q2","Q00535","P38936","P38919","Q96DC7","Q9Y5S9","Q9UIA9","P84022","O95817","Q9H089","O75312","P10599","Q9UI26","Q9UHL0","Q8NEU8","Q9Y3Y2","Q8NAG6","CPX-725","Q8NA57","Q96A72","P40763","O95398","Q8NDT2","O95373","O95343","P84103","Q96EV2","Q8NI27","O95760","Q9UBU9","Q9Y2B9","CPX-682","Q16630","P60896","O14980","O14974","P40305","Q9Y5L0","P20592","Q96D46","Q9UDY8","Q8NFH5","Q8NFH4","Q8NFH3","Q96HA1","Q9H1B4","O75474","P0DJD0","CPX-7281","CPX-7261","P61326","Q13523","Q13501","O15234","Q9NYF3","Q03014","Q13263","P0DQW0","Q9NU22","P07900","Q9H7Z3","Q9H814","URS000075DAEC_9606","Q96QU8","Q13043","Q9NVU7","Q9NW64","Q96QD9","Q96QC0","Q96Q15","O15397","O15379","Q6NSI3","Q9NZU7","Q9NZP6","O15131","Q13191","Q13188","Q9GZY0","Q9NUU7","P98161","Q96P70","Q9H8V3","Q13148","CPX-4747","P55265","Q7RTN6","P46527","P46531","Q9NRG9","Q9NRC8","Q9NRA8","P27797","Q16539","Q9UK53","Q9H1M0","Q9NPC8","Q9NPA8","Q96K30","P27986","Q9ULX6","Q96JI7","Q9H3M7","P54253","Q96IZ7","Q5JVF3","P17612","O75694","Q9ULC3","Q96J01","CPX-3624","Q9H2T7","P17861","Q96KW2","Q9UMX1","Q9UPR3","O14787","P54619","Q96MT3","Q9H6Z4","Q9H6R4","Q9H720","Q9UKX7","Q9UKK6","Q9UKG1","Q9UMR2","Q9H4D5","Q9NPF5","Q9H4A3","P21359","O95149","Q96FV9","CPX-873","O95071","O60674","P12830","Q5SRE5","Q5BIV9","P02545","O60518","Q9BVS4","Q9BW27","Q9BVL2","P46060","Q9BQL6","O60318","P22736","Q9BYW2","Q9BYV9","Q9BY77","P23528","O15169","P53801","P43487","P43405","Q8N0Z2","Q9HAU5","Q15915","Q05655","Q86VV4","P14923","Q8WYP5","Q09472","CPX-462","CPX-459","P50402","Q8N6T7","Q8N726","P0DW28","Q08J23","Q12769","O14681","Q06787","Q09161","Q05D32","Q12891","O14746","O14715","CPX-925","P0DJD1","Q49AN0","P37198","Q96GA3","Q06124","CPX-2488","CPX-2477","P63279","CPX-2436","CPX-2435","CPX-2433","Q99728","Q15465","CPX-2401","Q8WUM0","P36873","Q53GS7","Q8TEM1","P46934","O00148","Q99497","Q15717","P16671","O00629","Q99966","P61925","Q15678","CPX-2612","Q15648","Q92540","P46695","O00505","CPX-2549","Q99835","Q15139","Q8IWY9","Q92973","P63165","Q99653","O94829","Q99623","P21333","Q8TEX9","P63098","Q92688","Q8TD31","O00459","O00410","P39900","Q08211","Q08209","P12644","Q8TAS1","Q9BUP3","Q9BTX1","P56537","Q2M389","Q13838","P09651","Q9BWF3","P29590","Q96MU7","Q69383","O00716","CPX-9481","P06493","Q96ST2","P10071","P57740","Q5D1E8","Q8NEZ5","Q8N1F7","P06748","P06730","Q53F19","P23497","A0A1B0GTU1")

plot_cluster_protein_intersections_nct <- ggplot(data = cluster_protein_overlap_df %>% filter(reference %in% nucleocytoplasmic_transport_GO) %>% filter(non_reg == 1)) +
  geom_bar(mapping = aes(x = num_clusters_protein_in)) + alexis_theme()

plot_cluster_protein_intersections_nct
```
some shared genes between more than one regulated cluster for nucleocytoplasmic transport from non-reg pY sites. More unique genes though.


focus on ubiquitin binding shared between clusters 1 and 3
```{r}
ubiquitin_binding_GO <- c("O60231", "Q6ZMZ0", "Q92833", "Q9H6K1", "Q5T124", "CPX-2766", "P25686", "CPX-8151", "CPX-8150", "CPX-8147", "CPX-8134", "CPX-8133", "CPX-8132", "CPX-8131", "CPX-8130", "CPX-8129", "CPX-8128", "CPX-8126", "CPX-8125", "CPX-8122", "CPX-8110", "CPX-8109", "CPX-8108", "CPX-8107", "CPX-8106", "CPX-8103", "CPX-8102", "P15374", "Q00987", "CPX-7882", "CPX-7901", "CPX-7903", "CPX-7929", "Q9UNN5", "P09936", "CPX-1877", "P45974", "CPX-7847", "Q04323", "O43318", "P42566", "CPX-8942", "CPX-8941", "CPX-8935", "CPX-8927", "CPX-8917", "CPX-8916", "CPX-3291", "CPX-9081", "Q14596", "CPX-8263", "CPX-8262", "CPX-8261", "CPX-8242", "CPX-8241", "CPX-8222", "CPX-8221", "CPX-8202", "O43684", "CPX-7821", "P49459", "CPX-8097", "CPX-8091", "CPX-8090", "CPX-8089", "CPX-8088", "CPX-8087", "CPX-8085", "CPX-8084", "CPX-8083", "CPX-8064", "CPX-8063", "CPX-8041", "CPX-8025", "CPX-8007", "CPX-8006", "CPX-8005", "CPX-8004", "CPX-8003", "CPX-8002", "Q96EP0", "CPX-7906", "CPX-7905", "CPX-7904", "CPX-7902", "Q8WV99", "CPX-7881", "CPX-7846", "CPX-7822", "CPX-7801", "Q86VN1", "Q86UW6", "P78406", "P11388", "O00124", "O76064", "P21580", "Q5TDH0", "Q9HC29", "O75113", "Q9Y679", "Q9Y5T5", "Q96DC9", "P84022", "Q9H040", "Q9UHP3", "CPX-8201", "Q9Y3I1", "Q96EY5", "CPX-3295", "CPX-3292", "CPX-648", "O14964", "O14933", "Q96CS3", "Q9H1I8", "Q13501", "Q9NZ52", "Q9NZ09", "Q9NYJ8", "CPX-8061", "P61088", "P61073", "P61024", "P54727", "P54725", "Q9NWM3", "Q13049", "Q13490", "CPX-8123", "CPX-8135", "Q9H992", "CPX-7976", "Q9UNZ2", "Q96LJ8", "F5GYI3", "Q9UJY5", "Q9UJY4", "Q9UK41", "Q9H467", "O75674", "O75886", "Q96L34", "Q9UKV5", "Q6NZ36", "CPX-7786", "CPX-7785", "CPX-7784", "CPX-7763", "CPX-7762", "CPX-7761", "P04792", "CPX-7747", "P68543", "Q9H4L7", "CPX-8918", "O94888", "CPX-876", "O95071", "Q6ZT62", "Q14CS0", "O60260", "Q9BYM8", "Q6ZVM7", "CPX-2241", "CPX-2343", "CPX-2782", "CPX-2786", "CPX-2873", "CPX-2859", "CPX-2832", "CPX-2819", "CPX-2818", "CPX-2817", "CPX-2816", "CPX-2809", "CPX-2804", "CPX-530", "CPX-477", "CPX-2405", "CPX-2412", "CPX-2415", "P33552", "Q969H0", "Q9Y263", "Q9Y239", "Q9UBN7", "P37198", "Q96GF1", "Q9H0F6", "Q9H0E2", "Q96FW1", "Q9Y6K9", "CPX-2492", "CPX-2489", "CPX-2438", "CPX-2416", "CPX-2414", "CPX-2413", "CPX-2411", "CPX-2407", "CPX-2406", "CPX-2404", "CPX-2403", "CPX-2239", "P46934", "Q92783", "CPX-2683", "CPX-2658", "CPX-2554", "CPX-2553", "CPX-9281", "CPX-2538", "Q99816", "CPX-2516", "CPX-2512", "Q8IXJ6", "Q8IXH6", "Q92995", "CPX-2399", "CPX-2365", "CPX-2319", "CPX-2300", "Q8IYW5", "Q8IX04", "Q8TAT6", "Q8TAF3", "Q5M7Z0", "O60784", "Q96MX6", "CPX-6263", "CPX-2799", "CPX-2797", "CPX-2795", "CPX-2787", "CPX-2785", "CPX-2784", "CPX-2783", "CPX-2778", "CPX-2777", "CPX-2773", "CPX-2770", "CPX-2769", "CPX-2765", "CPX-2762", "CPX-2759", "CPX-2758", "CPX-2757", "CPX-2748", "CPX-9461", "CPX-9442", "Q8N5C8", "CPX-9361", "CPX-9381", "Q13351", "CPX-7983", "CPX-7982", "CPX-7981", "CPX-7979", "CPX-7977", "CPX-7975", "CPX-7973", "CPX-7972", "CPX-7971", "CPX-7968", "CPX-7967", "CPX-7966", "CPX-7965", "CPX-7963", "CPX-7962", "CPX-7930", "CPX-7928", "CPX-7927", "CPX-7926", "CPX-7925", "CPX-7924", "CPX-7923", "CPX-7922", "CPX-7921")

plot_cluster_protein_intersections_ubibinding <- ggplot(data = cluster_protein_overlap_df %>% filter(reference %in% ubiquitin_binding_GO) %>% filter(cluster1 == 1 | cluster3 == 1 )) +
  geom_bar(mapping = aes(x = num_clusters_protein_in)) + alexis_theme()

plot_cluster_protein_intersections_ubibinding
```
yes there are some shared proteins between both clusters that have enrichment in ubiquitin binding.


####__vi.  both clustered + combined
#####___i. focus on cell compartment
```{r}
#vector of term names I want to compare between clusters ---------------------
# CC_terms <- c("cytosol", "plasma membrane","cytoskeleton", "cell junction", "cell-substrate junction", "focal adhesion", "cell leading edge", "spliceosomal complex", "ribonucleoprotein granule", "nucleus", "nuclear speck", "vesicle", "extracellular space", "extracellular vesicle", "extracellular exosome", "membrane-enclosed lumen"  )

CC_terms <- c("nucleus", "spliceosomal complex", "nucleoplasm","perinuclear region of cytoplasm",  "cytosol", "actin cytoskeleton","cytoskeleton", "Golgi apparatus", "endocytic vesicle",  "focal adhesion",  "cell junction", "cell leading edge","plasma membrane", "clathrin-coated pit",  "extracellular exosome",  "extracellular space")

cluster1_CC_result <- (gost(query = cluster1_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  # filter(term_size < 1000)
  filter(term_name %in% CC_terms)
                                                                                
cluster2_CC_result <- (gost(query = cluster2_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% CC_terms)

cluster3_CC_result <- (gost(query = cluster3_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% CC_terms)
                                                                                
cluster4_CC_result <- (gost(query = cluster4_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  # filter(term_size < 500) %>% 
  filter(term_name %in% CC_terms)

NonReg_CC_result <- (gost(query = non_reg_pY_site_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  # filter(term_size < 500) %>% 
  filter(term_name %in% CC_terms)


#web link ---------------
NonReg_CC_result_weblink <- (gost(query = non_reg_pY_site_ids,as_short_link = TRUE, organism = "hsapiens", sources = c("GO:CC"))) 
NonReg_CC_result_weblink

#combine term lists per cluster -------------------------------------                                                                         
terms_all_CC <- rbind((cluster1_CC_result %>% mutate(cluster = "1")),
                   (cluster2_CC_result %>% mutate(cluster = "2")),
                   (cluster3_CC_result %>% mutate(cluster = "3")),
                   (cluster4_CC_result %>% mutate(cluster = "4")),
                   (NonReg_CC_result %>% mutate(cluster = "-"))) #non-regulated pY sites

#plot


#flipped ------------------------------------------------
plot_GOCC_all_clusters_flipped <- ggplot(data = terms_all_CC %>% mutate(term_name = fct_relevel(term_name, "nucleus", "spliceosomal complex", "nucleoplasm","perinuclear region of cytoplasm",  "cytosol", "actin cytoskeleton","cytoskeleton", "Golgi apparatus", "endocytic vesicle",  "focal adhesion",  "cell junction", "cell leading edge","plasma membrane", "clathrin-coated pit",  "extracellular exosome",  "extracellular space"),
                                                                                             #  "plasma membrane",
                                                                                             # "extracellular space",
                                                                                             # "extracellular vesicle",
                                                                                             # "extracellular exosome",
                                                                                             # "vesicle",
                                                                                             # "cell junction",
                                                                                             # "cell-substrate junction",
                                                                                             # "focal adhesion",
                                                                                             # "cell leading edge",
                                                                                             # "membrane-enclosed lumen",
                                                                                             # "cytosol",
                                                                                             # "ribonucleoprotein granule",
                                                                                             # "cytoskeleton",
                                                                                             # "nucleus",
                                                                                             # "nuclear speck",
                                                                                             # "spliceosomal complex"),
                                                                  cluster = fct_relevel(cluster, "1", "2", "3", "4", "-"))) +
  geom_point(mapping = aes(x = cluster, y = term_name, fill = -log10(p_value), size = intersection_size,
                           ), shape = 21, show.legend = TRUE) +
  theme_bw(16) +
  # scale_fill_brewer(palette = "PuOr")
  scale_fill_viridis_c(option = "C", direction =  1) +
  # coord_flip(clip = "off") +
  theme(axis.text.x = element_text(size = 18),
    # axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(size = 18),
    legend.position = "right") +
  ylab("GO cellular component")

plot_GOCC_all_clusters_flipped

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOCC_all_clusters_NonReg_flipped.png", plot = plot_GOCC_all_clusters_flipped,
       width = 18, height = 12, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOCC_all_clusters_NonReg_flipped.pdf", plot = plot_GOCC_all_clusters_flipped,
       width = 18, height = 12, scale = 0.4)


```
dash represents gene with non-regulated pY sites within our timeframe. 
many other good things about this result. For example, we can see we captured earlier signaling events. (stopped here evening 12-25-24)
#####___ii. focus on molecular function
```{r}
#vector of term names I want to compare between clusters ---------------------

MF_terms <- c('cadherin binding',
              'actin binding',
              'kinase binding',
              'signaling adaptor activity',
              'SH3 domain binding',
              'receptor tyrosine kinase binding',
              # 'protein tyrosine kinase binding',
              'cell-cell adhesion mediator activity',
              'ubiquitin-like protein ligase binding',
              'ubiquitin protein ligase binding',
              'ubiquitin binding',
              '1-phosphatidylinositol-4-phosphate 3-kinase activity',
              'GTPase regulator activity',
              'GTPase activator activity',
              'myosin binding',
              'phosphatase binding',
              'kinase regulator activity',
              'cell adhesion molecule binding',
              'protein serine kinase activity',
              'cyclin-dependent protein serine/threonine kinase activity',
              'ATP-dependent protein folding chaperone',
              'TPR domain binding',
              'importin-alpha family protein binding',
              'GTPase binding',
              'phosphotyrosine residue binding',
              'MAP kinase activity',
              'clathrin binding',
              'lipid binding',
              # 'mitogen-activated protein kinase binding',
              'clathrin adaptor activity',
              
              # 'cargo adaptor activity',
              'potassium:chloride symporter activity',
              # 'signaling receptor complex adaptor activity',
              'small GTPase binding',
              'phosphatidylinositol 3-kinase regulatory subunit binding',
              'alpha-actinin binding',
              'Rho-dependent protein serine/threonine kinase activity')#,
              # 'nucleoside-triphosphatase regulator activity',
              # 'molecular adaptor activity')

cluster1_MF_result <- (gost(query = cluster1_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% MF_terms)
                                                                                
cluster2_MF_result <- (gost(query = cluster2_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% MF_terms)

cluster3_MF_result <- (gost(query = cluster3_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% MF_terms)
                                                                                
cluster4_MF_result <- (gost(query = cluster4_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  # filter(term_size < 500) %>% 
  filter(term_name %in% MF_terms)

NonReg_MF_result <- (gost(query = non_reg_pY_site_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  # filter(term_size < 500) %>% 
  filter(term_name %in% MF_terms)

#web link
NonReg_MF_result_weblink <- (gost(query = non_reg_pY_site_ids,as_short_link = TRUE, organism = "hsapiens", sources = c("GO:MF"))) 
NonReg_MF_result_weblink

#combine term lists per cluster -------------------------------------                                                                         
terms_all_MF <- rbind((cluster1_MF_result %>% mutate(cluster = "1")),
                   (cluster2_MF_result %>% mutate(cluster = "2")),
                   (cluster3_MF_result %>% mutate(cluster = "3")),
                   (cluster4_MF_result %>% mutate(cluster = "4")),
                   (NonReg_MF_result %>% mutate(cluster = "-"))) #non-regulated pY sites

#plot


#flipped ------------------------------------------------
plot_GOMF_all_clusters_flipped <- ggplot(data = terms_all_MF %>% mutate(
                                                                  term_name = fct_relevel(term_name, 'alpha-actinin binding','phosphatidylinositol 3-kinase regulatory subunit binding','Rho-dependent protein serine/threonine kinase activity','cargo adaptor activity','clathrin adaptor activity','clathrin binding','MAP kinase activity','mitogen-activated protein kinase binding','potassium:chloride symporter activity','ATP-dependent protein folding chaperone','cyclin-dependent protein serine/threonine kinase activity','importin-alpha family protein binding','TPR domain binding','1-phosphatidylinositol-4-phosphate 3-kinase activity','kinase regulator activity','myosin binding','phosphatase binding','cell-cell adhesion mediator activity','GTPase activator activity','GTPase regulator activity','nucleoside-triphosphatase regulator activity','signaling adaptor activity','signaling receptor complex adaptor activity','small GTPase binding','GTPase binding','lipid binding','ubiquitin binding','ubiquitin protein ligase binding','protein tyrosine kinase binding','receptor tyrosine kinase binding','SH3 domain binding','protein serine kinase activity','ubiquitin-like protein ligase binding','phosphotyrosine residue binding','molecular adaptor activity','kinase binding','cell adhesion molecule binding','cadherin binding','actin binding',
),
                                                                                             
                                                                  cluster = fct_relevel(cluster, "1", "2", "3", "4", "-"))) +
  geom_point(mapping = aes(x = cluster, y = term_name, fill = -log10(p_value), size = intersection_size
                           ), shape = 21, show.legend = TRUE) +
  theme_bw(10) +
  # scale_fill_brewer(palette = "PuOr")
  scale_fill_viridis_c(option = "C", direction =  1) +
  # coord_flip(clip = "off") +
  theme(
    # axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(size = 10)) +
  ylab("GO molecular function")

plot_GOMF_all_clusters_flipped

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOMF_all_clusters_flipped.png", plot = plot_GOMF_all_clusters_flipped,
       width = 17, height = 16, scale = 0.35)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOMF_all_clusters_flipped.pdf", plot = plot_GOMF_all_clusters_flipped,
       width = 12, height = 14, scale = 0.4)


```


#####___iii. focus on biological process
```{r}
#vector of term names I want to compare between clusters ---------------------
# BP_terms <- c("cytosol", "plasma membrane","cytoskeleton", "cell junction", "cell-substrate junction", "focal adhesion", "cell leading edge", "spliceosomal complex", "ribonucleoprotein granule", "nucleus", "nuclear speck", "vesicle", "extracellular space", "extracellular vesicle", "extracellular exosome", "membrane-enclosed lumen"  )

BP_terms <- c(   
              "organelle organization",
             # "anatomical structure development",
             "cell adhesion",
              "cell junction organization",
             "actin filament organization",
             # "cell morphogenesis",
              "protein localization to cell periphery",
             "vesicle organization",
             "positive regulation of cell projection organization",
             "regulation of nucleocytoplasmic transport",
             "regulation of kinase activity",
             "regulation of small GTPase mediated signal transduction",
              "endosomal transport",
              # "post-Golgi vesicle-mediated transport",
             
             # "non-membrane-bounded organelle assembly",
             "regulation of translation",
              # "positive regulation of mRNA processing",
             
             # "vascular endothelial growth factor receptor signaling pathway",
             "MAPK cascade",
             # "negative regulation of epidermal growth factor receptor signaling pathway",
             "epidermal growth factor receptor signaling pathway" )
  
  
                                                                  # "epidermal growth factor receptor signaling pathway",
                                                                  # "negative regulation of epidermal growth factor receptor signaling pathway",
                                                                  # "MAPK cascade",
                                                                  # "vascular endothelial growth factor receptor signaling pathway",
                                                                  # "actin filament organization",
                                                                  # "positive regulation of mRNA processing",
                                                                  # "regulation of translation",
                                                                  # "non-membrane-bounded organelle assembly",
                                                                  # "cell junction organization",
                                                                  # 
                                                                  # "post-Golgi vesicle-mediated transport",
                                                                  # "endosomal transport",
                                                                  # "regulation of small GTPase mediated signal transduction",
                                                                  # "regulation of kinase activity",
                                                                  # "regulation of nucleocytoplasmic transport",
                                                                  # "positive regulation of cell projection organization",
                                                                  # "vesicle organization",
                                                                  # "protein localization to cell periphery",
                                                                  # "cell morphogenesis",
                                                                  # "cell adhesion",
                                                                  # "anatomical structure development",
                                                                  # "organelle organization")

cluster1_BP_result <- (gost(query = cluster1_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% BP_terms)
                                                                                
cluster2_BP_result <- (gost(query = cluster2_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% BP_terms)

cluster3_BP_result <- (gost(query = cluster3_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  # filter(term_size < 500)
  filter(term_name %in% BP_terms)
                                                                                
cluster4_BP_result <- (gost(query = cluster4_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  # filter(term_size < 500) %>% 
  filter(term_name %in% BP_terms)

NonReg_BP_result <- (gost(query = non_reg_pY_site_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  # filter(term_size < 500) %>% 
  filter(term_name %in% BP_terms)


#combine term lists per cluster -------------------------------------                                                                         
terms_all_BP <- rbind((cluster1_BP_result %>% mutate(cluster = "1")),
                   (cluster2_BP_result %>% mutate(cluster = "2")),
                   (cluster3_BP_result %>% mutate(cluster = "3")),
                   (cluster4_BP_result %>% mutate(cluster = "4")),
                   (NonReg_BP_result %>% mutate(cluster = "-"))) #non-regulated pY sites

#plot


#not flipped ------------------------------------------------
plot_GOBP_all_clusters1 <- ggplot(data = terms_all_BP %>%
                                    mutate(term_name = fct_relevel(term_name, 
                                                             "organelle organization",
                                                             # "anatomical structure development",
                                                             "cell adhesion",
                                                              "cell junction organization",
                                                             "actin filament organization",
                                                             # "cell morphogenesis",
                                                              
                                                             "positive regulation of cell projection organization",
                                                             "regulation of nucleocytoplasmic transport",
                                                             "regulation of kinase activity",
                                                             "regulation of small GTPase mediated signal transduction",
                                                             "protein localization to cell periphery",
                                                             "vesicle organization", 
                                                             "endosomal transport",
                                                              # "post-Golgi vesicle-mediated transport",
                                                             
                                                             # "non-membrane-bounded organelle assembly",
                                                             "regulation of translation",
                                                              # "positive regulation of mRNA processing",
                                                             
                                                             # "vascular endothelial growth factor receptor signaling pathway",
                                                             "MAPK cascade",
                                                             "negative regulation of epidermal growth factor receptor signaling pathway",
                                                             "epidermal growth factor receptor signaling pathway"  ),
                                                                                         
                                                                                         
                                                                                             
                                                                  cluster = fct_relevel(cluster, "1", "2", "3", "4", "-"))) +
  geom_point(mapping = aes(x = cluster, y = term_name, fill = -log10(p_value), size = intersection_size
                           ), shape = 21, show.legend = TRUE) +
  theme_bw(10) +
  # scale_fill_brewer(palette = "PuOr")
  scale_fill_viridis_c(option = "C", direction =  1) +
  # coord_flip(clip = "off") +
  theme(axis.text.x = element_text(size = 12),
    # axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(size = 10)) +
  ylab("GO biological process") +
  scale_y_discrete(limits = rev)

plot_GOBP_all_clusters1

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOBP_all_clusters1.png", plot = plot_GOBP_all_clusters1,
       width =24, height = 12, scale = 0.3)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOBP_all_clusters1.pdf", plot = plot_GOBP_all_clusters1,
       width = 20, height = 14, scale = 0.3)


```
#---------------------------------------------
#16. SUBCELLULAR LOCATIONS

##_a) FASTA
```{r}
locations_FASTA_df <- fasta_subcellular_location %>% 
   
  mutate(
    extracellular_TM = case_when(
      grepl("extracellular|transmembrane", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    cell_membrane = case_when(
      grepl("cell membrane|extracellular|transmembrane|plasma", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    nucleus = case_when(
      grepl("nucleus|nucle", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    mitochondria = case_when(
      grepl("mitochondr", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    cytoplasm = case_when(
      grepl("cytoplasm|cytosol", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    ER_Golgi = case_when(
      grepl("ndoplasmic|olgi", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE)) %>% 
  mutate(comparison = "FASTA")
```

##_a) FASTA with ratios
```{r}
locations_FASTA_df_ratios <- fasta_subcellular_location %>% 
   
  mutate(
    extracellular_TM = case_when(
      grepl("extracellular|transmembrane", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    cell_membrane = case_when(
      grepl("cell membrane|extracellular|transmembrane|plasma", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    nucleus = case_when(
      grepl("nucleus|nucle", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    mitochondria = case_when(
      grepl("mitochondr", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    cytoplasm = case_when(
      grepl("cytoplasm|cytosol", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    ER_Golgi = case_when(
      grepl("ndoplasmic|olgi", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE)) %>% 
  mutate(
    total_proteins = n_distinct(reference)) %>% 
  
  group_by(cell_membrane) %>% 
  mutate(
    ratio_membrane = n()/total_proteins) %>% 
  ungroup() %>% 
  mutate(comparison = "FASTA")
```

###_i. plot extracellular/Transmembrane by comparison
```{r}
psites_extracellular_TM_fasta <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = extracellular_TM ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  # scale_y_continuous(limits = c(0, 200), expand = c(0,0)) +
  alexis_theme()

psites_extracellular_TM_fasta

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_extracellular_TM_fasta.png", plot = psites_extracellular_TM_fasta, scale= 0.4, width = 6, height = 6)

psites_extracellular_TM_fasta_fill <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = extracellular_TM ), position = "fill", color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  alexis_theme()

psites_extracellular_TM_fasta_fill

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_extracellular_TM_fasta_fill.png", plot = psites_extracellular_TM_fasta_fill, scale= 0.4, width = 6, height = 6)
```

###_ii. plot cell membrane by comparison
```{r}

psites_cell_membrane_fasta <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = cell_membrane ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  # scale_y_continuous(limits = c(0, 200), expand = c(0,0)) +
  alexis_theme()

psites_cell_membrane_fasta

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_cell_membrane_fasta.png", plot = psites_cell_membrane_fasta, scale= 0.4, width = 6, height = 6)

psites_cell_membrane_fasta_fill <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = cell_membrane ), position = "fill", color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  alexis_theme()

psites_cell_membrane_fasta_fill

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_cell_membrane_fasta_fill.png", plot = psites_cell_membrane_fasta_fill, scale= 0.4, width = 6, height = 6)
```

###_iii. plot cytosol by comparison
```{r}

psites_cytoplasm_fasta <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = cytoplasm ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  # scale_y_continuous(limits = c(0, 200), expand = c(0,0)) +
  alexis_theme()

psites_cytoplasm_fasta

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_cytoplasm_fasta.png", plot = psites_cytoplasm_fasta, scale= 0.4, width = 6, height = 6)

psites_cytoplasm_fasta_fill <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = cytoplasm ), position = "fill", color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  alexis_theme()

psites_cytoplasm_fasta_fill

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_cytoplasm_fasta_fill.png", plot = psites_cytoplasm_fasta_fill, scale= 0.4, width = 6, height = 6)
```

###_iv. plot nucleus by comparison
```{r}

psites_nucleus_fasta <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = nucleus ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  # scale_y_continuous(limits = c(0, 200), expand = c(0,0)) +
  alexis_theme()

psites_nucleus_fasta

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_nucleus_fasta.png", plot = psites_nucleus_fasta, scale= 0.4, width = 6, height = 6)

psites_nucleus_fasta_fill <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = nucleus ), position = "fill", color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  alexis_theme()

psites_nucleus_fasta_fill

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_nucleus_fasta_fill.png", plot = psites_nucleus_fasta_fill, scale= 0.4, width = 6, height = 6)
```


###_v. plot mitochondira by comparison
```{r}

psites_mitochondria_fasta <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = mitochondria ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  # scale_y_continuous(limits = c(0, 200), expand = c(0,0)) +
  alexis_theme()

psites_mitochondria_fasta

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_mitochondria_fasta.png", plot = psites_mitochondria_fasta, scale= 0.4, width = 6, height = 6)

psites_mitochondria_fasta_fill <- ggplot(data = locations_FASTA_df) +
  geom_bar(mapping = aes(x = comparison, fill = mitochondria ), position = "fill", color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  alexis_theme()

psites_mitochondria_fasta_fill

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_mitochondria_fasta_fill.png", plot = psites_mitochondria_fasta_fill, scale= 0.4, width = 6, height = 6)
```





##_b) my data
```{r}
locations_diff_df_wImputation <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>% 
  distinct(comparison,gene_ref, diff, adj_pval, reference, mod_res, mod_residue, gene,overlap_my_data) %>%
  filter(adj_pval < 0.05) %>% 
  filter(diff < -1 | diff > 1) %>% 
  left_join(y = fasta_subcellular_location %>% select(reference, subcellular_location_cc, gene_ontology_cellular_component), by = "reference") %>% 
   
  mutate(
    extracellular_TM = case_when(
      grepl("extracellular|transmembrane", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    cell_membrane = case_when(
      grepl("cell membrane|extracellular|transmembrane|plasma", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    nucleus = case_when(
      grepl("nucleus|nucle", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    mitochondria = case_when(
      grepl("mitochondr", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    cytoplasm = case_when(
      grepl("cytoplasm|cytosol", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE),
    ER_Golgi = case_when(
      grepl("ndoplasmic|olgi", gene_ontology_cellular_component) == TRUE ~ TRUE,
      TRUE ~ FALSE))
```


###_i. plot extracellular/Transmembrane by comparison
```{r}
psites_regulated_extracellular_TM_comparison_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = extracellular_TM ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous( expand = c(0,0)) +
  alexis_theme()

psites_regulated_extracellular_TM_comparison_Imputation_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_extracellular_TM_comparison_Imputation_wSD.png", plot = psites_regulated_extracellular_TM_comparison_Imputation_wSD, scale= 0.4, width = 12, height = 12)

psites_regulated_extracellular_TM_comparison_fill_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = extracellular_TM ), position = "fill", color = "black") +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25),
        legend.title = element_text(size = 14))

psites_regulated_extracellular_TM_comparison_fill_Imputation_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_extracellular_TM_comparison_fill_Imputation_wSD.png", plot = psites_regulated_extracellular_TM_comparison_fill_Imputation_wSD, scale= 0.4, width = 10, height = 12)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_extracellular_TM_comparison_fill_Imputation_wSD.pdf", plot = psites_regulated_extracellular_TM_comparison_fill_Imputation_wSD, scale= 0.4, width = 8, height = 8)
```

###_ii. plot cell membrane by comparison
```{r}
psites_regulated_membrane_comparison_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = cell_membrane ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous( expand = c(0,0)) +
  alexis_theme()

psites_regulated_membrane_comparison_Imputation_wSD



psites_regulated_membrane_comparison_fill_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = cell_membrane ), position = "fill", color = "black") +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25),
        legend.title = element_text(size = 14))

psites_regulated_membrane_comparison_fill_Imputation_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_membrane_comparison_fill_Imputation_wSD.png", plot = psites_regulated_membrane_comparison_fill_Imputation_wSD, scale= 0.4, width = 10, height = 12)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_membrane_comparison_fill_Imputation_wSD.pdf", plot = psites_regulated_membrane_comparison_fill_Imputation_wSD, scale= 0.4, width = 12, height = 12)
```
###_iii. plot cytosol by comparison
```{r}
psites_regulated_cytoplasm_comparison_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = cytoplasm ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous( expand = c(0,0)) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25))

psites_regulated_cytoplasm_comparison_Imputation_wSD



psites_regulated_cytoplasm_comparison_fill_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = cytoplasm ), position = "fill", color = "black") +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25),
        legend.title = element_text(size = 14))

psites_regulated_cytoplasm_comparison_fill_Imputation_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_cytoplasm_comparison_fill_Imputation_wSD.png", plot = psites_regulated_cytoplasm_comparison_fill_Imputation_wSD, scale= 0.4, width = 10, height = 12)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_cytoplasm_comparison_fill_Imputation_wSD.pdf", plot = psites_regulated_cytoplasm_comparison_fill_Imputation_wSD, scale= 0.4, width = 12, height = 12)
```
###_iv. plot nucleus by comparison
```{r}
psites_regulated_nucleus_comparison_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = nucleus ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous( expand = c(0,0)) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25))

psites_regulated_nucleus_comparison_Imputation_wSD



psites_regulated_nucleus_comparison_fill_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = nucleus ), position = "fill", color = "black") +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25),
        legend.title = element_text(size = 14))

psites_regulated_nucleus_comparison_fill_Imputation_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_nucleus_comparison_fill_Imputation_wSD.png", plot = psites_regulated_nucleus_comparison_fill_Imputation_wSD, scale= 0.4, width = 10, height = 12)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_nucleus_comparison_fill_Imputation_wSD.pdf", plot = psites_regulated_nucleus_comparison_fill_Imputation_wSD, scale= 0.4, width = 12, height = 12)
```


###_v. plot mitochondira by comparison
```{r}
psites_regulated_mitochondria_comparison_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = mitochondria ), color = "black") +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
  scale_y_continuous( expand = c(0,0)) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25),
        legend.title = element_text(size = 14))

psites_regulated_mitochondria_comparison_Imputation_wSD



psites_regulated_mitochondria_comparison_fill_Imputation_wSD <- ggplot(data = locations_diff_df_wImputation %>% filter(abs(diff) > 1) %>% filter(adj_pval < 0.05) %>% filter(comparison %in% c("EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min" )) %>% mutate(comparison = fct_relevel(comparison,"EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min","EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"  ))) +
  geom_bar(mapping = aes(x = comparison, fill = mitochondria ), position = "fill", color = "black") +
  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
  scale_fill_brewer(palette = "RdGy", direction = -1) +
   alexis_theme() +
  theme(axis.text.x = element_text(angle = -60,   hjust = 0.1 , vjust = 0.25),
        legend.title = element_text(size = 14))

psites_regulated_mitochondria_comparison_fill_Imputation_wSD

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_mitochondria_comparison_fill_Imputation_wSD.png", plot = psites_regulated_mitochondria_comparison_fill_Imputation_wSD, scale= 0.4, width = 10, height = 12)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/psites_regulated_mitochondria_comparison_fill_Imputation_wSD.pdf", plot = psites_regulated_mitochondria_comparison_fill_Imputation_wSD, scale= 0.4, width = 12, height = 12)

```
#----------------------------------------------
#17. KEYWORD ID analysis (DISTRIBUTION OF PROTEIN FUNCTION PER CLUSTER)
Divergent regulation analysis to compare to Olsen 2006
start with zscore_cmeans_clustering_matrix_reps_ordered_df1

group_by gene, then maybe n_distinct(clusters), then percentage of genes with greater than 1 cluster represented. 
This will be just within regulated pY data!

I could maybe even get fancy with it and calculate percentages split by prior annotation of genes or sites in databases. This would just add more commentary pointing to we are getting a deeper look at the same trends or different newer trends.
###### . . . . differently regulated pY sites within same gene
```{r}
ratio_differently_reg_pY_within_protein <-  zscore_cmeans_clustering_matrix_reps_ordered_df1 %>%
  distinct(gene_ref, gene, cluster) %>%  #add in overlap_my_data if I want to split by annotation status
  group_by(gene) %>%
  summarize(
    n_pY_sites_per_gene = n_distinct(gene_ref),
    n_differently_regulated_pYsites_per_gene = n_distinct(cluster)) %>%
  ungroup() %>%
  mutate(
    differently_reg_pY_site_per_gene_type = case_when(
      n_pY_sites_per_gene == 1 ~ "only_1_site",
      n_pY_sites_per_gene > 1 & n_differently_regulated_pYsites_per_gene > 1 ~ "yes",
      n_pY_sites_per_gene > 1 & n_differently_regulated_pYsites_per_gene == 1 ~ "no")) %>%
  group_by(differently_reg_pY_site_per_gene_type) %>%
  summarize(
    n_genes = n() ) %>%
  pivot_wider(names_from = differently_reg_pY_site_per_gene_type, values_from = n_genes) %>%
  mutate(
    total_genes = sum(yes, no, only_1_site),
    total_genes_gt1pYsite = sum(yes, no)) %>%
  pivot_longer(cols = c("yes","no", "only_1_site"), names_to = c("differently_reg_pY_site_per_gene_type"), values_to = "n_genes") %>%
  mutate(
    pct_diff_reg_gt1pYsite = signif(((n_genes / total_genes_gt1pYsite) * 100), digits = 2),
    pct_diff_reg_all = signif(((n_genes / total_genes)* 100), digits = 2))


```

##### . . . . keyword cluster distribution
```{r}
keyword_cluster_distribution <- conversion %>% 
  separate(ref, into = c("reference", "psite"), sep = "_", remove = FALSE) %>% 
  filter(!is.na(cluster)) %>% 
  # left_join(y = locations_FASTA_df, by = "reference") %>% 
  left_join(y = master_FASTA, by = "reference") %>% 
  left_join(y = human_fasta_2024 %>% distinct(reference, full_protein_sequence, protein_names), by = c("reference", "full_protein_sequence")) %>% 
  mutate(
    functional_group = case_when(
      grepl("KW-0418", keyword_id) == TRUE ~ "kinases",
      grepl("KW-0343", keyword_id) == TRUE | grepl("guanine nucleotide exchange factor", protein_names) == TRUE ~ "GEFs &\n GAPs",
      grepl("KW-0805", keyword_id) == TRUE ~ "transcriptional\nregulators",
      grepl("KW-0010|KW-0678", keyword_id) == TRUE ~ "transcription\nfactors",
      grepl("KW-0832|KW-0833", keyword_id) == TRUE ~ "ubiquitin\nligases",
      grepl("KW-0009", keyword_id) == TRUE ~ "actin\nbinding",
      grepl("KW-0694", keyword_id) == TRUE ~ "RNA\nbinding" ,
      TRUE ~ "other", 
      is.na(keyword_id) ~ "other")) %>% 
  # filter(!is.na(functional_group)) %>% 
  mutate(functional_group = fct_relevel(
    functional_group, "kinases","GEFs &\n GAPs","transcriptional\nregulators", "transcription\nfactors",
    "ubiquitin\nligases","actin\nbinding","RNA\nbinding" ,"other" )) %>% 
  group_by(functional_group) %>% 
  mutate(
    num_pY_sites = n(),
    number_position = 1.05) %>% 
  ungroup()


kinases_cluster_distribution <- ggplot(data = keyword_cluster_distribution %>% filter(functional_group == "kinases")) + 
  geom_bar(mapping = aes(x = functional_group, fill = as.factor(cluster) ), position = "fill") + 
  alexis_theme()+ 
  scale_fill_manual(values = c("#081D58","#225EA8","#41B6C4", "#C7E9B4"))

kinases_cluster_distribution


#all keyword distributions
# plot_all_keyword_cluster_distribution <- ggplot(data = keyword_cluster_distribution) + 
#   geom_bar(mapping = aes(x = functional_group, fill = as.factor(cluster)), position = "fill") +
#   facet_wrap(facets = vars(functional_group), scales = "free_x") + 
#   scale_fill_manual(values = c("#081D58","#225EA8","#41B6C4", "#C7E9B4")) +
#   alexis_theme()
# 
# plot_all_keyword_cluster_distribution


#ordered by unique pY sites per functional group ------------------------
plot_all_keyword_cluster_distribution_orderedbycounts <- ggplot(data = keyword_cluster_distribution %>% mutate(functional_group= fct_reorder(functional_group, num_pY_sites))) + 
  geom_bar(mapping = aes(x = functional_group, fill = as.factor(cluster)), position = "fill") +
  geom_text(mapping = aes(x = functional_group, y = number_position-0.02, label = paste (num_pY_sites)), size = 4.2, hjust = 0.5, lineheight = 0.6) +
  geom_text(data = tibble(x = 4.5, y = 1.12, label = "unique pY sites per protein function"), mapping = aes(x = x, y = y, label = label), size = 4.5, hjust = 0.5, lineheight = 0.6, inherit.aes = FALSE, fontface = "bold") +
  ylab("ratio unique pY sites") +
  xlab("protein function groups") +
  scale_fill_manual(values = c("#081D58","#225EA8","#41B6C4", "#C7E9B4"), name = "cluster") +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -60, vjust = 0.85, hjust = 0, size = 13, family = "sans", lineheight = 0.65),
        axis.title = element_text(face = "bold", family = "sans", size = 15),
        legend.title = element_text(size = 12, family = "sans", face = "bold"),
        legend.text = element_text(size = 12, family = "sans")) +
  scale_y_continuous(limits = c(0, 1.2), expand = c(0,0), breaks = c(seq(0, 1, 0.25)))

plot_all_keyword_cluster_distribution_orderedbycounts

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/clusters_functional_categories_ratio_orderedbycount.png", plot = plot_all_keyword_cluster_distribution_orderedbycounts , width = 12, height = 12, scale =0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/clusters_functional_categories_ratio_orderedbycount.pdf", plot = plot_all_keyword_cluster_distribution_orderedbycounts , width = 14, height = 12, scale =0.4)

#ordered by functional group ------------------------
plot_all_keyword_cluster_distribution <- ggplot(data = keyword_cluster_distribution) + 
  geom_bar(mapping = aes(x = functional_group, fill = as.factor(cluster)), position = "fill") +
  geom_text(mapping = aes(x = functional_group, y = number_position, label = paste (num_pY_sites)), size = 3, hjust = 0.5, lineheight = 0.6) +
  geom_text(data = tibble(x = 5, y = 1.15, label = "unique pY sites per category"), mapping = aes(x = x, y = y, label = label), size = 3.5, hjust = 0.5, lineheight = 0.6, inherit.aes = FALSE) +
  ylab("ratio unique pY sites") +
  
  scale_fill_manual(values = c("#081D58","#225EA8","#41B6C4", "#C7E9B4"), name = "cluster") +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -60, vjust = 0.75, hjust = 0, size = 12, family = "sans", lineheight = 0.65),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(size = 12, family = "sans")) +
  scale_y_continuous(limits = c(0, 1.2), expand = c(0,0), breaks = c(seq(0, 1, 0.25)))

plot_all_keyword_cluster_distribution

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/clusters_functional_categories_ratio.png", plot = plot_all_keyword_cluster_distribution , width = 12, height = 8, scale =0.4)


#total counts -----------------------------------
plot_all_keyword_cluster_distribution_counts <- ggplot(data = keyword_cluster_distribution) + 
  geom_bar(mapping = aes(x = functional_group, fill = as.factor(cluster)), position = "stack") +
  # facet_wrap(facets = vars(functional_group), scales = "free_x") + 
  scale_fill_manual(values = c("#081D58","#225EA8","#41B6C4", "#C7E9B4"), name = "cluster") +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = -60, vjust = 0.75, hjust = 0, size = 12, family = "sans", lineheight = 0.65),
        legend.title = element_text(size = 12, family = "sans"),
        legend.text = element_text(size = 12, family = "sans")) +
  scale_y_continuous(expand = c(0,0)) + 
  ylab("regulated pY sites")
  # scale_y_continuous(limits = c(0, 1), expand = c(0,0), breaks = c(seq(0, 1, 0.25)))

plot_all_keyword_cluster_distribution_counts

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/clusters_functional_categories_counts.png", plot = plot_all_keyword_cluster_distribution_counts , width = 12, height = 8, scale =0.4)


```

#===============================
#### (gene_diff_abundance_3xDB) dataframe
compare genes on which we detect pY in this study relative to 3 databases of EGF stimulation responses
moved this code chunk up in order to use dataframe to annotate heatmaps
defined again later with counts for plotting too
just gene level matching. no requirement for gene to have pY in the database.
```{r}
#combine all three databases of genes annotated to be EGF responsive ------------
WP437 <- c('NOS3','COX2','SHC1','STAT5A','RALA','NEDD4','ELK4','MAPK1','MAPK8','ARHGEF1','STMN1','STAT1','EPS15L1','SH3GL3','EGF','INPP5D','PTPN5','ATF1','GRB10','ERRFI1','GRIM19','MAP3K1','PTK6','RPS6KA2','CSK','PCNA','KRAS','LIMK2','RASA1','ARF6','IQGAP1','EGFR','SP1','BRAF','DOK2','PTPRR','CRK','SH2D2A','MAPK9','RPS6KA3','RIN1','CAV2','E2F1','VAV2','SOS2','PTPN12','MTOR','NCK2','MAP3K3','RALGDS','VAV3','CAMK2A','STAT3','MAPK3','SOS1','GAB2','RAP1A','JAK1','CDC42','NCOA3','ATXN2','RAB5A','RPS6KB1','MAPK14','ASAP1','SYNJ1','MAP2K1','RAF1','EPN1','NCK1','STAMBP','CAV1','STAM2','HGS','MAP2K2','CREB1','PLCG1','ERBB2','SPRY2','INPPL1','EIF4EBP1','MAP4K1','RICTOR','USP6NL','RPS6KA5','PTK2B','PIK3R2','PLD2','EPS8','RAC1','ABI1','PLSCR1','PIK3R1','MEF2D','GAB1','PLCE1','PLD1','DNM1','JUN','PIAS3','SH3GL2','RPS6KA1','ROCK1','MAP3K4','PRKCD','AP2B','AKT1','FOXO1','VAV1','PRKCZ','RALB','FOS','PRKCI','PRKCA','SRC','ITCH','ABL1','RALBP1','MAPK7','REPS2','JUND','GRB2','EPS15','USP8','AP2A1', 'AP2B1', 'HRAS','PDPK1','IQSEC1','PEBP1','SH3KBP1','TNK2','PTPN11','AP2S1','PRKCB','FOXO4','FOSB','PTEN','NEDD8','STAM','GJA1','CRKL','JAK2','MAP2K5','BCAR1','MAP3K2','ELK1','STAT5B','PIK3C2B','STXBP1','CBLB','CBL','CBLC','PAK1','CFL1','PTK2','AP2M1','MEF2A','PXN','MEF2C')

#turn wiki pathways into a dataframe
WP437_gene_df <- data.frame("gene" = WP437, "WP437" = TRUE)

#combine genes from all four database sources into a single dataframe
gene_3xDB_overlap <-  PSP_vs_PTMSigDB_EGF %>%   #exchanged for 'overlap_PSP_PTMSEA'
              # filter(mod_res == "Y") %>% # filter for only proteins with pY observed when possible. WP437 lacks site info
              # mutate(DB1 = "PSP|PTMSigDB|PpDIA") %>% 
              full_join(y = WP437_gene_df, by = "gene") %>% 
              distinct(gene, PSP, PTM_SEA,  WP437) %>% 
  pivot_longer(cols = c(PSP, PTM_SEA,  WP437), names_to = "DB") %>% 
  rename(present_in_DB = value) %>%
  filter(present_in_DB == TRUE)


#join with my data ----------------------------------------------------
gene_diff_abundance_3xDB <- foldchange_imputed_wSD %>%
  separate(gene_ref, into = c("gene", "mod_residue"), sep = "_", remove = FALSE) %>% 
  mutate(mod_res = str_sub(mod_residue, end = 1L)) %>% 
  # rename(mod_residue = modres_position) %>%
  filter(mod_res == "Y") %>% 
  filter(abs(diff) > 1) %>%
  filter (adj_pval <= 0.05) %>%
   
  mutate(my_data = TRUE) %>%
  full_join(y = gene_3xDB_overlap %>% mutate(DB4x = TRUE), by = "gene") %>% 
  # full_join(y = overlap_PSP_PTMSEA %>%
  #             filter(mod_res == "Y") %>% # filter for only proteins with pY observed when possible. WP437 lacks site info
  #             full_join(y = WP437_gene_df, by = "gene") %>% 
  #             distinct(gene) %>%
  #             mutate(DB4x = TRUE), by = c("gene") ) %>% 
  mutate(
    overlap_my_data = case_when(
      my_data == TRUE & DB4x ==TRUE ~ "both",
      my_data == TRUE & is.na(DB4x) ~ "this\nstudy",
      is.na(my_data) & DB4x ==TRUE ~ "DBs\nonly"),
    overlap_my_data = fct_relevel(overlap_my_data, "both", "this\nstudy", "DBs\nonly"))


```
#===============================



#---------------------------------------------
#18. Pathway specific heatmaps using imputed data
##_a.  EGF heat map 
z-scored & imputed based on mean w/o SD)
###__i. PSP
```{r}

# reorder columns
zscore_EGFR_df1 <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  # filter(gene %in% ((PSP_EGFR )$gene))
  filter(gene %in% ((PSP_EGFR %>% filter(mod_res == "Y"))$gene)) %>% 
  arrange(gene)
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix <- as.matrix(zscore_EGFR_df1[,4:33])

rownames(zscore_EGFR_matrix) <- zscore_EGFR_df1[,1]


#plot heatmap
zscore_EGFR_pheatmap <- pheatmap(zscore_EGFR_matrix , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         
         fontsize_row = 2,
         # annotation_row = row_annotations, annotation_colors = my_colour,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR.pdf", plot = zscore_EGFR_pheatmap , width = 10, height = 60, scale =0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR.png", plot = zscore_EGFR_pheatmap , width = 10, height = 20, scale = 0.8, limitsize = FALSE)
```

###__i. PTM-SEA = PTM-SigDB
```{r}

# reorder columns
zscore_EGFR_df1_PTMSigDB <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  # filter(gene %in% ((PSP_EGFR )$gene))
  filter(gene %in% ((EGFR1_pathway_PTMSigDB %>% filter(mod_res == "Y"))$gene)) %>% 
  arrange(gene)
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix_PTMSigDB <- as.matrix(zscore_EGFR_df1_PTMSigDB[,4:33])

rownames(zscore_EGFR_matrix_PTMSigDB) <- zscore_EGFR_df1_PTMSigDB[,1]


#plot heatmap
zscore_EGFR_pheatmap_PTMSigDB <- pheatmap(zscore_EGFR_matrix_PTMSigDB , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         
         fontsize_row = 2,
         # annotation_row = row_annotations, annotation_colors = my_colour,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_PTMSigDB.pdf", plot = zscore_EGFR_pheatmap_PTMSigDB , width = 10, height = 60, scale =0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_PTMSigDB.png", plot = zscore_EGFR_pheatmap_PTMSigDB , width = 10, height = 20, scale = 0.8, limitsize = FALSE)
```



###__ii. WP437 
Wikipathway 437 (WP437) is used by PTM-Navigator as one representation of EGF:EGFR signaling. 
I have extracted all gene names from WP437. Filtering shows which of the pathway genes I detect. 
I then show which sites (ideally just pY for this dataset) that I detect on these genes. 
```{r}
WP437 <- c('NOS3','COX2','SHC1','STAT5A','RALA','NEDD4','ELK4','MAPK1','MAPK8','ARHGEF1','STMN1','STAT1','EPS15L1','SH3GL3','EGF','INPP5D','PTPN5','ATF1','GRB10','ERRFI1','GRIM19','MAP3K1','PTK6','RPS6KA2','CSK','PCNA','KRAS','LIMK2','RASA1','ARF6','IQGAP1','EGFR','SP1','BRAF','DOK2','PTPRR','CRK','SH2D2A','MAPK9','RPS6KA3','RIN1','CAV2','E2F1','VAV2','SOS2','PTPN12','MTOR','NCK2','MAP3K3','RALGDS','VAV3','CAMK2A','STAT3','MAPK3','SOS1','GAB2','RAP1A','JAK1','CDC42','NCOA3','ATXN2','RAB5A','RPS6KB1','MAPK14','ASAP1','SYNJ1','MAP2K1','RAF1','EPN1','NCK1','STAMBP','CAV1','STAM2','HGS','MAP2K2','CREB1','PLCG1','ERBB2','SPRY2','INPPL1','EIF4EBP1','MAP4K1','RICTOR','USP6NL','RPS6KA5','PTK2B','PIK3R2','PLD2','EPS8','RAC1','ABI1','PLSCR1','PIK3R1','MEF2D','GAB1','PLCE1','PLD1','DNM1','JUN','PIAS3','SH3GL2','RPS6KA1','ROCK1','MAP3K4','PRKCD','AP2B','AKT1','FOXO1','VAV1','PRKCZ','RALB','FOS','PRKCI','PRKCA','SRC','ITCH','ABL1','RALBP1','MAPK7','REPS2','JUND','GRB2','EPS15','USP8','AP2A1','AP2B1', 'HRAS','PDPK1','IQSEC1','PEBP1','SH3KBP1','TNK2','PTPN11','AP2S1','PRKCB','FOXO4','FOSB','PTEN','NEDD8','STAM','GJA1','CRKL','JAK2','MAP2K5','BCAR1','MAP3K2','ELK1','STAT5B','PIK3C2B','STXBP1','CBLB','CBL','CBLC','PAK1','CFL1','PTK2','AP2M1','MEF2A','PXN','MEF2C')
# reorder columns
zscore_EGFR_WP437_df1 <- zscore_cmeans_clustering_matrix_reps_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>%
  # filter(gene %in% ((PSP_EGFR_WP437 )$gene))
  filter(gene %in% WP437) %>%
  left_join(y = WP437_EGFR_node_depths, by = "gene") %>% 
  arrange(depth)
  # arrange(gene)
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_WP437_matrix <- as.matrix(zscore_EGFR_WP437_df1[,4:33])

rownames(zscore_EGFR_WP437_matrix) <- zscore_EGFR_WP437_df1[,1]

#annotation matrix
annotation_WP437_depths_df <- zscore_EGFR_WP437_df1 %>%
  left_join(data_clustered_reps_df %>% select(gene_ref, cluster, membership_correlation), by = "gene_ref") %>% 
  mutate(depth = as.character(depth)) %>% 
  mutate(
      mod_res = str_sub(psite, end = 1L)) %>% 
    distinct(gene_ref, cluster, mod_res, depth)

#get the annotion contents into a matrix without the gene_ref ids, which will be added later as rownames
  row_annotations_WP437_matrix_df <- annotation_WP437_depths_df %>% 
    distinct(gene_ref, cluster, mod_res, depth) %>%
    select(cluster, mod_res, depth) %>% 
    as.matrix()

  
      #assign row names to be gene_ref
rownames(row_annotations_WP437_matrix_df) <- annotation_WP437_depths_df$gene_ref
    
#return matrix with row names into a dataframe
  #INPUT THIS FOR ROW ANNOTATIONS IN PHEATMAP
row_annotations_WP437_matrix_df <- as.data.frame(row_annotations_WP437_matrix_df)
  
    #colors for heatmap
#row annotation colors
my_colour_WP437 = list(
    mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
    cluster = c('1' = "#1B9E77", '2' = "#D95F02", '3'= "#7570B3", '4' = "#E7298A"),
    # EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    depth = c("0" = "chocolate4", "1" = "#9E0142","2" =  "#D53E4F","3" =  "#F46D43","4" =  "#FDAE61","5" =  "#FEE08B", "6" = "#FFFFBF", "7" = "#E6F598" ,"8" = "#ABDDA4" ,"9" = "#66C2A5", "10" = "#3288BD" ,"11" = "lightskyblue","12" =  "deepskyblue","13" =  "blue","14" =  "#5B12F6" ,"15" = "lightslateblue", "16" = "blueviolet", "17" =  "violet"))
# 

#plot heatmap
zscore_EGFR_WP437_pheatmap <- pheatmap(zscore_EGFR_WP437_matrix , cluster_cols = F, cluster_rows = F,
         cutree_rows = 10, cutree_cols = 5,
         colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         # clustering_distance_rows = "minkowski",
         
         fontsize_row = 6,
         annotation_row = row_annotations_WP437_matrix_df, annotation_colors = my_colour_WP437,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_WP437.pdf", plot = zscore_EGFR_WP437_pheatmap , width = 10, height = 40, scale =0.8)

#taller, less wide pdf-----------
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_WP437_taller.pdf", plot = zscore_EGFR_WP437_pheatmap , width = 10, height = 30, scale =0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_WP437.png", plot = zscore_EGFR_WP437_pheatmap , width = 10, height = 20, scale = 0.8, limitsize = FALSE)
```


```{r}
# custom_colors_spectral <- brewer.pal(11, "Spectral")
# 
# custom_colors_spectral
# 
# custom_colors_purples <- brewer.pal(9, "Purples")
# 
# custom_colors_purples
# 
# custom_colors_ylgn <- brewer.pal(9, "YlGn")
# 
# custom_colors_ylgn
```






#----------------------------------------------

#19. DATABASES (FULL PSP) VS. MY DATA:

##__a. read csv Uniprot fasta with cellular functions
```{r}
ascore_final_gene1_fxns_Imputation_noSD <- ascore_gene_clusters_Imputation_noSD %>% 
  left_join(y = fxns_fasta %>% select(-protein_names), by = c("reference"))
```


##__b. PSP_all vs. my data

###___i. dataframe
start with significant psites.
```{r}
PSP_all_vs_my_data <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>% 
  mutate(mod_residue = as.character(mod_residue)) %>% 
  left_join(y = (PSP_all %>%
                   # rename(reference = acc_id) %>%
                   mutate(mod_residue = str_sub(psite, start = 2L))  %>%
                   mutate(PSP_all = "in_PSP_all") ),
            by = c( "gene", "gene_ref", "mod_residue", "mod_res", "psite")) %>% 
  mutate(PSP_all = case_when(
    is.na(PSP_all) ~ "not_in_PSP_all",
    TRUE ~ PSP_all),
    is_significant = case_when(
      abs(diff) > 1 & adj_pval <= 0.05 ~ "significant",
      TRUE ~ "not_significant"),
    mod_residue = str_sub(psite, start = 2L)) %>%
  rename(n_obs_imputed = n_obs) %>% 
  filter(grepl("vs_EGF0min", comparison) == TRUE) %>% 
  separate(comparison, into = c("condition", "condition_2"), sep =  c("_vs_"), remove = FALSE) %>% 
  left_join(y =( ascore_gene_clusters_Imputation_noSD %>% select(condition, n_obs, cluster, median_norm_intensity, psite, gene) %>%  mutate(mod_residue = str_sub(psite, start = 2L))), by = c("gene", "condition", "mod_residue", "psite"))
```
dataframe fed into this code is assigned later in script. need to rectify!



###___i. plot PSP_all vs. my data 
```{r}
#-----------------------------------------
plot_PSP_all_vs_my_data <- ggplot(data = PSP_all_vs_my_data %>% filter(grepl("vs_EGF0min", comparison) == TRUE) %>% 
                                    distinct(comparison, PSP_all, n_obs, gene_ref, mod_res, is_significant)) +
  geom_bar(mapping = aes(x = PSP_all, fill = is_significant), color = "black") +
  facet_wrap(vars(comparison)) +
  alexis_theme() +
  scale_fill_viridis_d(direction = -1)

plot_PSP_all_vs_my_data


#-------------------------------
plot_PSP_all_vs_my_data_nobs <- ggplot(data = PSP_all_vs_my_data %>% mutate(n_obs = as.factor(n_obs))) +
  geom_bar(mapping = aes(x = PSP_all, fill = n_obs), position = "dodge") +
  facet_wrap(vars(comparison)) +
  alexis_theme() +
  scale_fill_viridis_d()

plot_PSP_all_vs_my_data_nobs


#only not in PSP_all --------------------------------------
plot_PSP_all_vs_my_data_nobs_notinPSP <- ggplot(data = PSP_all_vs_my_data %>% mutate(n_obs = as.factor(n_obs)) %>% filter(PSP_all == "not_in_PSP_all") %>% filter(!is.na(n_obs)) %>% distinct(comparison, PSP_all, n_obs, gene_ref, mod_res) %>% mutate(comparison = fct_relevel(comparison, "EGF1min_vs_EGF0min", "EGF3min_vs_EGF0min", "EGF5min_vs_EGF0min", "EGF15min_vs_EGF0min"))) +
  geom_bar(mapping = aes(x = comparison,  fill = mod_res), position = "dodge", size = 0.1, color = "black") +
  facet_wrap(vars(n_obs)) +
  alexis_theme() +
  scale_color_brewer(palette = "Purples") +
  scale_fill_viridis_d(direction = -1) +
  theme(axis.text.x = element_text(angle = -75, size = 12, vjust = 0.5, hjust = 0)) +
  # scale_y_continuous(limits = c(0, 20), expand = c(0,0), breaks = seq(0, 20, 5))+
  expand_limits(limits =c(0,0))

plot_PSP_all_vs_my_data_nobs_notinPSP

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_PSP_all_vs_my_data_nobs_notinPSP.png", plot = plot_PSP_all_vs_my_data_nobs_notinPSP, width = 12, height = 12, scale = 0.4)

```
Cool! we have 


##__c. NOT in PSP
```{r}
not_in_PSP <- PSP_all_vs_my_data %>%
  # mutate(n_obs = as.factor(n_obs)) %>%
  filter(PSP_all == "not_in_PSP_all") %>%
  filter(!is.na(n_obs)) %>%
  distinct(comparison, PSP_all, n_obs,  gene_ref, mod_res, cluster) %>% 
  left_join(y = ascore_final_gene1_fxns_Imputation_noSD %>%
              select(gene_ref, mod_res, reference,
                     # protein_names,
                     gene_names:gene_ontology_cellular_component) %>% 
              mutate(gene_ref = str_replace_all(gene_ref, " ", "_")), by = c("gene_ref", "mod_res"))

net_unique_pYsites_not_in_PSP <- not_in_PSP %>% distinct(gene_ref)
```

###___i. write NOT_in_PSP to csv
```{r}
write_csv(x = not_in_PSP,"modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/not_in_PSP.csv")

#append functions ---------------------
#SUPP FILE 10
not_in_PSP_fxns <- not_in_PSP %>% 
  distinct(reference,  gene_ref) %>% 
  left_join(y = fxns_fasta, by = "reference") %>% 
  select(reference, gene_names, gene_ref,protein_names, function_cc, subcellular_location_cc)

write_csv(x = not_in_PSP_fxns,"modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/not_in_PSP_withfxns.csv")
```

###___ii. dataframe: unique new sites
```{r}
unique_not_in_PSP <- not_in_PSP %>%
  filter(n_obs %in% c(3, 4, 5, 6)) %>% 
  distinct(gene_ref) %>% 
  separate(col = "gene_ref", into = c("gene", "psite"), sep = "_", remove = FALSE)  
  

unique_not_in_PSP_5or6reps <- not_in_PSP %>%
  filter(n_obs %in% c( 5, 6)) %>% 
  distinct(gene_ref) %>% 
  separate(col = "gene_ref", into = c("gene", "psite"), sep = "_", remove = FALSE) 
#67 phosphosites measured in at least 3 of 6 replicates per condition with significant change relative to untreated, but not in Phosphosite plus. 


# pY only ---------------------------------
unique_not_in_PSP_pY <- unique_not_in_PSP %>% 
  filter(str_sub(psite, end = 1L) == "Y")
```
Nterm_mod_ascore_pY
###___iii. plot intensity of novel pY sites
```{r}
plot_intensity_rank_novel_pY_sites <- ggplot() +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>% 
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(!gene_ref %in% unique_not_in_PSP_pY$gene_ref) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "grey50", alpha = 0.5, shape = 21, size = 1) +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>% 
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, ref, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(ref %in% Nterm_mod_ascore_pY$ref) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "orange", alpha = 1, shape = 21, size = 4) +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(gene_ref %in% unique_not_in_PSP_pY$gene_ref) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "blue", alpha = 0.5, shape = 21, size = 1.2, stroke = 2) +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(gene_ref %in% c("LIMD1_Y4", "TKT_Y4", "NECAP_Y6", "RAB14_Y6", "STX12_Y9", "PLCG2_Y13", "GRB10_Y15")) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "red", alpha = 1, shape = 21, size = 2, stroke = 2) +
  ylab(expression(log[2]~(intensity))) + xlab("rank intensity") +
  theme_bw(18) +
  facet_wrap(facets = vars(condition))

plot_intensity_rank_novel_pY_sites

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_intensity_rank_novel_pY_sites.pdf", plot = plot_intensity_rank_novel_pY_sites, width = 14, height = 8, scale = 0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_intensity_rank_novel_pY_sites.png", plot = plot_intensity_rank_novel_pY_sites, width = 14, height = 8, scale = 0.6)
```
This shows that the novel pY sites are relatively low abundance from all the pY sites we measured.

```{r}

all_nterm_mod_peptide_dfs <- ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(gene_ref %in% c("LIMD1_Y4", "TKT_Y4", "NECAP2_Y6", "RAB14_Y6", "STX12_Y9", "PLCG2_Y13", "GRB10_Y15")) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition))

plot_intensity_rank_novel_pY_sites2 <- ggplot() +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
               filter(mod_res == "Y") %>%
               group_by(condition, gene_ref) %>%
               mutate(median_condition_intensity = median(median_norm_intensity)) %>%
               ungroup() %>%
               distinct(condition, gene_ref, median_condition_intensity) %>%
               group_by(condition) %>%
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>%
               ungroup() %>%
               filter(!gene_ref %in% unique_not_in_PSP_pY$gene_ref) %>%
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "grey50", alpha = 0.3, shape = 21, size = 0.75) +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>% 
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, ref, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(ref %in% Nterm_mod_ascore_pY$ref) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "orange", alpha = 0.6, shape = 21, stroke = 3, size = 2) +
  # geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
  #              mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
  #              filter(mod_res == "Y") %>% 
  #              group_by(condition, gene_ref) %>% 
  #              mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
  #              ungroup() %>% 
  #              distinct(condition, gene_ref, median_condition_intensity) %>% 
  #              group_by(condition) %>% 
  #              mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
  #              ungroup() %>% 
  #              filter(gene_ref %in% unique_not_in_PSP_pY$gene_ref) %>% 
  #              mutate(
  #              condition = case_when(
  #                condition == "EGF0min" ~ "untreated",
  #                TRUE ~ condition),
  #              condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
  #            aes(x = rank_condition_intensity, y = median_condition_intensity),color = "blue", alpha = 0.5, shape = 21, size = 1.2, stroke = 2) +
  geom_point(data = ascore_final_gene1_fxns_Imputation_noSD %>%
               mutate(gene_ref = str_replace_all(gene_ref, " ", "_")) %>%
               filter(mod_res == "Y") %>% 
               group_by(condition, gene_ref) %>% 
               mutate(median_condition_intensity = median(median_norm_intensity)) %>% 
               ungroup() %>% 
               distinct(condition, gene_ref, median_condition_intensity) %>% 
               group_by(condition) %>% 
               mutate(rank_condition_intensity = rank(median_condition_intensity)) %>% 
               ungroup() %>% 
               filter(gene_ref %in% c("LIMD1_Y4", "TKT_Y4", "NECAP2_Y6", "RAB14_Y6", "STX12_Y9", "PLCG2_Y13", "GRB10_Y15")) %>% 
               mutate(
               condition = case_when(
                 condition == "EGF0min" ~ "untreated",
                 TRUE ~ condition),
               condition = fct_relevel(condition, "untreated", "EGF1min", "EGF3min", "EGF5min", "EGF15min")),
             aes(x = rank_condition_intensity, y = median_condition_intensity),color = "blue", alpha = 0.8, shape = 21, size = 2, stroke = 1.5) +
  ylab(expression(log[2]~(intensity))) + xlab("rank intensity") +
  theme_bw(18) +
  facet_wrap(facets = vars(condition))

plot_intensity_rank_novel_pY_sites2

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_intensity_rank_novel_pY_sites2.pdf", plot = plot_intensity_rank_novel_pY_sites2, width = 14, height = 8, scale = 0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_intensity_rank_novel_pY_sites2.png", plot = plot_intensity_rank_novel_pY_sites2, width = 14, height = 8, scale = 0.6)
```



#=========================================
#20. RETURN TO GENE-LEVEL 3xDB ANALYSIS NOW WITH CLUSTER ANNOTATIONS
LIKELY FINE TO TRASH THIS.
## - - - append clusters to newly implicated genes
I do think some could be wrong protein group assignment, like GAGE2E, but I think GAGE2E = GAGE1 or GAGE5 would still be new for EGF stimulation. Further, could 139 genes be wrongly assigned by comet? Did I mis-assign or mis-join gene to reference?
Or, are these pY sites low abundance, is the stastical significance reasonable?
```{r}
# new_EGF_genes <- gene_diff_abundance_3xDB_pYfound %>%
#             filter(overlap_my_data == "this\nstudy") %>% 
#   left_join(y = conversion, by = "gene_ref")

new_EGF_genes <- gene_diff_abundance_3xDB %>%
            filter(overlap_my_data == "this\nstudy") %>% 
  left_join(y = conversion %>%
              separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE),
            by = "gene")
```

## - - - write csv of new genes, with pY detected on them
```{r}
write_csv(x = new_EGF_genes,file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/genes_wpY_not_in3xDBs.csv")
```

## - - - plot cluster distribution of pY sites on genes not in any of the 4 database sources of EGF stimulation signature. 
--just counts
```{r}
plot_cluster_membership_of_pYsites_on_new_EGF_genes_counts <- ggplot(data =  gene_diff_abundance_3xDB %>%
                                                                left_join(y = conversion,  by = "gene_ref") %>% 
                                                                filter(!is.na(cluster)) %>% 
                                                                distinct(gene, gene_ref, cluster, overlap_my_data))+
  geom_bar(mapping = aes(x = as.factor(cluster), fill = overlap_my_data), show.legend = TRUE, position = "dodge", alpha = 0.5, color = "black") +
  alexis_theme() +
  guides(fill=guide_legend(title="gene annotation type")) +
  scale_fill_manual(values =c( "lightblue", "darkblue")) +
  ylab("unique pY sites") +
  scale_y_continuous(expand = c(0,0.1), limits = c(0, 225))


plot_cluster_membership_of_pYsites_on_new_EGF_genes_counts
```

--percentages
```{r}
df_percent_pYsites_on_new_genes_per_cluster <- gene_diff_abundance_3xDB %>%
                                left_join(y = conversion,  by = "gene_ref") %>%
                                filter(!is.na(cluster)) %>% 
                                distinct(gene, gene_ref, cluster, overlap_my_data) %>% 
                                group_by(cluster) %>% 
                                mutate(
                                  total_pY_sites_per_cluster = n(),
                                  total_genes_per_cluster = n_distinct(gene)) %>% 
                                ungroup() %>% 
                                group_by(cluster, overlap_my_data) %>% 
                                mutate(
                                  n_pYsites_per_annotation_type = n(), 
                                  percent_pYsites_per_cluster = n_pYsites_per_annotation_type / total_pY_sites_per_cluster * 100) %>% 
                                  ungroup() %>% 
                                distinct(overlap_my_data, cluster, n_pYsites_per_annotation_type, percent_pYsites_per_cluster,
                                         total_pY_sites_per_cluster, total_genes_per_cluster) %>%
                                  group_by(cluster) %>%  
                                  mutate(text_position_x = case_when(
                                    overlap_my_data == "both" ~ cluster -0.23,
                                    overlap_my_data == "this\nstudy" ~ cluster + 0.23)) %>% 
                                  ungroup()


plot_cluster_membership_of_pYsites_on_new_EGF_genes_pcts <- ggplot(data =  df_percent_pYsites_on_new_genes_per_cluster)+
  geom_col(mapping = aes(x = as.factor(cluster), y = percent_pYsites_per_cluster, fill = overlap_my_data), show.legend = TRUE, position = "dodge", alpha = 0.6, color = "black") +
  geom_text (mapping = aes(x = text_position_x, y = percent_pYsites_per_cluster - 5, label = paste(round(percent_pYsites_per_cluster), "%", sep = "")), show.legend = FALSE, size = 3.7) +
  # geom_text(data = tibble(x = c(1, 2, 3, 4), y = c(95, 95, 95, 95), label = c("cluster 1", "cluster 2", "cluster 3", "cluster 4")), mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, face = "bold", family = "sans") +
   geom_text (mapping = aes(x = cluster, y = 90, label = paste("cluster ", cluster ,"\nn = ", total_pY_sites_per_cluster,"\npY sites", sep = "")), show.legend = FALSE, size =4, lineheight = 0.75) +
  geom_text (mapping = aes(x = cluster, y = 78, label = paste("\nn = ", total_genes_per_cluster,"\ngenes", sep = "")), show.legend = FALSE, size =4, lineheight = 0.75) +
  alexis_theme() +
  guides(fill=guide_legend(title="gene\nannotation")) +
  scale_fill_brewer(palette = "Dark2") +
  # scale_fill_manual(values =c( "lightblue", "darkblue")) +
  # scale_color_manual(values =c( "black", "black")) +
  ylab("percent pY sites per cluster") +
  xlab("cluster") +
  theme(legend.title = element_text(size = 12, hjust = 0.5, family = "sans")) +
  scale_y_continuous(expand = c(0,0), limits = c(0, 100))


plot_cluster_membership_of_pYsites_on_new_EGF_genes_pcts

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cluster_membership_of_pYsites_on_new_EGF_genes_pcts.png", 
       plot = plot_cluster_membership_of_pYsites_on_new_EGF_genes_pcts, width = 12, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_cluster_membership_of_pYsites_on_new_EGF_genes_pcts.pdf", plot = plot_cluster_membership_of_pYsites_on_new_EGF_genes_pcts, width = 12, height = 12, scale = 0.4)

```
We assessed distribution of pY sites on genes previously annotated to contribute to the EGF stimulation response across 4 different sources of signature annotation (Phosphosite Plus, PTMSigDB, WP437, PhosphopeDIA ErbB PRM assay). 

Given that we detected many pY sites not previously detected in two well-accepted phosphosignaling annotation databases, we wanted to further investigate if the pY sites fell on genes already annotated in those databases or if the pY sites were detected on proteins altogether not previously annotated as part of the EGF stimulation response. This would address two questions, first, this assesses if majority of the site discrepancies are due to phosphosite localization issues. For example, if all of the pY sites were on the same genes, but slightly differently localized, we would expect majority of the sites to be on the same genes as in the databases. (As for incorrect gene assignment, could this be assessed by relative comparison to global phospho? This would assume majority of the global phospho sites have been detected, AND annotated, which is not certain. Instead comparison to global phospho would indicate whether a more sensitive pY enrichment detects novel sites due to lack of sensitive methods in the field, or if the gene assignment by search tool, i.e., comet, had high error)).
Majority (two-thirds) of cluster 1, 3 and 4 pY sites are on previously annotated genes. while a sizeable portion of each clusters 1, 3 and 4 pY sites are on genes not previously annotated as part of the EGF stimulation response. 

This split of novel genes was more drastic for cluster 2 in which about half (48%) of the pY sites are on genes not previously annotated. 







## - - - Characterize pY sites on new genes in EGF signaling response
We identify pY sites on 139 genes for which the genes were not previously implicated in EGF response according to the four different databases described above. This is quite a lot of genes newly implicated in EGF stimulation. I want to both crosscheck results for potential assignment errors as well as characterize these genes. We propose simple cursory characterization of number of pY sites per gene, Number of pSTY sites from global enrichment per gene, detection in total proteome data as well as gene ontology annotation status of these groups split by cluster. 

### .  .  . .  . . pY sites per gene 
```{r}
df_pY_sites_per_new_genes_3xDB <- gene_diff_abundance_3xDB %>%
                                left_join(y = conversion, by = "gene_ref") %>% 
                                filter(!is.na(cluster)) %>% 
  #count up pY sites per gene, split by genes annotated or not in 4X EGF DB
  distinct(gene, overlap_my_data, gene_ref) %>% 
  group_by( gene) %>% 
  mutate(n_pYsites_per_gene = n_distinct(gene_ref)) %>% 
  ungroup()

```

```{r}
plot_n_pYsites_per_gene <- ggplot(data = df_pY_sites_per_new_genes_3xDB %>%
                                    distinct(overlap_my_data,gene, n_pYsites_per_gene)) + #could add in cluster w/facet if desired.
  geom_bar(mapping = aes(x  = n_pYsites_per_gene,fill = overlap_my_data), position = "dodge") +
  # facet_grid(rows = vars(overlap_my_data), cols = vars(cluster)) +
  alexis_theme() +
  scale_x_continuous(limits = c(0, 13), breaks = c(seq(0, 13, 1)), expand = c(0,0.1)) +
  scale_y_continuous(limits = c(0, 400), breaks = (seq(0, 400, 50)), expand = c(0, 0))
     

plot_n_pYsites_per_gene          
```
_MYO1E 7 pY sites_
MYO1E is the gene with 7 pY sites in which the gene is not included in 4x database annotations. There is a 2019 paper detailing the role of MYO1E in PI3K signaling and podosome morphology. Therefore it is plausible these sites are real. This also suggests the PI3K signaling pathway is being activated. The isoform data suggests all pY sites are on individual peptides.  (Zhang, Y.; Cao, F.; Zhou, Y.; Feng, Z.; Sit, B.; Krendel, M.; Yu, C.-H. Tail Domains of Myosin-1e Regulate Phosphatidylinositol Signaling and F-Actin Polymerization at the Ventral Layer of Podosomes. Mol. Biol. Cell 2019, 30 (5), 622-635. https://doi.org/10.1091/mbc.E18-06-0398.)
The pY sites have been observed before and recorded in phosphosite plus. This suggests the sites could be lacking connection to EGF signaling or related crosstalk (i.e PI3K signaling arm).


_FAM83B_Y685, FAM83B_Y683, FAM83B_Y343_
Check if these are have the Y683/Y685 isoform. 
Response type = cluster 1 and 4:

_ERBIN_Y1293, ERBIN_Y1104, ERBIN_Y884_



## - - - GO analysis of new genes
I could break up the data for GO analysis by both clusters and DB annotation (both 4XDB & this study VS. just this study).
I will start by breaking up by both clusters and database annotation.
###___i. focus on cell compartment
Define genes to include (by reference) for input into Gene ontology searching.
```{r}
# join conversion dataframe to 'gene_diff_abundance_3xDB' to append cluster information
GO_input_df_new_genes <- gene_diff_abundance_3xDB %>% 
  left_join(y = conversion,
            by = "gene_ref") %>% 
  separate(ref, into = c("reference", "psite_del"), sep = "_", remove = FALSE) %>% 
  select(-psite_del)

#input is your vector of protein ids

#--------------------------------------------------------------------------------------------------------
  ##cluster 1, both in this study and >= 1 dataframe via protein ------------------------------

GO_input_both_cluster1_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 1))$reference
GO_input_thisstudy_cluster1_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 1))$reference


    ###GO enrichment call cluster 1 (both & this study only) ----------------------------------
GO_input_both_cluster1_result <- (gost(query = GO_input_both_cluster1_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster1_result <- (gost(query = GO_input_thisstudy_cluster1_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)




#--------------------------------------------------------------------------------------------------------
  ##cluster 2, both in this study and >= 1 dataframe via protein
GO_input_both_cluster2_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 2))$reference
GO_input_thisstudy_cluster2_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 2))$reference

   ###GO enrichment call cluster 2 (both & this study only) ----------------------------------
GO_input_both_cluster2_result <- (gost(query = GO_input_both_cluster2_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster2_result <- (gost(query = GO_input_thisstudy_cluster2_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)



#--------------------------------------------------------------------------------------------------------

  ##cluster 3, both in this study and >= 1 dataframe via protein
GO_input_both_cluster3_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 3))$reference
GO_input_thisstudy_cluster3_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 3))$reference


   ###GO enrichment call cluster 3 (both & this study only) ----------------------------------
GO_input_both_cluster3_result <- (gost(query = GO_input_both_cluster3_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster3_result <- (gost(query = GO_input_thisstudy_cluster3_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)



#--------------------------------------------------------------------------------------------------------
  ##cluster 4, both in this study and >= 1 dataframe via protein
GO_input_both_cluster4_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 4))$reference
GO_input_thisstudy_cluster4_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 4))$reference



   ###GO enrichment call cluster 4 (both & this study only) ----------------------------------
GO_input_both_cluster4_result <- (gost(query = GO_input_both_cluster4_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster4_result <- (gost(query = GO_input_thisstudy_cluster4_ids, organism = "hsapiens", sources = c("GO:CC"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

#combine term lists per cluster -------------------------------------                                                                         
terms_all_CC_4xDB <- rbind(
  (GO_input_both_cluster3_result %>% mutate(cluster = "1b")),
  (GO_input_thisstudy_cluster1_result %>% mutate(cluster = "1ts")),
  
   (GO_input_both_cluster3_result %>% mutate(cluster = "2b")),
  (GO_input_thisstudy_cluster2_result %>% mutate(cluster = "2ts")),
  
   (GO_input_both_cluster3_result %>% mutate(cluster = "3b")),
  (GO_input_thisstudy_cluster3_result %>% mutate(cluster = "3ts")),
  
   (GO_input_both_cluster4_result %>% mutate(cluster = "4b")),
  (GO_input_thisstudy_cluster4_result %>% mutate(cluster = "4ts")))

#plot


#flipped ------------------------------------------------
plot_GOCC_4xDB_w_clusters <- ggplot(data = terms_all_CC_4xDB) + #%>%
                                           # mutate(term_name = fct_relevel(term_name, "nucleus", "spliceosomal complex", "perinuclear region of cytoplasm",  "cytosol", "actin cytoskeleton","cytoskeleton", "Golgi apparatus", "endocytic vesicle",  "focal adhesion",  "cell junction", "cell leading edge","plasma membrane", "clathrin-coated pit",  "extracellular exosome",  "extracellular space"),
                                                                                             #  "plasma membrane",
                                                                                             # "extracellular space",
                                                                                             # "extracellular vesicle",
                                                                                             # "extracellular exosome",
                                                                                             # "vesicle",
                                                                                             # "cell junction",
                                                                                             # "cell-substrate junction",
                                                                                             # "focal adhesion",
                                                                                             # "cell leading edge",
                                                                                             # "membrane-enclosed lumen",
                                                                                             # "cytosol",
                                                                                             # "ribonucleoprotein granule",
                                                                                             # "cytoskeleton",
                                                                                             # "nucleus",
                                                                                             # "nuclear speck",
                                                                                             # "spliceosomal complex"),
                                                                  # cluster = fct_relevel(cluster, "1", "2", "3", "4"))) +
  geom_point(mapping = aes(x = cluster, y = term_name, fill = -log10(p_value), size = intersection_size,
                           ), shape = 21, show.legend = TRUE) +
  theme_bw(16) +
  # scale_fill_brewer(palette = "PuOr")
  scale_fill_viridis_c(option = "C", direction =  1) +
  # coord_flip(clip = "off") +
  theme(
    # axis.text.x = element_text(size = 18),
    axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(size = 14)) +
  ylab("GO cellular component")

plot_GOCC_4xDB_w_clusters

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOCC_4xDB_w_clusters_1000.png", plot = plot_GOCC_4xDB_w_clusters,
       width = 20, height = 28, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOCC_4xDB_w_clusters_1000.pdf", plot = plot_GOCC_4xDB_w_clusters,
       width = 22, height = 18, scale = 0.4)

```

_restricting term size to <=1000_
Overall, a low number of genes were mapped to GO terms, order of 4 - 16 genes. 
Cluster 3 new genes to this study show preferential early endosome membrane,vacuole, vacuolar membrane, transport vesicle, lytic vacuole membrane, lytic vacuole, lysosome, lysosomal membrane, late endosome membrane, late endosome, early endosome membrane, not seen in the previously annotated study. 
cluster 4 showed a single unique 'post-synaptic specialization.' But I will need to see what genes that entails to see if it makes any sense. 
cluster 1 showed 4-5 genes unique to cortical actin filament bundle.
cluster 2 showed 4 genes part of the extrinsic component of the membrane.

_term size <5000_ 
trends hold relative to <1500. 
Additional information added for cluster 4 new genes to this study: postsynaptic specialization also matches to postsynapse

Next I need to put the above IDs into the GO search function (gost()) to identify top GO classifications for each protein set containing pY sites that are shared vs. unique to this study. This is without filtering for database protein annotations with pY anywhere on them specifically.

###___i. focus on biological process
Define genes to include (by reference) for input into Gene ontology searching.
```{r}
# join conversion dataframe to 'gene_diff_abundance_3xDB' to append cluster information
      # GO_input_df_new_genes <- gene_diff_abundance_3xDB %>% 
      #   left_join (y = conversion, by = "ref")    #commented aout because acheived above in cell component section

#input is your vector of protein ids

#--------------------------------------------------------------------------------------------------------
  ##cluster 1, both in this study and >= 1 dataframe via protein ------------------------------
# GO_input_both_cluster1_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 1))$reference
# GO_input_thisstudy_cluster1_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 1))$reference


    ###GO enrichment call cluster 1 (both & this study only) ----------------------------------
GO_input_both_cluster1_result_BP <- (gost(query = GO_input_both_cluster1_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster1_result_BP <- (gost(query = GO_input_thisstudy_cluster1_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>%
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)




#--------------------------------------------------------------------------------------------------------
  ##cluster 2, both in this study and >= 1 dataframe via protein
# GO_input_both_cluster2_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 2))$reference
# GO_input_thisstudy_cluster2_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 2))$reference

   ###GO enrichment call cluster 2 (both & this study only) ----------------------------------
GO_input_both_cluster2_result_BP <- (gost(query = GO_input_both_cluster2_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster2_result_BP <- (gost(query = GO_input_thisstudy_cluster2_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>%
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)



#--------------------------------------------------------------------------------------------------------

  ##cluster 3, both in this study and >= 1 dataframe via protein
# GO_input_both_cluster3_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 3))$reference
# GO_input_thisstudy_cluster3_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 3))$reference


   ###GO enrichment call cluster 3 (both & this study only) ----------------------------------
GO_input_both_cluster3_result_BP <- (gost(query = GO_input_both_cluster3_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster3_result_BP <- (gost(query = GO_input_thisstudy_cluster3_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)



#--------------------------------------------------------------------------------------------------------
  ##cluster 4, both in this study and >= 1 dataframe via protein
# GO_input_both_cluster4_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 4))$reference
# GO_input_thisstudy_cluster4_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 4))$reference



   ###GO enrichment call cluster 4 (both & this study only) ----------------------------------
GO_input_both_cluster4_result_BP <- (gost(query = GO_input_both_cluster4_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster4_result_BP <- (gost(query = GO_input_thisstudy_cluster4_ids, organism = "hsapiens", sources = c("GO:BP"))$result) %>%
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

#combine term lists per cluster -------------------------------------                                                                         
terms_all_BP_3xDB <- rbind(
  (GO_input_both_cluster3_result_BP %>% mutate(cluster = "1b")),
  (GO_input_thisstudy_cluster1_result_BP %>% mutate(cluster = "1ts")),
  
   (GO_input_both_cluster3_result_BP %>% mutate(cluster = "2b")),
  (GO_input_thisstudy_cluster2_result_BP %>% mutate(cluster = "2ts")),
  
   (GO_input_both_cluster3_result_BP %>% mutate(cluster = "3b")),
  (GO_input_thisstudy_cluster3_result_BP %>% mutate(cluster = "3ts")),
  
   (GO_input_both_cluster4_result_BP %>% mutate(cluster = "4b")),
  (GO_input_thisstudy_cluster4_result_BP %>% mutate(cluster = "4ts")))

#plot


#flipped ------------------------------------------------
plot_GOBP_3xDB_w_clusters <- ggplot(data = terms_all_BP_3xDB) + #%>%
                                           # mutate(term_name = fct_relevel(term_name, "nucleus", "spliceosomal complex", "perinuclear region of cytoplasm",  "cytosol", "actin cytoskeleton","cytoskeleton", "Golgi apparatus", "endocytic vesicle",  "focal adhesion",  "cell junction", "cell leading edge","plasma membrane", "clathrin-coated pit",  "extracellular exosome",  "extracellular space"),
                                                                                             #  "plasma membrane",
                                                                                             # "extracellular space",
                                                                                             # "extracellular vesicle",
                                                                                             # "extracellular exosome",
                                                                                             # "vesicle",
                                                                                             # "cell junction",
                                                                                             # "cell-substrate junction",
                                                                                             # "focal adhesion",
                                                                                             # "cell leading edge",
                                                                                             # "membrane-enclosed lumen",
                                                                                             # "cytosol",
                                                                                             # "ribonucleoprotein granule",
                                                                                             # "cytoskeleton",
                                                                                             # "nucleus",
                                                                                             # "nuclear speck",
                                                                                             # "spliceosomal complex"),
                                                                  # cluster = fct_relevel(cluster, "1", "2", "3", "4"))) +
  geom_point(mapping = aes(x = cluster, y = term_name, fill = -log10(p_value), size = intersection_size,
                           ), shape = 21, show.legend = TRUE) +
  theme_bw(16) +
  # scale_fill_brewer(palette = "PuOr")
  scale_fill_viridis_c(option = "C", direction =  1) +
  # coord_flip(clip = "off") +
  theme(
    # axis.text.x = element_text(size = 18),
    axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(size = 14)) +
  ylab("GO biological process")

plot_GOBP_3xDB_w_clusters

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOBP_3xDB_w_clusters_1000.png", plot = plot_GOBP_3xDB_w_clusters,
       width = 18, height = 24, scale = 0.6)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOBP_3xDB_w_clusters_1000.pdf", plot = plot_GOBP_3xDB_w_clusters,
       width = 22, height = 18, scale = 0.4)

```
Clusters 1, 2, and 4 lacked enough genes for statistical power of GO enrichment. 
_term size <500_
However, cluster 3 did show some enrichments consistent with the CC terms which is exciting. There is enrichment of 4 - 6 genes in vesicle organization, post-Golgi mediated transport, golgi vesicle transport, and endosomal transport. The golgi vesicle transport and post-golgi mediated transport are interesting specificities!


###___i. focus on molecular function
Define genes to include (by reference) for input into Gene ontology searching.
```{r}
# join conversion dataframe to 'gene_diff_abundance_3xDB' to append cluster information
      # GO_input_df_new_genes <- gene_diff_abundance_3xDB %>% 
      #   left_join (y = conversion, by = "ref")    #commented out because acheived above in cell component section

#input is your vector of protein ids

#--------------------------------------------------------------------------------------------------------
  ##cluster 1, both in this study and >= 1 dataframe via protein ------------------------------
# GO_input_both_cluster1_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 1))$reference
# GO_input_thisstudy_cluster1_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 1))$reference


    ###GO enrichment call cluster 1 (both & this study only) ----------------------------------
GO_input_both_cluster1_result_MF <- (gost(query = GO_input_both_cluster1_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster1_result_MF <- (gost(query = GO_input_thisstudy_cluster1_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>%
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)




#--------------------------------------------------------------------------------------------------------
  ##cluster 2, both in this study and >= 1 dataframe via protein
# GO_input_both_cluster2_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 2))$reference
# GO_input_thisstudy_cluster2_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 2))$reference

   ###GO enrichment call cluster 2 (both & this study only) ----------------------------------
GO_input_both_cluster2_result_MF <- (gost(query = GO_input_both_cluster2_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster2_result_MF <- (gost(query = GO_input_thisstudy_cluster2_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>%
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)



#--------------------------------------------------------------------------------------------------------

  ##cluster 3, both in this study and >= 1 dataframe via protein
# GO_input_both_cluster3_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 3))$reference
# GO_input_thisstudy_cluster3_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 3))$reference


   ###GO enrichment call cluster 3 (both & this study only) ----------------------------------
GO_input_both_cluster3_result_MF <- (gost(query = GO_input_both_cluster3_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster3_result_MF <- (gost(query = GO_input_thisstudy_cluster3_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)



#--------------------------------------------------------------------------------------------------------
  ##cluster 4, both in this study and >= 1 dataframe via protein
# GO_input_both_cluster4_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "both") %>% filter(cluster == 4))$reference
# GO_input_thisstudy_cluster4_ids <- (GO_input_df_new_genes %>% filter(overlap_my_data == "this\nstudy") %>% filter(cluster == 4))$reference



   ###GO enrichment call cluster 4 (both & this study only) ----------------------------------
GO_input_both_cluster4_result_MF <- (gost(query = GO_input_both_cluster4_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>% 
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

GO_input_thisstudy_cluster4_result_MF <- (gost(query = GO_input_thisstudy_cluster4_ids, organism = "hsapiens", sources = c("GO:MF"))$result) %>%
  filter(term_size <= 1000)
  # filter(term_name %in% CC_terms_newgenes)

#combine term lists per cluster -------------------------------------                                                                         
terms_all_MF_3xDB <- rbind(
  (GO_input_both_cluster3_result_MF %>% mutate(cluster = "1b")),
  (GO_input_thisstudy_cluster1_result_MF %>% mutate(cluster = "1ts")),
  
   (GO_input_both_cluster3_result_MF %>% mutate(cluster = "2b")),
  (GO_input_thisstudy_cluster2_result_MF %>% mutate(cluster = "2ts")),
  
   (GO_input_both_cluster3_result_MF %>% mutate(cluster = "3b")),
  (GO_input_thisstudy_cluster3_result_MF %>% mutate(cluster = "3ts")),
  
   (GO_input_both_cluster4_result_MF %>% mutate(cluster = "4b")),
  (GO_input_thisstudy_cluster4_result_MF %>% mutate(cluster = "4ts")))

#plot


#flipped ------------------------------------------------
plot_GOMF_3xDB_w_clusters <- ggplot(data = terms_all_MF_3xDB) + #%>%
                                           # mutate(term_name = fct_relevel(term_name, "nucleus", "spliceosomal complex", "perinuclear region of cytoplasm",  "cytosol", "actin cytoskeleton","cytoskeleton", "Golgi apparatus", "endocytic vesicle",  "focal adhesion",  "cell junction", "cell leading edge","plasma membrane", "clathrin-coated pit",  "extracellular exosome",  "extracellular space"),
                                                                                             #  "plasma membrane",
                                                                                             # "extracellular space",
                                                                                             # "extracellular vesicle",
                                                                                             # "extracellular exosome",
                                                                                             # "vesicle",
                                                                                             # "cell junction",
                                                                                             # "cell-substrate junction",
                                                                                             # "focal adhesion",
                                                                                             # "cell leading edge",
                                                                                             # "membrane-enclosed lumen",
                                                                                             # "cytosol",
                                                                                             # "ribonucleoprotein granule",
                                                                                             # "cytoskeleton",
                                                                                             # "nucleus",
                                                                                             # "nuclear speck",
                                                                                             # "spliceosomal complex"),
                                                                  # cluster = fct_relevel(cluster, "1", "2", "3", "4"))) +
  geom_point(mapping = aes(x = cluster, y = term_name, fill = -log10(p_value), size = intersection_size,
                           ), shape = 21, show.legend = TRUE) +
  theme_bw(16) +
  # scale_fill_brewer(palette = "PuOr")
  scale_fill_viridis_c(option = "C", direction =  1) +
  # coord_flip(clip = "off") +
  theme(
    # axis.text.x = element_text(size = 18),
    axis.text.x = element_text(angle = -90, vjust = 0.5, hjust = 0),
        axis.text.y = element_text(size = 14)) +
  ylab("GO biological process")

plot_GOMF_3xDB_w_clusters

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOMF_3xDB_w_clusters_1000.png", plot = plot_GOMF_3xDB_w_clusters,
       width = 24, height = 18, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/plot_GOMF_3xDB_w_clusters_1000.pdf", plot = plot_GOMF_3xDB_w_clusters,
       width = 22, height = 18, scale = 0.4)

```
overall clusters 1, 2, and 3 appear similar unlike cluster 4. This could be biological or due to less sites per cluster 4 relative to 1-3.
Specifically clusters 1, 2 and 3 but not 4 show kinase activity (S, T specifically too), protein complex binding (useless term), molecular adaptor activity, MAP kinase activity, JUN kinase activity, GTPase binding, enzyme binding, clathrin binding.

all four clusters show kinase binding, cadherin binding and cell adhesion molecule binding. 

Uniquely, cluster 1 new genes show phospholipid binding, molecular function regulator activity, enzyme regulator activity, cytoskeletal protein binding. 

unqiuely cluster 2 new genes show nothing not in the previously annotated genes. 

uniquely to cluster 3 new genes, show symporter activity (5 genes) and anion binding (20ish genes).

uniquely to cluster 4 new genes, show nothing not in previously annotated genes. However, the cluster 4 profile looks different than the clusters 1 - 3 in MF terms signaling adaptor activity, RTK binding, tyrosine kinase binding, cell adhesion mediator activity and not the shared profiles of clusters 1 -3. 



#=========================================

#21. CONDITION-LEVEL CLUSTERING and HEATMAPS
Mean imputation without standard deviation was used for these condition-level (i.e. replicate collapsed) heat maps.


##__a. collapse to mean intensity of psite per condition before scaling
Goal is to more simply assess trends by averaging replicate intensities then perform clustering and heatmap.
```{r}
##PIVOT WIDER TO COMPARE TRENDS ACROSS ALL TIME POINTS, just condition using mean intensity
##FEEDS INTO ZSCORE AND CLUSTERING
  #separate dataframe for pivoting. 
  matrix_ascore_gene_imputed_df3_meancondition_noSD <- matrix_ascore_gene_imputed_t_2_again_noSD %>%
    ungroup() %>% 
    distinct(condition, gene_ref, imputed_gt_3_reps, condition_gene_ref_mean_intensity) %>% 
    mutate(gene_ref = str_replace_all(gene_ref, pattern = " ", replacement = "_")) %>% 
    
  #now identify psites missing completely at one time point but measured in others.
  pivot_wider(id_cols = c("gene_ref"),
              names_from = condition,
              values_from = condition_gene_ref_mean_intensity,
              values_fill = NA) %>% 
    pivot_longer(cols = contains("EGF"), names_to = "condition") %>% 
    rename(condition_gene_ref_mean_intensity = value) %>% 
    group_by(gene_ref, condition) %>%  #to allow for different value sampling during imputation in next step
    mutate(condition_gene_ref_mean_intensity = case_when(
      !is.na(condition_gene_ref_mean_intensity) ~ condition_gene_ref_mean_intensity,
      is.na(condition_gene_ref_mean_intensity) ~ 10)) %>% #impute to minimum signal for conditions lacking observations at all
    ungroup() %>% 
    #chose n = 24 to account for some cases where all 4 conditions X 6 reps were not measured. sampling to size = 1 means to keep one value.
    pivot_wider(id_cols = c("gene_ref"),
              names_from = condition,
              values_from = condition_gene_ref_mean_intensity,
              values_fill = NA) 


    ### intensity of 10 was added if no p-sites were detected in all 6 replicates for a given time point for a specific psite.


#z-score (scale) ----------------------------------------------------------------------------------
colnames_for_zscore_matrix_condition_noSD <- colnames(matrix_ascore_gene_imputed_df3_meancondition_noSD %>% select(-gene_ref))


cmeans_clustering_input_matrix_condition_noSD <- as.matrix(matrix_ascore_gene_imputed_df3_meancondition_noSD[,2:6])

rownames(cmeans_clustering_input_matrix_condition_noSD) <- as.matrix(matrix_ascore_gene_imputed_df3_meancondition_noSD[,1])

zscore_cmeans_clustering_matrix_condition_noSD <- apply(cmeans_clustering_input_matrix_condition_noSD, 1, scale) %>% t()
colnames(zscore_cmeans_clustering_matrix_condition_noSD) <- colnames_for_zscore_matrix_condition_noSD

zscore_cmeans_clustering_matrix_condition_noSD[is.nan(zscore_cmeans_clustering_matrix_condition_noSD)] <- 0
```

####. . __ keep 3 or more measured p sites
```{r}
#keep only observations with 3 or more measurements per psite
zscore_cmeans_clustering_condition_df_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "gene_ref") #%>% 
  # left_join((psites_obs_gt_3 %>% distinct(gene_ref, well_observed)), by = "gene_ref") %>% 
  # filter(well_observed == TRUE)

#return to matrix after keeping only >=3 observations per psite
zscore_cmeans_clustering_matrix_condition_noSD <- as.matrix(zscore_cmeans_clustering_condition_df_noSD[,2:6])
rownames(zscore_cmeans_clustering_matrix_condition_noSD) <- as.matrix(zscore_cmeans_clustering_condition_df_noSD[,1])

```




##__b.  C-means clustering
made missing values into 0 for clustering purposes.

need to set seed!! cmeans reoders clusters every time :(
```{r}
set.seed(15)
fcm_result_condition <- cmeans(zscore_cmeans_clustering_matrix_condition_noSD, centers = 4, m = 2)

# fcm_result <- cmeans(cmeans_clustering_input_matrix, centers = 6, m = 2)

# print(fcm_result_condition)
```

###___i. extract membership values
I want to color plot below by membership correlation and not just one color per p-site
```{r}
# Extract the cluster membership matrix
membership_values <- fcm_result_condition$membership

#show the membership values with simple print
# print(membership_values)

#optionally, convert the matrix to a dataframe for easier viewing
membership_df <- as.data.frame(membership_values)

#optionally, I can add clusters to the dataframe
membership_df$cluster <- apply(membership_values, 1, which.max) #get the cluster with highest membership

membership_df$cluster <- as.factor(membership_df$cluster) #convert to double or factor if desired

#update row and column names for dataframe
membership_df <- membership_df %>% 
  rownames_to_column(var = "ref")
colnames(membership_df) <- c("ref", "membership_cluster_1","membership_cluster_2","membership_cluster_3","membership_cluster_4", "cluster")

#pivot dataframe to have one correlation per psite
membership_df_long <- membership_df %>%
  pivot_longer(cols= c("membership_cluster_1","membership_cluster_2","membership_cluster_3","membership_cluster_4"), names_to = "potential_clusters", values_to = "membership_correlation")

#filter to keep only most correlated cluster per p-site
membership_df_long_less <- membership_df_long %>%
  mutate(potential_clusters = as.factor(str_sub(potential_clusters, start = -1L))) %>% 
  group_by(ref) %>% 
  filter(cluster == potential_clusters) %>% ungroup() %>% 
  select(-potential_clusters)

#now I can join the cluster membership correlation (membership_df_long_less) to the graph below for better coloration!
```


####__ii. format dataframe, assign clusters by max correlation, join with membership correlations, and reorder clusters
```{r}
set.seed(11)
data_clustered_condition <- data.frame(zscore_cmeans_clustering_matrix_condition_noSD)
# data_clustered <- data.frame(cmeans_clustering_input_matrix)

#assign to most correlated cluster
data_clustered_condition$cluster <- as.factor(apply(fcm_result_condition$membership, 1, which.max))

data_clustered_condition$gene_ref <- rownames(data_clustered_condition)

data_clustered_condition_df <- as.data.frame(data_clustered_condition) %>% 
  pivot_longer(cols = c(EGF15min:EGF3min), names_to = c("condition")) %>%
  # separate(timepoint, into =c("condition"), sep = "_") %>% 
  
  mutate(minute = case_when(
    condition == "EGF15min" ~ 15,
    condition == "EGF5min" ~ 5,
    condition == "EGF3min" ~ 3,
    condition == "EGF1min" ~ 1,
    condition == "EGF0min" ~ 0)) %>%
  select(-condition) %>%
  rename(mean_condition_intensity = value) %>% 
  # group_by(gene_ref) %>% 
  # mutate(
  #   ref_time_0 = mean_condition_intensity[minute == 0],
  #   fold_change_time0 = mean_condition_intensity - ref_time_0) %>% 
  # ungroup() %>% 
  # group_by(cluster) %>% 
  separate(gene_ref, into = c("gene", "psite" ), sep = "_", remove = FALSE) %>% 
  rename(cluster_unordered = cluster) %>% #rename to allow reordering safely
  mutate(
    cluster = case_when(
      cluster_unordered == 1 ~ 3,
      cluster_unordered == 2 ~ 4,
      cluster_unordered == 3 ~ 2,
      cluster_unordered == 4 ~ 1))
  # mutate(
  #   cluster = case_when(
  #     cluster_unordered == 1 ~ 1,
  #     cluster_unordered == 2 ~ 3, 
  #     cluster_unordered == 3 ~ 4,
  #     cluster_unordered == 4 ~ 2))

#selected examples --------------------------------------

 data_clustered_condition_df <- data_clustered_condition_df %>% 
  left_join(y = membership_df_long_less %>% rename(gene_ref = ref) %>% rename(cluster_unordered = cluster), by = c("cluster_unordered", "gene_ref")) %>% 
  mutate(membership_correlation = as.factor(membership_correlation))
```

####__iii. plot all observations per cluster, colored by membership correlation
```{r}
# cluster_membership_plot1_condition <- ggplot((data_clustered_condition_df ), aes(x = minute, y = mean_condition_intensity, color = gene_ref
cluster_membership_plot1_condition <- ggplot((data_clustered_condition_df ), aes(x = minute, y = mean_condition_intensity, color = membership_correlation )) + 
  scale_color_viridis_d() +
  geom_line(size = 0.5, show.legend = FALSE) +
 alexis_theme() +
  facet_wrap(facets = vars(cluster))

cluster_membership_plot1_condition

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_condition.png", plot = cluster_membership_plot1_condition, width = 16, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_condition.pdf", plot = cluster_membership_plot1_condition, width = 16, height = 10, scale = 0.4)

#-------------------------------------------------------------------------------------------
#make just a legend to save for image.
legend <- ggplot(data = data.frame(cluster_membership = c(0.2,0.27, 0.98,1), mean_condition_intensity = c(0, 0.25, 0.5,1), minute = c("a", "b", "c", "d") )) +
  geom_line(mapping = aes(x = minute, y = mean_condition_intensity , color = cluster_membership)) +
  scale_color_viridis_c() + 
  theme(legend.ticks = element_line(linewidth = 0.25, color = "white"),
        legend.ticks.length = unit(1.5, "mm"))
        # legend.frame = element_rect(color = "black"))

legend
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_condition_legend.png", plot = legend, width = 3, height = 6, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_1_condition_legend.pdf", plot = legend, width = 3, height = 6, scale = 0.4)
```

####__iv. plot mean intensity of clusters
```{r}
#mean intensity of clusters -------------------------------------
cluster_membership_plot2_condition <- ggplot((data_clustered_condition_df %>%
                                     group_by(cluster, minute) %>%
                                     summarize(mean_intensity = mean(mean_condition_intensity) + 1, count_obs = n()) %>% 
                                      ungroup()), aes(x = minute, y = mean_intensity, color = count_obs )) + 
  scale_color_viridis_c() +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  geom_point(size = 2, show.legend = TRUE) +
  geom_line(size = 2, show.legend = TRUE, alpha = 0.4) +
  geom_point(size = 6, alpha = 0.4, show.legend = TRUE) +
  alexis_theme() +
  # scale_y_continuous(limits = c(-1, 2), expand = c(0,0), breaks = c(seq(0, 2, 1))) +
  facet_wrap(facets = vars(cluster))

cluster_membership_plot2_condition

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2b_condition.png", plot = cluster_membership_plot2_condition, width = 16, height = 10, scale = 0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/zscore_scaled_cluster_membership_plot_2b_condition.pdf", plot = cluster_membership_plot2_condition, width = 16, height = 10, scale = 0.4)
```

##__d .heatmap ordered by clusters (mean w/o SD imputed + zscored)

ordered rows by cmeans fuzzy clusters and columns by time series. - not euclidean clusters.
cmeans fuzzy clusters actually look better than euclidean or any of the other kmeans cluster algorithms within pheatmap (euclidean, manhattan, minkowski, binary...)
```{r}
set.seed(15)

#vector of psites only observed 10 or more times across all 30 measurments
# well_observed_psites <- (psites_obs_gt_3 %>%
#   distinct(gene_ref, well_observed) %>%  
#   filter(well_observed == TRUE))$gene_ref

#annotation matrix
zscore_cmeans_clustering_matrix_condition_ordered_df_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>%
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>% 
  left_join(y = data_clustered_condition_df, by = "gene_ref") %>% 
  mutate(
    mod_res = str_sub(psite, end = 1L)) %>% 
  distinct(gene_ref, cluster, mod_res) #%>% 
  # filter(gene_ref %in% well_observed_psites)

#pull out annotations from columns I want
row_annotations_condition_noSD <- zscore_cmeans_clustering_matrix_condition_ordered_df_noSD %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
  distinct(gene_ref, cluster, mod_res) %>% 
  # filter(gene_ref %in% well_observed_psites) %>%
  select( cluster, mod_res) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matris, but return to dataframe to please function.
rownames(row_annotations_condition_noSD) <- zscore_cmeans_clustering_matrix_condition_ordered_df_noSD$gene_ref
row_annotations_condition_noSD <- as.data.frame(row_annotations_condition_noSD)

#row annotation colors
my_colour_noSD = list(
    mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
    cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
    EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"))
# "#C7E9B4""#41B6C4""#225EA8""#081D58"



# reorder columns
zscore_cmeans_clustering_matrix_condition_ordered_df1_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
   
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  left_join((zscore_cmeans_clustering_matrix_condition_ordered_df_noSD %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # filter(gene_ref %in% well_observed_psites) %>%
  arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_cmeans_clustering_matrix_condition_ordered_matrix_noSD <- as.matrix(zscore_cmeans_clustering_matrix_condition_ordered_df1_noSD[,2:6])

rownames(zscore_cmeans_clustering_matrix_condition_ordered_matrix_noSD) <- zscore_cmeans_clustering_matrix_condition_ordered_df1_noSD[,1]


zscore_pheatmap_condition_noSD <- pheatmap(zscore_cmeans_clustering_matrix_condition_ordered_matrix_noSD , cluster_cols = F, cluster_rows = F,
# zscore_pheatmap <- pheatmap(zscore_cmeans_clustering_matrix_condition , cluster_cols = F, cluster_rows = T,
         cutree_rows = 4, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         # clustering_distance_rows = "euclidean",
         
         fontsize_row = 2,
         annotation_row = row_annotations_condition_noSD, annotation_colors = my_colour_noSD,
         treeheight_row = 0)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_mean_condition_noSD.pdf", plot = zscore_pheatmap_condition_noSD , width = 12, height = 60, scale =0.8)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_mean_condition_noSD.png", plot = zscore_pheatmap_condition_noSD , width = 6, height = 20, scale = 0.8, limitsize = FALSE)
```




##__e. Pathway specific heatmaps using imputed data

###___ . row annotation colors
gene level
```{r}
#row annotation colors
my_colour_condition = list(
    mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
    cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
    # EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # depth = c("0" = "green", "1" = "green4","2" =  "darkgreen","3" =  "yellow","4" =  "yellow4","5" =  "orange", "6" = "darkorange2", "7" = "darkgoldenrod" ,"8" = "darkorange4" ,"9" = "red4", "10" = "darkmagenta" ,"11" = "#891BF2","12" =  "#7918F3","13" =  "#6A15F5","14" =  "#5B12F6" ,"15" = "#4C0FF7", "16" = "#3C0CF9", "17" =  "#1E06FC"),
    PSP_EGF_annotated_site = c("both" = "#22A884FF", "this study" = "#D95F02"),
    PTMSigDB_EGF_annotated_site = c("both" = "#22A884FF", "this study" = "#D95F02"),
    CST_EGF_annotated_site = c("both" = "#22A884FF", "this study" = "#D95F02"),
    PSP_EGF_annotated_gene = c("both" = "#22A900", "this study" = "#D59F02"),
    not_in_PSP = c("not in PSP" = "red4"))

# depth_colors <- colorRampPalette(c("grey", "purple", "blue"))
# depth_colors(22)
```



###___i.   EGF heat map 
####. . ___ PSP
#####. . . ___ joined just by gene, allowing any pY site I measure
```{r}
PSP_EGFR_pY_ref_df <- PSP_EGFR %>%
  # rename(psite = mod_residue) %>%
  mutate(psite = paste0(mod_res, mod_residue)) %>% 
  mutate(gene_ref = paste(gene, psite, sep = "_")) #%>% 
  # filter(mod_res == "Y")
  

# reorder columns
zscore_EGFR_df1_condition_noSD_PSP <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  # filter(gene %in% ((PSP_EGFR )$gene))
  filter(gene %in% PSP_EGFR_pY_ref_df$gene) %>% 
  arrange(gene)
  # filter(gene %in% ((PSP_EGFR %>% filter(mod_res == "Y") %>% rename(psite = mod_residue))$gene))
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix_condition_noSD_PSP <- as.matrix(zscore_EGFR_df1_condition_noSD_PSP[,4:8])

rownames(zscore_EGFR_matrix_condition_noSD_PSP) <- zscore_EGFR_df1_condition_noSD_PSP[,1]
# -------------------------------------------------------------------------------------------------------------
  #row annotations overlap my data gene and site level
set.seed(15)


#annotation matrix
zscore_EGFR_matrix_condition_PSP_noSD_ordered_df <- zscore_EGFR_matrix_condition_noSD_PSP %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>%
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>% 
  # left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  
  #add in EGF node depths here via left join column = depth
  # left_join(y = WP437_EGFR_node_depths %>%
  #             mutate(depth = as.character(depth)),
  #           by = c("gene")) %>% 
  
  #add in previous database annotations at gene level
  left_join(y = gene_diff_abundance_3xDB %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              mutate(overlap_my_data_gene = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, overlap_my_data_gene),
            by = "gene") %>%
  
  #add in previous database annotations at site level
  left_join(y = (psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>% #this will keep only psites that are significantly regulated according to fold change tests using standard deviation during imputation.
              #formatting for legend
              mutate(PSP_EGF_annotated_site = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both", 
                TRUE ~ overlap_my_data)) %>% 
              distinct(gene, gene_ref,psite, PSP_EGF_annotated_site)),
            by = c("gene", "gene_ref")) %>% 
  
  #add in NOT in PSP info
  left_join(y = net_unique_pYsites_not_in_PSP %>% mutate(not_in_PSP = "not in PSP"), by = "gene_ref") %>% 
  
  filter(!is.na(overlap_my_data_gene)) %>%  #remove psites not significantly regulated
  filter(!is.na(PSP_EGF_annotated_site)) %>%  #remove psites not significantly regulated
  
  select(gene_ref, contains("min"), everything()) %>% 
  arrange(gene, gene_ref, overlap_my_data_gene, PSP_EGF_annotated_site) %>% 
  
  # mutate(
  #   mod_res = str_sub(psite, end = 1L)) %>% 

  distinct(gene_ref,  PSP_EGF_annotated_site, not_in_PSP) #all pY and depth is hard to interpret in figure. Therefore, just overlap_my_data w/ 2 colors.
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data)



#pull out annotations from columns I want
row_annotations_condition <- zscore_EGFR_matrix_condition_PSP_noSD_ordered_df %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
    # distinct(gene_ref,  overlap_my_data_gene, PSP_EGF_annotated_site, not_in_PSP) %>%
  distinct(gene_ref, PSP_EGF_annotated_site, not_in_PSP) %>%
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data) %>%
  select(  PSP_EGF_annotated_site, not_in_PSP) %>%    #get rid of depth and mod_res annotations
  # select( cluster, mod_res, depth) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations_condition) <- zscore_EGFR_matrix_condition_PSP_noSD_ordered_df$gene_ref
row_annotations_condition <- as.data.frame(row_annotations_condition)




# -------------------------------------------------------------------------------------------------------------

#plot heatmap
zscore_EGFR_pheatmap_condition_noSD <- pheatmap(zscore_EGFR_matrix_condition_noSD_PSP , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         
         fontsize_row = 7.5,
         annotation_row = row_annotations_condition, annotation_colors = my_colour_condition,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PSP_gene_noSD_overlap.pdf", plot = zscore_EGFR_pheatmap_condition_noSD , width = 12, height = 60, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PSP_gene_noSD_overlap.png", plot = zscore_EGFR_pheatmap_condition_noSD , width = 5, height = 40, scale = 0.5, limitsize = TRUE)
```

#####. . . ___ joined by both gene and psite

```{r}
PSP_EGFR_pY_ref_df <- PSP_EGFR %>%
  mutate(psite = paste0(mod_res, mod_residue)) %>%
  mutate(gene_ref = paste(gene, psite, sep = "_")) %>% 
  filter(mod_res == "Y")

#somehow this code relies on gene names from ascore_gene_fasta, and doesn't play well with human_fasta_2024 genenames. Can I make a gene conversion that satisfies all analyses?
  

# reorder columns
zscore_EGFR_df1_condition_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  # filter(gene %in% ((PSP_EGFR )$gene))
  filter(gene_ref %in% PSP_EGFR_pY_ref_df$gene_ref) %>% #filtering for psite level matching here
  arrange(gene)
  # filter(gene %in% ((PSP_EGFR %>% filter(mod_res == "Y") %>% rename(psite = mod_residue))$gene))
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix_condition_noSD <- as.matrix(zscore_EGFR_df1_condition_noSD[,4:8])

rownames(zscore_EGFR_matrix_condition_noSD) <- zscore_EGFR_df1_condition_noSD[,1]


#plot heatmap
zscore_EGFR_pheatmap_condition_noSD <- pheatmap(zscore_EGFR_matrix_condition_noSD , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         fontsize_col = 18,
         fontsize_row = 10,
         # annotation_row = row_annotations, annotation_colors = my_colour,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PSP_generef_noSD.pdf", plot = zscore_EGFR_pheatmap_condition_noSD , width = 8, height = 40, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PSP_generef_noSD.png", plot = zscore_EGFR_pheatmap_condition_noSD , width = 8, height = 40, scale = 0.4, limitsize = TRUE)
```







####. . ___ PTM-SEA = PTMSigDB
#####. . . ___ joined just by gene, allowing any pY site I measure
```{r}
PTMSigDB_EGFR_pY_ref_df <- EGFR1_pathway_PTMSigDB %>%
  mutate(psite = paste0(mod_res, mod_residue)) %>%
  mutate(gene_ref = paste(gene, psite, sep = "_")) #%>% 
  # filter(mod_res == "Y")
  

# reorder columns
zscore_EGFR_df1_condition_PTMSigDB_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  filter(gene %in% PTMSigDB_EGFR_pY_ref_df$gene) %>% 
  arrange(gene)
  # filter(gene %in% ((PTMSigDB_EGFR %>% filter(mod_res == "Y") %>% rename(psite = mod_residue))$gene))
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix_condition_PTMSigDB_noSD <- as.matrix(zscore_EGFR_df1_condition_PTMSigDB_noSD[,4:8])

rownames(zscore_EGFR_matrix_condition_PTMSigDB_noSD) <- zscore_EGFR_df1_condition_PTMSigDB_noSD[,1]
# -------------------------------------------------------------------------------------------------------------
  #row annotations overlap my data gene and site level
set.seed(15)


#annotation matrix
zscore_EGFR_matrix_condition_PTMSigDB_noSD_ordered_df <- zscore_EGFR_matrix_condition_PTMSigDB_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>%
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>% 
  # left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  
  #add in EGF node depths here via left join column = depth
  # left_join(y = WP437_EGFR_node_depths %>%
  #             mutate(depth = as.character(depth)),
  #           by = c("gene")) %>% 
  
  #add in previous database annotations at gene level
  left_join(y = gene_diff_abundance_3xDB %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              mutate(overlap_my_data_gene = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, overlap_my_data_gene),
            by = "gene") %>%
  
  #add in previous database annotations at site level
  left_join(y = (psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>% #this will keep only psites that are significantly regulated according to fold change tests using standard deviation during imputation.
              #formatting for legend
              mutate(PTMSigDB_EGF_annotated_site = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both", 
                TRUE ~ overlap_my_data)) %>% 
              distinct(gene, gene_ref, PTMSigDB_EGF_annotated_site)),
            by = c("gene", "gene_ref")) %>% 
  
  #add in NOT in PSP info
  left_join(y = net_unique_pYsites_not_in_PSP %>% mutate(not_in_PSP = "not in PSP"), by = "gene_ref") %>% 
  
  filter(!is.na(overlap_my_data_gene)) %>%  #remove psites not significantly regulated
  filter(!is.na(PTMSigDB_EGF_annotated_site)) %>%  #remove psites not significantly regulated
  
  select(gene_ref, contains("min"), everything()) %>% 
  arrange(gene, gene_ref, overlap_my_data_gene, PTMSigDB_EGF_annotated_site) %>% 
  
  # mutate(
  #   mod_res = str_sub(psite, end = 1L)) %>% 
  distinct(gene_ref, overlap_my_data_gene, PTMSigDB_EGF_annotated_site, not_in_PSP) #all pY and depth is hard to interpret in figure. Therefore, just overlap_my_data w/ 2 colors.
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data)



#pull out annotations from columns I want
row_annotations_condition <- zscore_EGFR_matrix_condition_PTMSigDB_noSD_ordered_df %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
  # distinct(gene_ref,  overlap_my_data_gene, PTMSigDB_EGF_annotated_site, not_in_PSP) %>%
  distinct(gene_ref, PTMSigDB_EGF_annotated_site, not_in_PSP) %>%
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data) %>%
  select(  PTMSigDB_EGF_annotated_site, not_in_PSP) %>%    #get rid of depth and mod_res annotations
  # select( cluster, mod_res, depth) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations_condition) <- zscore_EGFR_matrix_condition_PTMSigDB_noSD_ordered_df$gene_ref
row_annotations_condition <- as.data.frame(row_annotations_condition)




# -------------------------------------------------------------------------------------------------------------

#plot heatmap
zscore_EGFR_pheatmap_condition_PTMSigDB_noSD <- pheatmap(zscore_EGFR_matrix_condition_PTMSigDB_noSD , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         
         fontsize_row = 7.5,
         annotation_row = row_annotations_condition, annotation_colors = my_colour_condition,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PTMSigDB_gene_noSD_overlap.pdf", plot = zscore_EGFR_pheatmap_condition_PTMSigDB_noSD , width = 12, height = 60, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PTMSigDB_gene_noSD_overlap.png", plot = zscore_EGFR_pheatmap_condition_PTMSigDB_noSD , width = 5, height = 40, scale = 0.5, limitsize = TRUE)
```

#####. . . ___ joined by both gene and psite
```{r}
PTMSigDB_EGFR_pY_ref_df <- EGFR1_pathway_PTMSigDB %>%
  mutate(psite = paste0(mod_res, mod_residue)) %>%
  mutate(gene_ref = paste(gene, psite, sep = "_")) %>% 
  filter(mod_res == "Y")
  

# reorder columns
zscore_EGFR_df1_condition_PTMSigDB_gene_ref_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  # filter(gene %in% ((PTMSigDB_EGFR )$gene))
  filter(gene_ref %in% PTMSigDB_EGFR_pY_ref_df$gene_ref) %>% 
  arrange(gene)
  # filter(gene %in% ((PTMSigDB_EGFR %>% filter(mod_res == "Y") %>% rename(psite = mod_residue))$gene))
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix_condition_PTMSigDB_gene_ref_noSD <- as.matrix(zscore_EGFR_df1_condition_PTMSigDB_gene_ref_noSD[,4:8])

rownames(zscore_EGFR_matrix_condition_PTMSigDB_gene_ref_noSD) <- zscore_EGFR_df1_condition_PTMSigDB_gene_ref_noSD[,1]


#plot heatmap
zscore_EGFR_pheatmap_condition_PTMSigDB_gene_ref_noSD <- pheatmap(zscore_EGFR_matrix_condition_PTMSigDB_gene_ref_noSD , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         fontsize_col = 18,
         fontsize_row = 10,
         # annotation_row = row_annotations, annotation_colors = my_colour,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PTMSigDB_generef_noSD.pdf", plot = zscore_EGFR_pheatmap_condition_PTMSigDB_gene_ref_noSD , width = 8, height = 40, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_PTMSigDB_generef_noSD.png", plot = zscore_EGFR_pheatmap_condition_PTMSigDB_gene_ref_noSD , width = 8, height = 60, scale = 0.4, limitsize = TRUE)
```

####. . ___ CST EGF/ErbB1
#####. . . ___ joined just by gene, allowing any pY site I measure
```{r}


CST_EGFR_proteins <- c("P00533","P42336","Q9Y243","P42345","P23443","P15498","P63000","Q13153","Q13233","P45983","P05412","P01100","Q05397","P56945","P16333","P60953","P15941","P35222","P56539","P49023","P12830","P42226","P46108","P00519","Q9UPR0","P0DP24","Q16566","Q9UQM7","P22681","P62993","Q96J02","O14964","Q07889","O14807","P04049","Q02750","P01112","P28482","P05771","P12931","P01116","P52333","P07947","P43405","Q9UQC2","Q06124","Q99704","Q7L591","P42224","Q18PE1","P31751","P31749","P53779","P45984","Q6FG41","Q14289","P51636","Q03135","P52630","Q14765","P0DP25","Q13557","Q96NX5","P0DP23","Q13555","Q13554","P05129","P23458","Q6PKX4","Q9P104","Q07890","O60496","Q8TEW6","P36507","O60674","P17252","Q9NQ66","P19174","P51178"," Q4KWH8","P16885","O75038","Q00722","Q9UJM3","P52735","Q9UKW4","P15498","P16220","Q02930","O43889","P05771","P17252","P05129", "P19419", "P41970", "P28324", "P42336", "O00443", "O00750", "P23443", "P36507", "P46734")

CST_gene_reference_conversion <- ascore_gene_clusters_Imputation_noSD %>% 
  filter(reference %in% CST_EGFR_proteins) %>% 
  distinct(reference, gene)
  

# reorder columns
zscore_EGFR_df1_condition_noSD_CST <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  # filter(gene_ref %in% well_observed_psites) %>%
  filter(grepl("_Y", gene_ref) == TRUE) %>% 
  # filter(gene %in% ((PSP_EGFR )$gene))
  filter(gene %in% CST_gene_reference_conversion$gene) %>% 
  arrange(gene, gene_ref)
  # filter(gene %in% ((PSP_EGFR %>% filter(mod_res == "Y") %>% rename(psite = mod_residue))$gene))
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap 
zscore_EGFR_matrix_condition_noSD_CST <- as.matrix(zscore_EGFR_df1_condition_noSD_CST[,4:8])

rownames(zscore_EGFR_matrix_condition_noSD_CST) <- zscore_EGFR_df1_condition_noSD_CST[,1]


# -------------------------------------------------------------------------------------------------------------
  #row annotations overlap my data gene and site level
set.seed(15)


#annotation matrix
zscore_EGFR_matrix_condition_CST_noSD_ordered_df <- zscore_EGFR_matrix_condition_noSD_CST %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>%
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>% 
  # left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  
  #add in EGF node depths here via left join column = depth
  # left_join(y = WP437_EGFR_node_depths %>%
  #             mutate(depth = as.character(depth)),
  #           by = c("gene")) %>% 
  
  #add in previous database annotations at gene level
  left_join(y = gene_diff_abundance_3xDB %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
              mutate(overlap_my_data_gene = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both",
                TRUE ~ overlap_my_data)) %>%
              distinct(gene, overlap_my_data_gene),
            by = "gene") %>%
  
  #add in previous database annotations at site level
  left_join(y = (psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
              filter(overlap_my_data %in% c("this\nstudy", "both")) %>% #this will keep only psites that are significantly regulated according to fold change tests using standard deviation during imputation.
              #formatting for legend
              mutate(CST_EGF_annotated_site = case_when(
                overlap_my_data == "this\nstudy" ~ "this study",
                overlap_my_data == "both" ~ "both", 
                TRUE ~ overlap_my_data)) %>% 
              distinct(gene, gene_ref,psite, CST_EGF_annotated_site)),
            by = c("gene", "gene_ref")) %>% 
  
  #add in NOT in PSP info
  left_join(y = net_unique_pYsites_not_in_PSP %>% mutate(not_in_PSP = "not in PSP"), by = "gene_ref") %>% 
  
  filter(!is.na(overlap_my_data_gene)) %>%  #remove psites not significantly regulated
  filter(!is.na(CST_EGF_annotated_site)) %>%  #remove psites not significantly regulated
  
  select(gene_ref, contains("min"), everything()) %>% 
  arrange(gene, gene_ref, overlap_my_data_gene, CST_EGF_annotated_site) %>% 
  
  # mutate(
  #   mod_res = str_sub(psite, end = 1L)) %>% 

  distinct(gene_ref,  CST_EGF_annotated_site, not_in_PSP) #all pY and depth is hard to interpret in figure. Therefore, just overlap_my_data w/ 2 colors.
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data)



#pull out annotations from columns I want
row_annotations_condition <- zscore_EGFR_matrix_condition_CST_noSD_ordered_df %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
    # distinct(gene_ref,  overlap_my_data_gene, PSP_EGF_annotated_site, not_in_PSP) %>%
  distinct(gene_ref, CST_EGF_annotated_site, not_in_PSP) %>%
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data) %>%
  select(  CST_EGF_annotated_site, not_in_PSP) %>%    #get rid of depth and mod_res annotations
  # select( cluster, mod_res, depth) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations_condition) <- zscore_EGFR_matrix_condition_CST_noSD_ordered_df$gene_ref
row_annotations_condition <- as.data.frame(row_annotations_condition)




# -------------------------------------------------------------------------------------------------------------



#plot heatmap
zscore_EGFR_pheatmap_condition_noSD_CST <- pheatmap(zscore_EGFR_matrix_condition_noSD_CST , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         
         fontsize_row = 7.5,
         annotation_row = row_annotations_condition, annotation_colors = my_colour_condition,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_CST_gene_noSD.pdf", plot = zscore_EGFR_pheatmap_condition_noSD_CST , width = 12, height = 60, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_CST_gene_noSD.png", plot = zscore_EGFR_pheatmap_condition_noSD_CST , width = 5, height = 40, scale = 0.5, limitsize = TRUE)
```


####. . ___ WP437
#####. . . ___ joined just by gene, allowing any pY site I measure
PTM-Nav
only gene level matching, not site level because wikipathways does not provide psite level pathway data.
```{r}
WP437 <- c('NOS3','COX2','SHC1','STAT5A','RALA','NEDD4','ELK4','MAPK1','MAPK8','ARHGEF1','STMN1','STAT1','EPS15L1','SH3GL3','EGF','INPP5D','PTPN5','ATF1','GRB10','ERRFI1','GRIM19','MAP3K1','PTK6','RPS6KA2','CSK','PCNA','KRAS','LIMK2','RASA1','ARF6','IQGAP1','EGFR','SP1','BRAF','DOK2','PTPRR','CRK','SH2D2A','MAPK9','RPS6KA3','RIN1','CAV2','E2F1','VAV2','SOS2','PTPN12','MTOR','NCK2','MAP3K3','RALGDS','VAV3','CAMK2A','STAT3','MAPK3','SOS1','GAB2','RAP1A','JAK1','CDC42','NCOA3','ATXN2','RAB5A','RPS6KB1','MAPK14','ASAP1','SYNJ1','MAP2K1','RAF1','EPN1','NCK1','STAMBP','CAV1','STAM2','HGS','MAP2K2','CREB1','PLCG1','ERBB2','SPRY2','INPPL1','EIF4EBP1','MAP4K1','RICTOR','USP6NL','RPS6KA5','PTK2B','PIK3R2','PLD2','EPS8','RAC1','ABI1','PLSCR1','PIK3R1','MEF2D','GAB1','PLCE1','PLD1','DNM1','JUN','PIAS3','SH3GL2','RPS6KA1','ROCK1','MAP3K4','PRKCD','AP2B','AKT1','FOXO1','VAV1','PRKCZ','RALB','FOS','PRKCI','PRKCA','SRC','ITCH','ABL1','RALBP1','MAPK7','REPS2','JUND','GRB2','EPS15','USP8','AP2A1', 'AP2B1', 'HRAS','PDPK1','IQSEC1','PEBP1','SH3KBP1','TNK2','PTPN11','AP2S1','PRKCB','FOXO4','FOSB','PTEN','NEDD8','STAM','GJA1','CRKL','JAK2','MAP2K5','BCAR1','MAP3K2','ELK1','STAT5B','PIK3C2B','STXBP1','CBLB','CBL','CBLC','PAK1','CFL1','PTK2','AP2M1','MEF2A','PXN','MEF2C')
# reorder columns
zscore_EGFR_WP437_df1_condition_noSD <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%
  mutate(psite_num = as.numeric(str_sub(psite, start = 2L))) %>%
  # select(everything(), psite_num) %>% 
  # filter(gene_ref %in% well_observed_psites) %>% 
  filter(grepl("_Y", gene_ref) == TRUE) %>%
  # filter(gene %in% ((PSP_EGFR_WP437 )$gene))
  filter(gene %in% WP437) %>% 
  left_join(data_clustered_condition_df %>%distinct(gene_ref, cluster), by = "gene_ref") %>%
  # left_join(data_clustered_reps_df %>%distinct(gene_ref, cluster), by = "gene_ref") %>%
  filter(!is.na(cluster)) %>% 
  left_join(y = WP437_EGFR_node_depths %>% distinct(), by = "gene") %>%
  distinct() %>%
  arrange(depth, gene, psite_num)
  # arrange(gene)
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_WP437_matrix_condition_noSD <- as.matrix(zscore_EGFR_WP437_df1_condition_noSD[,4:8])

rownames(zscore_EGFR_WP437_matrix_condition_noSD) <- zscore_EGFR_WP437_df1_condition_noSD[,1]


#annotations -----------------------------------------

#annotation matrix
annotation_WP437_depths_df_condition_noSD <- zscore_EGFR_WP437_df1_condition_noSD %>%
  # left_join(data_clustered_reps_df %>% select(gene_ref, cluster), by = "gene_ref") %>% 
  filter(!is.na(cluster)) %>% 
  mutate(depth = as.character(depth)) %>% 
  # mutate(
  #     mod_res = str_sub(psite, end = 1L)) %>%
  #add in NOT in PSP info
  left_join(y = net_unique_pYsites_not_in_PSP %>% mutate(not_in_PSP = "not in PSP"), by = "gene_ref") %>%
     
  #add in previous database annotations at site level
  left_join(y = PSP_EGFR_pY_ref_df %>% distinct(gene_ref) %>% mutate(PSP_EGF_annotated_site = "TRUE"), by = "gene_ref") %>% 
  left_join(y = PTMSigDB_EGFR_pY_ref_df %>% distinct(gene_ref) %>% mutate(PTMSigDB_EGF_annotated_site = "TRUE"), by = "gene_ref") %>%
  mutate(
    PSP_EGF_annotated_site = case_when(
    PSP_EGF_annotated_site == "TRUE" ~ "previously annotated",
    is.na(PSP_EGF_annotated_site) ~ "EGF-response in this study" ),
    PTMSigDB_EGF_annotated_site = case_when(
    PTMSigDB_EGF_annotated_site == "TRUE" ~ "previously annotated",
    is.na(PTMSigDB_EGF_annotated_site) ~ "EGF-response in this study" )) %>% 
  distinct(gene_ref,
             cluster,
             not_in_PSP,
             # mod_res,
           PSP_EGF_annotated_site,
           PTMSigDB_EGF_annotated_site,
             depth)

  




#get the annotion contents into a matrix without the gene_ref ids, which will be added later as rownames
  row_annotations_WP437_matrix_df_condition_noSD <- annotation_WP437_depths_df_condition_noSD%>% 
    filter(!is.na(cluster)) %>% 
    # distinct(gene_ref, cluster, mod_res, depth) %>%
    select(cluster,
           # mod_res,
           not_in_PSP,
           PSP_EGF_annotated_site,
           PTMSigDB_EGF_annotated_site,
           depth) %>% 
    as.matrix()

  
      #assign row names to be gene_ref
rownames(row_annotations_WP437_matrix_df_condition_noSD) <- annotation_WP437_depths_df_condition_noSD$gene_ref
    
#return matrix with row names into a dataframe
  #INPUT THIS FOR ROW ANNOTATIONS IN PHEATMAP
row_annotations_WP437_matrix_df_condition_noSD <- as.data.frame(row_annotations_WP437_matrix_df_condition_noSD)
  
    #colors for heatmap
#row annotation colors
my_colour_WP437_condition = list(
    # mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
    cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
    # EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    depth = c("0" = "chocolate4", "1" = "#9E0142","2" =  "#D53E4F","3" =  "#F46D43","4" =  "#FDAE61","5" =  "#FEE08B", "6" = "#FFFFBF", "7" = "#E6F598" ,"8" = "#ABDDA4" ,"9" = "#66C2A5", "10" = "#3288BD" ,"11" = "lightskyblue","12" =  "deepskyblue","13" =  "blue","14" =  "#5B12F6" ,"15" = "lightslateblue", "16" = "blueviolet", "17" =  "violet"),
    PSP_EGF_annotated_site = c("previously annotated" = "#22A884FF", "EGF-response in this study" = "#D95F02"),
    PTMSigDB_EGF_annotated_site = c("previously annotated" = "#22A884FF", "EGF-response in this study" = "#D95F02"),
    CST_EGF_annotated_gene = c("TRUE" = "#22A884FF", "this study" = "#D95F02"),
    PSP_EGF_annotated_gene = c("both" = "#22A900", "this study" = "#D59F02"),
    not_in_PSP = c("not in PSP" = "red4"))
# 

# "#C7E9B4""#41B6C4""#225EA8""#081D58"




#plot heatmap -------------------------------------------
zscore_EGFR_WP437_pheatmap_condition <- pheatmap(zscore_EGFR_WP437_matrix_condition_noSD ,
                   cluster_cols = F,
                   cluster_rows = F,
                 # cutree_rows = 6,
                 # cutree_cols = 5,
                 colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
                 # clustering_distance_rows = "minkowski",
                 
                 fontsize_row = 10,
                 annotation_row = row_annotations_WP437_matrix_df_condition_noSD,
                 annotation_colors = my_colour_WP437_condition,
                 treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_WP437_condition.pdf", plot = zscore_EGFR_WP437_pheatmap_condition , width = 16, height = 60, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_WP437_condition.png", plot = zscore_EGFR_WP437_pheatmap_condition , width = 7, height = 40, scale = 0.5, limitsize = FALSE)

# #taller, less wide
# ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_WP437_condition_taller.pdf", plot = zscore_EGFR_WP437_pheatmap_condition , width = 10, height = 60, scale =0.4)
```
####. . ___ PSP, PTMSigDB, CST, WP437 combined
#####. . . ___ joined just by gene, allowing any pY site I measure
```{r}
#vector to df
WP437_gene_ref_df <- data.frame(gene = WP437) %>% distinct(gene)

#join to this consolidated gene list to see all genes side by side
gene_list_4xDB <- rbind((PSP_EGFR %>% distinct(gene) %>% mutate(source = "PSP")),
                        (EGFR1_pathway_PTMSigDB %>% distinct(gene)%>% mutate(source = "PTMSigDB")),
                        (CST_gene_reference_conversion %>% distinct(gene)%>% mutate(source = "CST")),
                        (WP437_gene_ref_df%>% mutate(source = "WP437"))) %>% 
                  distinct(gene, source)


  

# reorder columns
zscore_EGFR_df1_condition_noSD_4xDB <- zscore_cmeans_clustering_matrix_condition_noSD %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>%
  rownames_to_column(var = "gene_ref") %>% 
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>%

  filter(grepl("_Y", gene_ref) == TRUE) %>% 

  filter(gene %in% (gene_list_4xDB %>% distinct(gene))$gene) %>% 
  arrange(gene)
  # filter(gene %in% ((PSP_EGFR %>% filter(mod_res == "Y") %>% rename(psite = mod_residue))$gene))
  # left_join((conversion %>% distinct(gene_ref, cluster)), by = "gene_ref") %>% 
  # arrange(-desc(cluster)) 

#for input into heatmap with fuzzy cmeans clustering orders (soft cluster)
zscore_EGFR_matrix_condition_noSD_4xDB <- as.matrix(zscore_EGFR_df1_condition_noSD_4xDB[,4:8])

rownames(zscore_EGFR_matrix_condition_noSD_4xDB) <- zscore_EGFR_df1_condition_noSD_4xDB[,1]
# -------------------------------------------------------------------------------------------------------------
  #row annotations overlap my data gene and site level
set.seed(15)


#annotation matrix
zscore_EGFR_matrix_condition_4xDB_noSD_ordered_df <- zscore_EGFR_matrix_condition_noSD_4xDB %>% 
  as.data.frame() %>% 
  select(contains("0min"), contains("1min"), contains("3min"), contains("EGF5min"), contains("EGF15min")) %>% 
  rownames_to_column(var = "gene_ref") %>%
  separate(gene_ref, into = c("gene", "psite"), sep = "_", remove = FALSE) %>% 
  # left_join(y = data_clustered_reps_df, by = "gene_ref") %>%
  
  #add in EGF node depths here via left join column = depth
  # left_join(y = WP437_EGFR_node_depths %>%
  #             mutate(depth = as.character(depth)),
  #           by = c("gene")) %>% 
  
  # #add in previous database annotations at gene level
  # left_join(y = gene_diff_abundance_3xDB %>%
  #             filter(overlap_my_data %in% c("this\nstudy", "both")) %>%
  #             mutate(overlap_my_data_gene = case_when(
  #               overlap_my_data == "this\nstudy" ~ "this study",
  #               overlap_my_data == "both" ~ "both",
  #               TRUE ~ overlap_my_data)) %>%
  #             distinct(gene, overlap_my_data_gene),
  #           by = "gene") %>%
  # 
  # #add in previous database annotations at site level
  # left_join(y = (psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  #             filter(overlap_my_data %in% c("this\nstudy", "both")) %>% #this will keep only psites that are significantly regulated according to fold change tests using standard deviation during imputation.
  #             #formatting for legend
  #             mutate(PSP_EGF_annotated_site = case_when(
  #               overlap_my_data == "this\nstudy" ~ "this study",
  #               overlap_my_data == "both" ~ "both", 
  #               TRUE ~ overlap_my_data)) %>% 
  #             distinct(gene, gene_ref,psite, PSP_EGF_annotated_site)),
  #           by = c("gene", "gene_ref")) %>% 
  
  #add in NOT in PSP info
  left_join(y = net_unique_pYsites_not_in_PSP %>% mutate(not_in_PSP = "not in PSP"), by = "gene_ref") %>% 
  
  #add in previous database annotations at site level
  left_join(y = PSP_EGFR_pY_ref_df %>% distinct(gene_ref) %>% mutate(PSP_site = "TRUE"), by = "gene_ref") %>% 
  left_join(y = PTMSigDB_EGFR_pY_ref_df %>% distinct(gene_ref) %>% mutate(PTMSigDB_site = "TRUE"), by = "gene_ref") %>%
  
  left_join(y = gene_list_4xDB %>% filter(source == "PSP") %>% distinct(gene) %>% mutate(PSP_gene = "TRUE") , by = "gene") %>% 
  left_join(y = gene_list_4xDB %>% filter(source == "PTMSigDB") %>% distinct(gene) %>% mutate(PTMSigDB_gene = "TRUE") , by = "gene") %>%
  left_join(y = gene_list_4xDB %>% filter(source == "CST") %>% distinct(gene) %>% mutate(CST_gene = "TRUE") , by = "gene") %>% 
  left_join(y = gene_list_4xDB %>% filter(source == "WP437") %>% distinct(gene) %>% mutate(WP437_gene = "TRUE") , by = "gene") %>%
  mutate(
    PSP_site = case_when(
    PSP_site == "TRUE" ~ "previously annotated",
    is.na(PSP_site) ~ "EGF-response in this study" ),
    PTMSigDB_site = case_when(
    PTMSigDB_site == "TRUE" ~ "previously annotated",
    is.na(PTMSigDB_site) ~ "EGF-response in this study" ),
    PSP_gene = case_when(
    PSP_gene == "TRUE" ~ "previously annotated",
    is.na(PSP_gene) ~ "EGF-response in this study" ),
    PTMSigDB_gene = case_when(
    PTMSigDB_gene == "TRUE" ~ "previously annotated",
    is.na(PTMSigDB_gene) ~ "EGF-response in this study" ),
    CST_gene = case_when(
    CST_gene == "TRUE" ~ "previously annotated",
    is.na(CST_gene) ~ "EGF-response in this study" ),
    WP437_gene = case_when(
    WP437_gene == "TRUE" ~ "previously annotated",
    is.na(WP437_gene) ~ "EGF-response in this study" )) %>% 
  distinct(gene_ref,
             # cluster,
             not_in_PSP,
             # mod_res,
           PSP_site,
           PTMSigDB_site,
           PSP_gene,
           PTMSigDB_gene,
           CST_gene,
           WP437_gene, not_in_PSP) %>% 

  
  # filter(!is.na(overlap_my_data_gene)) %>%  #remove psites not significantly regulated
  # filter(!is.na(PSP_EGF_annotated_site)) %>%  #remove psites not significantly regulated
  
  select(gene_ref, contains("min"), everything()) %>% 
  arrange( gene_ref) %>% 
  
  # mutate(
  #   mod_res = str_sub(psite, end = 1L)) %>% 

  distinct(gene_ref,
           PSP_site,
           PTMSigDB_site,
           PSP_gene,
           PTMSigDB_gene,
           CST_gene,
           WP437_gene, not_in_PSP) 



#pull out annotations from columns I want
row_annotations_condition_4xDB <- zscore_EGFR_matrix_condition_4xDB_noSD_ordered_df %>%
  # left_join(y = data_completeness_summary %>%
  #             pivot_wider(id_cols = gene_ref, names_from = condition, values_from = observed) %>%
  #             distinct(gene_ref, EGF0min, EGF1min, EGF3min, EGF5min, EGF15min),
  #           by = "gene_ref") %>% 
    # distinct(gene_ref,  overlap_my_data_gene, PSP_EGF_annotated_site, not_in_PSP) %>%
  distinct(gene_ref, PSP_site,
           PTMSigDB_site,
           PSP_gene,
           PTMSigDB_gene,
           CST_gene,
           WP437_gene, not_in_PSP) %>%
  # distinct(gene_ref, cluster, mod_res, depth, overlap_my_data) %>%
  select(  PSP_site,
           PTMSigDB_site,
           PSP_gene,
           PTMSigDB_gene,
           CST_gene,
           WP437_gene, not_in_PSP) %>%    #get rid of depth and mod_res annotations
  # select( cluster, mod_res, depth) %>%
  as.matrix()

#turn to matrix to embed row names that match to pheatmap matrix, but return to dataframe to please function.
rownames(row_annotations_condition_4xDB) <- zscore_EGFR_matrix_condition_4xDB_noSD_ordered_df$gene_ref
row_annotations_condition_4xDB <- as.data.frame(row_annotations_condition_4xDB)


# -----------------------------------------------------------------
# COLOR annotations
my_colour_4xDB_condition = list(
    # mod_res = c(S = "#440154FF", T = "#22A884FF", Y = "#FDE725FF"),
    # cluster = c('1' = "#081D58", '2' = "#225EA8", '3'= "#41B6C4", '4' = "#C7E9B4"),
    # EGF15min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF5min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF3min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF1min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # EGF0min = c("6" = "#003C30", "5" = "#01665E", "4"= "#35978F", "3" = "#80CDC1", "2" = "#D9D9D9", "1" = "#F5F5F5", "0" = "#F7F7F7"),
    # depth = c("0" = "chocolate4", "1" = "#9E0142","2" =  "#D53E4F","3" =  "#F46D43","4" =  "#FDAE61","5" =  "#FEE08B", "6" = "#FFFFBF", "7" = "#E6F598" ,"8" = "#ABDDA4" ,"9" = "#66C2A5", "10" = "#3288BD" ,"11" = "lightskyblue","12" =  "deepskyblue","13" =  "blue","14" =  "#5B12F6" ,"15" = "lightslateblue", "16" = "blueviolet", "17" =  "violet"),
    PSP_site = c("previously annotated" = "#22A884FF", "EGF-response in this study" = "#D95F02"),
    PTMSigDB_site = c("previously annotated" = "#22A884FF", "EGF-response in this study" = "#D95F02"),
    CST_gene = c("previously annotated" = "#22A200", "EGF-response in this study" = "#E99D22"),
    WP437_gene = c("previously annotated" = "#22A200", "EGF-response in this study" = "#E99D22"),
    PSP_gene = c("previously annotated" = "#22A200", "EGF-response in this study" = "#E99D22"),
    PTMSigDB_gene = c("previously annotated" = "#22A200", "EGF-response in this study" = "#E99D22"),
    not_in_PSP = c("not in PSP" = "red4"))

# -------------------------------------------------------------------------------------------------------------

#plot heatmap
zscore_EGFR_pheatmap_condition_noSD_4xDB <- pheatmap(zscore_EGFR_matrix_condition_noSD_4xDB , cluster_cols = F, cluster_rows = F,
         cutree_rows = 3, cutree_cols = 5, colorRampPalette(c("#4575B4","#91BFDB",  "ghostwhite",  "#FC8D59",  "#D73027" ))(80),
         clustering_distance_rows = "minkowski",
         
         fontsize_row = 7.5,
         annotation_row = row_annotations_condition_4xDB, annotation_colors = my_colour_4xDB_condition,
         treeheight_row = 1)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_4xDB_gene_noSD_overlap.pdf", plot = zscore_EGFR_pheatmap_condition_noSD_4xDB , width = 14, height = 60, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/pheatmap_imputed_zscore_EGFR_condition_4xDB_gene_noSD_overlap.png", plot = zscore_EGFR_pheatmap_condition_noSD_4xDB , width = 12, height = 40, scale = 0.5, limitsize = TRUE)
```


#### . . .___Fig. EV10B Gene level overlap 4x DB

try plotting gene overlaps as barplot of net degree overlaps
```{r}

total_unique_genes <- gene_list_4xDB %>% distinct(gene)

gene_overlap_4xDB_df <- gene_list_4xDB %>%
  mutate(gene_present = 1) %>% 
  pivot_wider(id_cols = gene, names_from = source, values_from = gene_present, values_fill = 0) %>% 
  group_by(gene) %>% 
  mutate(sum_overlap = sum(PSP, PTMSigDB, CST, WP437)) %>% 
  ungroup() %>% 
  group_by(sum_overlap) %>% 
  mutate(n_genes_per_overlap_extent = n()) %>% 
  ungroup()
   
  

gene_overlap_4xDB_barplot <- ggplot() +
  geom_bar(data = gene_overlap_4xDB_df, mapping = aes(x = sum_overlap)) +
  geom_text(data = gene_overlap_4xDB_df %>% distinct(sum_overlap, n_genes_per_overlap_extent),
            mapping = aes(x = sum_overlap, y = n_genes_per_overlap_extent + 15, label = n_genes_per_overlap_extent),
            size = 5,inherit.aes = FALSE) +
  ylab("unique proteins") +
  xlab("n databases\ncontain protein") +
  alexis_theme() +
  theme(axis.title.x = element_text(hjust = 0.5, vjust = 1)) +
  scale_y_continuous(breaks = c(seq(0, 400, 100)), limits = c(0, 400), expand = c(0,0))
  
gene_overlap_4xDB_barplot

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/gene_overlap_4xDB_barplot.pdf", plot = gene_overlap_4xDB_barplot , width = 6, height = 8, scale =0.4)

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/gene_overlap_4xDB_barplot.png", plot = gene_overlap_4xDB_barplot , width = 6, height = 8, scale = 0.4)
```

try plotting gene overlaps as upset plot
```{r}
gene_overlap_4xDB_upset <- gene_list_4xDB %>%
  mutate(gene_present = 1) %>% 
  pivot_wider(id_cols = gene, names_from = source, values_from = gene_present, values_fill = 0) %>% 
  select(PSP, PTMSigDB, WP437, CST) %>% 
  mutate_all(.funs = as.numeric) %>% 
  as.matrix() %>% 
  as.data.frame()

gene_overlap_4xDB_upset_plot <- upset(gene_overlap_4xDB_upset, nsets = 4, nintersects = 20, text.scale = 2)
gene_overlap_4xDB_upset_plot
```
I think upset plot is too difficult to look at and parse quickly.


##### . . . ___Fig EV10C stats

```{r}
gene_agreeement_4xDB_vs_thisstudy <- zscore_EGFR_matrix_condition_4xDB_noSD_ordered_df %>% 
  select(gene_ref, PSP_gene: WP437_gene) %>% 
  distinct()
```







####___f. depth analysis (WP437)
```{r}
# zscore_EGFR_WP437_df1_condition <- zscore_EGFR_WP437_df1_condition %>% select(gene_ref:depth)
zscore_EGFR_WP437_df1_condition_fordepthplots <- zscore_EGFR_WP437_df1_condition_noSD %>% 
  mutate(
    signal_annotation = case_when(
      depth < 10 & gene %in% c("STAT3", "STAT5B", "STAT5A", "PIAS3", "STAT1", "E2F1", "PCNA") ~ "early transcription",
      depth < 10 & gene %in% c("MAPK7", "MAP2K1", "MAP2K2", "MAPK1", "MAPK3", "MEF2A", "MEF2C", "MEF2D", "ELK4", "RPS6KA3", "CREB1", "ATF1", "ELK1", "SP1", "MAPK8", "MAPK9", "JUN", "FOS", "JUND", "FOSB") ~ "late transcription",
      depth < 10 & gene %in% c("VAV1", "VAV3", "VAV2", "RAC1", "CDC42", "ROCK1", "LMK2", "CFL1", "BCAR1", "EPS8", "RALBP1" ) ~ "regulation of\nactin polymerization",
      depth < 10 & gene %in% c("PRKCA", "PRKCI", "PRKCZ", "PRKCB", "RICTOR", "NPPL1", "PDPK1") ~ "NFKB pathway",
      depth >= 10 & gene %in% c("EGFR","IQSEC","ERRFI1","NEDD8","REPS2","GRB2","SHC1","SOS1","HRAS","AP2S1","AP2A1","AP2B1","EPS1","AP2M1","EPS15L1","EPN1",
"SYNJ1","ARF6","ASAP1","RALBP1","CAV2",
"CAV1","HGS","STAM","STAM2","STAMBP","USP8","CBL","CBLB","CBLC","ABI1","USP6NL","EPS8","RAB5A","RIN1","NEDD4","TNK2","PLSCR1","ATXN2","PLD1","ASAP1","SH3KBP1",
"ITCH","SH3GL3","INPP5D","SH3GL2","ARHGEF1","RALBP1","ARF6","EPS15") ~ "recycling | degradation",
    TRUE ~ "propagation"),
simple_annotation = case_when(
  signal_annotation == "recycling | degradation" ~ "EGFR recycling\n& degradation",
  signal_annotation == "early transcription" | signal_annotation == "late transcription" ~ "transcription\nactivation",
  signal_annotation == "regulation of\nactin polymerization"  ~ "actin\npolymerization",
  TRUE ~ "propagation"),
simple_annotation = fct_relevel(simple_annotation, "propagation", "actin\npolymerization", "transcription\nactivation" , "EGFR recycling\n& degradation"),
height = case_when(
  signal_annotation == "propagation" ~ 0.8,
  signal_annotation == "regulation of\nactin polymerization" ~ 0.8,
  signal_annotation == "NFKB pathway" ~ 0.6,
  signal_annotation == "early transcription" ~ 0.8,
  signal_annotation == "late transcription" ~ 0.8,
  signal_annotation == "recycling | degradation" ~ 0.8),
signal_annotation = fct_relevel(signal_annotation,"propagation" , "regulation of\nactin polymerization" , "NFKB pathway", "early transcription", "late transcription" , "recycling | degradation"))

#density plot ---------------------------------------------
depth_density_plot <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster))) +
  geom_density(mapping = aes(x = depth),
                             # color = cluster),
               alpha = 0.1, size = 0.5) +
  geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.02, width = 0.3, color = "black") +
  alexis_theme() +
  facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  scale_color_manual(values = c("#081D58", "#225EA8", "#41B6C4",  "#C7E9B4")) + 
  # scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  ylab("density") +
  geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0,  0.5,  1)) +
  theme(legend.position = "top",
        legend.text = element_text(size = 10)) + 
  xlab("WP437 EGFR signaling pathway depth") 

depth_density_plot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_density_plot1.png", plot = depth_density_plot , width = 16, height = 12, scale = 0.4)
```

```{r}
# zscore_EGFR_WP437_df1_condition <- zscore_EGFR_WP437_df1_condition %>% select(gene_ref:depth)


#density plot ---------------------------------------------
depth_histogram_plot <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster))) +
  geom_vline(mapping = aes(xintercept = 10), color = "grey", linetype = 2, size = 0.5) +
  geom_histogram(mapping = aes(x = depth, fill = signal_annotation), bins = 17, position = "dodge", color = "black",
                             # color = cluster),
               alpha = 1, size = 0.5) +
  # geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.02, width = 0.3, color = "black") +
  alexis_theme() +
  theme(strip.text = element_text(size= 6, family = "sans"), legend.position = "right") +
  # facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  facet_grid(cols =   vars(cluster), rows =  vars(signal_annotation)) +
  # scale_fill_brewer(palette = "Dark2") +
  scale_fill_viridis_d(option = "C") +
  # scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  # ylab("density") +
  geom_vline(mapping = aes(xintercept = 10), color = "grey", linetype = 2, size = 0.5) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  # scale_y_continuous(limits = c(0, 1), breaks = c(0,  0.5,  1)) +
  xlab("WP437 EGFR signaling pathway depth") 

depth_histogram_plot
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_histogram_plot.png", plot = depth_histogram_plot , width = 16, height = 14, scale = 0.5)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_histogram_plot.pdf", plot = depth_histogram_plot , width = 16, height = 14, scale = 0.4)
```



```{r}
#density plot ---------------------------------------------
depth_density_plot_propagation <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster)) %>% 
                               filter(simple_annotation == "propagation")) +
  geom_density(mapping = aes(x = depth),
                             # color = cluster),
               alpha = 0.1, size = 0.5) +
  geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.02, width = 0.3, color = "black") +
  alexis_theme() +
  facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  ylab("density") +
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0,  0.5,  1)) +
  xlab("WP437 EGFR signaling pathway depth") 

depth_density_plot_propagation
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_density_plot_propagation.png", plot = depth_density_plot_propagation , width = 24, height = 10, scale = 0.4)
```

```{r}
#density plot ---------------------------------------------
depth_density_plot_actin_polymerization <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster)) %>% 
                               filter(simple_annotation == "actin\npolymerization")) +
  geom_density(mapping = aes(x = depth),
                             # color = cluster),
               alpha = 0.1, size = 0.5) +
  geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.05, width = 0.3, color = "black") +
  alexis_theme() +
  facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_fill_manual(values = c(    "darkorange"  )) +
  ylab("density") +
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  scale_y_continuous(limits = c(0, 3), breaks = c(0,  1,  2, 3)) +
  xlab("WP437 EGFR signaling pathway depth") 

depth_density_plot_actin_polymerization
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_density_plot_actin_polymerization.png", plot = depth_density_plot_actin_polymerization , width = 24, height = 10, scale = 0.4)
```

```{r}
#density plot ---------------------------------------------
depth_density_plot_transcription <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster)) %>% 
                               filter(simple_annotation == "transcription\nactivation")) +
  geom_density(mapping = aes(x = depth),
                             # color = cluster),
               alpha = 0.1, size = 0.5) +
  geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.02, width = 0.3, color = "black") +
  alexis_theme() +
  facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_fill_manual(values = c(   "forestgreen", "deepskyblue")) +
  ylab("density") +
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0,  0.5,  1)) +
  xlab("WP437 EGFR signaling pathway depth") 

depth_density_plot_transcription
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_density_plot_transcription.png", plot = depth_density_plot_transcription , width = 24, height = 10, scale = 0.4)
```

```{r}
#density plot ---------------------------------------------
depth_density_plot_recycling <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster)) %>% 
                               filter(simple_annotation == "EGFR recycling\n& degradation")) +
  geom_density(mapping = aes(x = depth),
                             # color = cluster),
               alpha = 0.1, size = 0.5) +
  geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.02, width = 0.3, color = "black") +
  alexis_theme() +
  facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_fill_manual(values = c(   "blueviolet")) +
  ylab("density") +
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0,  0.5,  1)) +
  xlab("WP437 EGFR signaling pathway depth") 

depth_density_plot_recycling
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_density_plot_recycling.png", plot = depth_density_plot_recycling , width = 24, height = 10, scale = 0.4)
```


```{r}
set.seed(11)
# "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet"
# "#0D0887FF"  "#BD3786FF"  "darkorange"  "#FDC926FF" "#F0F921FF" "darkolivegreen3"
#alternative visualization ---------------------------------------------
# depth_violin_plot1 <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster))) +
depth_violin_plot1 <- ggplot() +
  geom_violin(data = zscore_EGFR_WP437_df1_condition_fordepthplots%>% mutate(cluster = as.factor(cluster)),
              mapping = aes(x = cluster, y = depth, ), draw_quantiles = c(0.25, 0.5, 0.75), size = 0.8, show.legend = FALSE) +
  # geom_violin(data = zscore_EGFR_WP437_df1_condition_fordepthplots%>% mutate(cluster = as.factor(cluster)),
  #             mapping = aes(x = cluster, y = depth, fill = signal_annotation)) +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
                filter(signal_annotation =="propagation"),
              mapping = aes(x = (cluster-0.125), y = depth), 
                            # color = signal_annotation),
              shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "#0D0887FF") +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
                
                filter(signal_annotation =="regulation of actin polymerization"),
              mapping = aes(x = (cluster + 0.125), y = depth),
                            # color = signal_annotation),
              shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "darkorange") +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
               
                filter(signal_annotation =="NFKB pathway"),
              mapping = aes(x = (cluster + 0.01), y = depth),
                            # color = signal_annotation), 
              shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "#F0F921FF") +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
                
                filter(signal_annotation =="early transcription"),
              mapping = aes(x = (cluster+ 0.01), y = depth),
                            # color = signal_annotation),
              shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "forestgreen") +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
                
                filter(signal_annotation =="late transcription"),
              mapping = aes(x = (cluster), y = depth),
                            # color = signal_annotation),
              shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "deepskyblue") +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
                
                filter(signal_annotation =="recycling | degradation"),
              mapping = aes(x = cluster, y = depth),
                            # color = signal_annotation),
              shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "blueviolet") +
  alexis_theme() +
  # facet_grid(cols = vars(cluster), rows = vars(signal_annotation)) +
  # scale_fill_manual(values = c("brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  scale_color_brewer(palette = "Dark2") +
  # scale_color_viridis_d(option = "C") +
  scale_y_reverse() +
  ylab("WP437 EGFR signaling pathway depth") 
  # scale_alpha_manual(values = c(0.1,0.1,0.1,0.1,0.1,0.1,0.1 ))
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.16, 0.16), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)

depth_violin_plot1

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_violin_plot1.png", plot = depth_violin_plot1 , width = 14, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_violin_plot1.pdf", plot = depth_violin_plot1 , width = 14, height = 10, scale = 0.4)
```
```{r}
# # library(viridis)
# plasma_colors <- viridis(n = 10, option = "plasma")
# 
# plasma_colors
# "#0D0887FF" "#47039FFF" "#7301A8FF" "#9C179EFF" "#BD3786FF" "#D8576BFF" "#ED7953FF" "#FA9E3BFF" "#FDC926FF" "#F0F921FF"
# # 
# "#0D0887FF"  "#BD3786FF"  "darkorange"  "#FDC926FF" "#F0F921FF" "darkolivegreen3"
```



```{r}
set.seed(11)
# "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet"
# "#0D0887FF"  "#BD3786FF"  "darkorange"  "#FDC926FF" "#F0F921FF" "darkolivegreen3"
#alternative visualization ---------------------------------------------
# depth_violin_plot1 <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>% mutate(cluster = as.factor(cluster))) +
depth_violin_plot2 <- ggplot() +
  geom_violin(data = zscore_EGFR_WP437_df1_condition_fordepthplots%>% mutate(cluster = as.factor(cluster)),
              mapping = aes(x = cluster, y = depth, ), draw_quantiles = c(0.25, 0.5, 0.75), size = 0.8, show.legend = FALSE) +
  geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots%>% mutate(cluster = as.factor(cluster)),
              mapping = aes(x = cluster, y = depth, fill = signal_annotation), shape = 21, alpha = 1, width = 0.3, size = 2) +
  
  # geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
  #               filter(signal_annotation =="propagation"),
  #             mapping = aes(x = (cluster-0.125), y = depth), 
  #                           # color = signal_annotation),
  #             shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "#0D0887FF") +
  # geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
  #               
  #               filter(signal_annotation =="regulation of actin polymerization"),
  #             mapping = aes(x = (cluster + 0.125), y = depth),
  #                           # color = signal_annotation),
  #             shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "darkorange") +
  # geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
  #              
  #               filter(signal_annotation =="NFKB pathway"),
  #             mapping = aes(x = (cluster + 0.01), y = depth),
  #                           # color = signal_annotation), 
  #             shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "#F0F921FF") +
  # geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
  #               
  #               filter(signal_annotation =="early transcription"),
  #             mapping = aes(x = (cluster+ 0.01), y = depth),
  #                           # color = signal_annotation),
  #             shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "forestgreen") +
  # geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
  #               
  #               filter(signal_annotation =="late transcription"),
  #             mapping = aes(x = (cluster), y = depth),
  #                           # color = signal_annotation),
  #             shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "deepskyblue") +
  # geom_jitter(data = zscore_EGFR_WP437_df1_condition_fordepthplots %>%
  #               
  #               filter(signal_annotation =="recycling | degradation"),
  #             mapping = aes(x = cluster, y = depth),
  #                           # color = signal_annotation),
  #             shape = 21, alpha = 0.2, size = 3,  width = 0.03, height = 0, color = "black", fill = "blueviolet") +
  alexis_theme() +
  # facet_grid(cols = vars(cluster), rows = vars(signal_annotation)) +
  scale_fill_manual(values = c("chartreuse4","aquamarine1", "mediumpurple3" , "firebrick",  "#FCA636FF",  "azure4")) +
  # "royalblue4", "magenta1" ,"#E16462FF","green" , "turquoise","azure3"
  # scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_y_reverse() +
  ylab("WP437 EGFR signaling pathway depth") 
  # scale_alpha_manual(values = c(0.1,0.1,0.1,0.1,0.1,0.1,0.1 ))
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.16, 0.16), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)

depth_violin_plot2

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_violin_plot2.png", plot = depth_violin_plot2 , width = 14, height = 10, scale = 0.4)
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_violin_plot2.pdf", plot = depth_violin_plot2 , width = 14, height = 10, scale = 0.4)
```
```{r}
# # # library(viridis)
# plasma_colors <- viridis(n = 10, option = "plasma")
# plasma_colors6 <- viridis(n = 6, option = "plasma")
# plasma_colors
# 
# plasma_colors6
# "aquamarine3" "mediumpurple3"  "firebrick" "darkolivegreen3" "#FCA636FF"  "azure4"
# "turquoise4" "#6A00A8FF" "#B12A90FF" "#E16462FF" "#FCA636FF" "#F0F921FF"
# "#0D0887FF" "#47039FFF" "#7301A8FF" "#9C179EFF" "#BD3786FF" "#D8576BFF" "#ED7953FF" "#FA9E3BFF" "#FDC926FF" "#F0F921FF"
# #
# "#0D0887FF"  "#BD3786FF"  "darkorange"  "#FDC926FF" "#F0F921FF" "darkolivegreen3"
```




####___g. depth analysis (WP437), minus 10 for recycling
##### . . . . ii. density faceted


```{r}
# zscore_EGFR_WP437_df1_condition <- zscore_EGFR_WP437_df1_condition %>% select(gene_ref:depth)
zscore_EGFR_WP437_df1_condition_fordepthplots_m10 <- zscore_EGFR_WP437_df1_condition_noSD %>% 
  mutate(
    signal_annotation = case_when(
      depth < 10 & gene %in% c("STAT3", "STAT5B", "STAT5A", "PIAS3", "STAT1", "E2F1", "PCNA") ~ "early transcription",
      depth < 10 & gene %in% c("MAPK7", "MAP2K1", "MAP2K2", "MAPK1", "MAPK3", "MEF2A", "MEF2C", "MEF2D", "ELK4", "RPS6KA3", "CREB1", "ATF1", "ELK1", "SP1", "MAPK8", "MAPK9", "JUN", "FOS", "JUND", "FOSB") ~ "late transcription",
      depth < 10 & gene %in% c("VAV1", "VAV3", "VAV2", "RAC1", "CDC42", "ROCK1", "LMK2", "CFL1", "BCAR1", "EPS8", "RALBP1" ) ~ "regulation of\nactin polymerization",
      depth < 10 & gene %in% c("PRKCA", "PRKCI", "PRKCZ", "PRKCB", "RICTOR", "NPPL1", "PDPK1") ~ "NFKB pathway",
      depth >= 10 & gene %in% c("EGFR","IQSEC","ERRFI1","NEDD8","REPS2","GRB2","SHC1","SOS1","HRAS","AP2S1","AP2A1","AP2B1","EPS1","AP2M1","EPS15L1","EPN1",
"SYNJ1","ARF6","ASAP1","RALBP1","CAV2",
"CAV1","HGS","STAM","STAM2","STAMBP","USP8","CBL","CBLB","CBLC","ABI1","USP6NL","EPS8","RAB5A","RIN1","NEDD4","TNK2","PLSCR1","ATXN2","PLD1","ASAP1","SH3KBP1",
"ITCH","SH3GL3","INPP5D","SH3GL2","ARHGEF1","RALBP1","ARF6","EPS15") ~ "recycling | degradation",
    TRUE ~ "propagation"),
simple_annotation = case_when(
  signal_annotation == "recycling | degradation" ~ "EGFR recycling\n& degradation",
  signal_annotation == "early transcription" | signal_annotation == "late transcription" ~ "transcription\nactivation",
  signal_annotation == "regulation of\nactin polymerization"  ~ "actin\npolymerization",
  TRUE ~ "propagation"),
simple_annotation = fct_relevel(simple_annotation, "propagation", "actin\npolymerization", "transcription\nactivation" , "EGFR recycling\n& degradation"),
height = case_when(
  signal_annotation == "propagation" ~ 0.8,
  signal_annotation == "regulation of\nactin polymerization" ~ 0.8,
  signal_annotation == "NFKB pathway" ~ 0.6,
  signal_annotation == "early transcription" ~ 0.8,
  signal_annotation == "late transcription" ~ 0.8,
  signal_annotation == "recycling | degradation" ~ 0.8),
signal_annotation = fct_relevel(signal_annotation,"propagation" , "regulation of\nactin polymerization" , "NFKB pathway", "early transcription", "late transcription" , "recycling | degradation")) %>% 
  mutate(
    depth = case_when(
      depth >= 10 ~ depth - 10,
      depth < 10 ~ depth))

#density plot ---------------------------------------------
depth_density_plot_m10 <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>% mutate(cluster = as.factor(cluster))) +
  geom_density(mapping = aes(x = depth),
                             # color = cluster),
               alpha = 0.1, size = 0.5) +
  geom_jitter(mapping = aes(x = depth, y = height, fill = signal_annotation),shape = 21,  alpha = 0.3, size = 2, height = 0.02, width = 0.3, color = "black") +
  alexis_theme() +
  facet_grid(rows = vars(cluster), cols = vars(simple_annotation)) +
  scale_color_manual(values = c("#081D58", "#225EA8", "#41B6C4",  "#C7E9B4")) + 
  # scale_color_brewer(palette = "Dark2") +
  # scale_fill_viridis_d(option = "C") +
  scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  ylab("density") +
  # geom_vline(mapping = aes(xintercept = 10), color = "deepskyblue4", linetype = 2, size = 1) +
  # geom_text(data = tibble(x = c(3, 13), y = c(0.20, 0.20), label = c("Signal propagation", "EGFR recycling\n& degradation")),
            # mapping = aes(x = x, y = y, label = label), inherit.aes = FALSE, size = 4, lineheight = 0.75)+
  scale_y_continuous(limits = c(0, 1), breaks = c(0,  0.5,  1)) +
  theme(
        panel.border = element_rect(fill = "transparent", color = "black", linewidth = 1),
        legend.position = "top",
        legend.text = element_text(size = 10),
        axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5)) + 
  xlab("WP437 EGFR signaling pathway depth") 

depth_density_plot_m10
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_density_plot1_m10.png", plot = depth_density_plot_m10 , width = 16, height = 16, scale = 0.4)
```

##### . . . . ii. violin
```{r}
depth_boxplot_plot_m10_survey <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>% mutate(cluster = as.factor(cluster))) +
  geom_violin(mapping = aes(x = cluster, y = depth), draw_quantiles = c(0.25, 0.5, 0.75), ) +
  geom_boxplot(mapping = aes(x = cluster, y = depth, fill = signal_annotation), draw_quantiles = c( 0.5),alpha= 0.5 ) +
  geom_jitter(mapping = aes(x = cluster, y = depth, fill = signal_annotation), alpha = 0.5, shape = 21, width = 0.15, size = 2) +
  scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  alexis_theme()

depth_boxplot_plot_m10_survey
```
```{r}
depth_boxplot_plot_m10 <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>% mutate(cluster = as.factor(cluster))) +
  # geom_violin(mapping = aes(x = cluster, y = depth), draw_quantiles = c(0.25, 0.5, 0.75), size = 1) +
  geom_boxplot(mapping = aes(x = cluster, y = depth), size = 1) +
  # geom_boxplot(mapping = aes(x = cluster, y = depth, fill = signal_annotation), draw_quantiles = c( 0.5),alpha= 0.5 ) +
  # geom_jitter(mapping = aes(x = cluster, y = depth, fill = signal_annotation), alpha = 0.5, shape = 21, width = 0.15, size = 2) +
  # scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  alexis_theme()

depth_boxplot_plot_m10

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/WP427_depth_boxplot_plot_m10.png", plot = depth_boxplot_plot_m10 , width = 6, height = 6, scale = 0.4)
```

```{r}
# install.packages("MKmisc")
# library(MKmisc)

```

stats for boxplot
```{r}
stats_depth_cluster <- zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>%
  distinct(gene_ref, cluster) %>% 
  group_by(cluster) %>% 
  summarize(
    n_generef_per_cluster = n()) %>% 
  ungroup()
  
stats_depth_cluster

#t-test (moderated)-----------------------------

cluster_depth_matrix_inputdf <- zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>% 
  distinct(gene_ref, cluster, depth) %>%
  mutate(cluster = as.factor(cluster)) %>%
  group_by() %>% 
  pivot_wider(id_cols = gene_ref, names_from = cluster, values_from = depth)


cluster1_depths <- zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>%
  filter(cluster == "1") %>%
  distinct(gene_ref, depth)

cluster2_depths <- zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>%
  filter(cluster == "2") %>%
  distinct(gene_ref, depth)

cluster3_depths <- zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>%
  filter(cluster == "3") %>%
  distinct(gene_ref, depth)


cluster4_depths <- zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>%
  filter(cluster == "4") %>%
  distinct(gene_ref, depth)

ttest_cluster1vs2 <- t.test(x = cluster1_depths$depth, y = cluster2_depths$depth, var.equal = FALSE)
ttest_cluster1vs2

ttest_cluster1vs3 <- t.test(x = cluster1_depths$depth, y = cluster3_depths$depth, var.equal = FALSE)
ttest_cluster1vs3

ttest_cluster1vs4 <- t.test(x = cluster1_depths$depth, y = cluster4_depths$depth, var.equal = FALSE)
ttest_cluster1vs4

ttest_cluster2vs4 <- t.test(x = cluster2_depths$depth, y = cluster4_depths$depth, var.equal = FALSE)
ttest_cluster2vs4

ttest_cluster3vs4 <- t.test(x = cluster3_depths$depth, y = cluster4_depths$depth, var.equal = FALSE)
ttest_cluster3vs4

ttest_cluster2vs3 <- t.test(x = cluster2_depths$depth, y = cluster3_depths$depth, var.equal = FALSE)
ttest_cluster2vs3

# ttest_cluster1vs2 <- mod.t.test(x = x, group = g, adjust.method = "BH", paired = FALSE)
```



```{r}
depth_boxplot_plot_m10_separatefxns <- ggplot(data = zscore_EGFR_WP437_df1_condition_fordepthplots_m10 %>% mutate(cluster = as.factor(cluster))) +
  # geom_violin(mapping = aes(x = cluster, y = depth), draw_quantiles = c(0.25, 0.5, 0.75), ) +
  geom_boxplot(mapping = aes(x = cluster, y = depth, fill = signal_annotation), draw_quantiles = c( 0.5),alpha= 0.5 ) +
  # geom_jitter(mapping = aes(x = cluster, y = depth, fill = signal_annotation), alpha = 0.5, shape = 21, width = 0.15, size = 2) +
  scale_fill_manual(values = c(  "brown",  "darkorange"  , "#F0F921FF", "forestgreen", "deepskyblue", "blueviolet")) +
  alexis_theme()

depth_boxplot_plot_m10_separatefxns
```

#END OF IMPUTATIONS
##===============================
##===============================
##===============================


#22. PHOSPHO SIGNALING PATHWAY OVERLAPS
##_a) EGFR
```{r}
ascore_EGFR1_PTMSEA <- ascore_fasta_protein_mod_loc_pY_sum_psite %>%
  separate(ref, into = c("reference2", "psite"), sep = "_", remove = FALSE) %>% 
  select(-reference2) %>% 
  left_join(y = fasta_gene_names %>% rename(reference = entry) %>% select(reference, gene, protein_names, keyword_id), by = "reference") %>% 
  full_join(y = EGFR1_pathway_PTMSigDB %>%
              mutate(psite = paste0(mod_res, mod_residue)),
            by = c("gene", "reference", "mod_res", "psite"), relationship = "many-to-many") %>% 
mutate(PTM_SEA = case_when(
  is.na(PTM_SEA) ~ FALSE, 
  TRUE ~ TRUE)) %>%   
mutate(
    overlap = case_when(
    !is.na(condition) & PTM_SEA == TRUE ~ "both",
    PTM_SEA == TRUE ~ "literature",
    PTM_SEA == FALSE  ~ "my data")) %>%
  distinct(overlap, gene, psite, mod_res)
  
```

##_b) pSTY sites in EGFR annotated pathway from PTMSEA
```{r}
plot_PTMSEA_EGFR_pathway_modres <- ggplot(data = EGFR1_pathway_PTMSigDB %>%
                                            mutate(psite = paste0(mod_res, mod_residue)) %>%
                                            distinct(gene, psite, mod_res)) +
  geom_bar(mapping = aes(x = mod_res, fill = mod_res), color = "black", size = 0.5, show.legend = FALSE) +
  alexis_theme() +
  theme(axis.text.x = element_text(angle = 0, size = 12, hjust = 0.5)) +
  scale_fill_viridis_d(direction = -1) +
  ggtitle(label = "PTM-SEA: EGFR pathway \np-site distribution") +
  ylab("unique gene + p-site")
  

plot_PTMSEA_EGFR_pathway_modres

ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/literature_PTMSEA_EGFR_pathway_modres_distribution.png", plot = plot_PTMSEA_EGFR_pathway_modres, width = 6, height = 6, scale = 0.4)
```


##_c) overlaps by protein + site
```{r}
EGFR1_overlaps <- ascore_EGFR1_PTMSEA %>% 
  distinct(overlap, gene, psite, mod_res)

#plot overlaps count of psites in my data vs. PTMSEA EGFR1 pathway
EGFR1_psite_overlaps <- ggplot(data = EGFR1_overlaps %>% filter(mod_res == "Y")) +
  geom_bar(mapping = aes(x = overlap, fill = mod_res), color = "black", size = 0.5) +
  scale_fill_viridis_d(direction = -1) +
  alexis_theme() +
  scale_y_continuous(expand = c(0,0)) +
  # expand_limits(y = c(0, 500)) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) +
  ylab("unqiue p-sites")


EGFR1_psite_overlaps


ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/EGFR1_psite_overlaps_pY.png", plot = EGFR1_psite_overlaps,
       scale = 0.4, width = 8, height = 6)

```
still some pY sites to identify that we could not identify with just global phospho enrichment alone.

##_d) overlaps by protein
```{r}

ascore_EGFR1_PTMSEA_protein <- ascore_fasta_protein_mod_loc_pY_sum_psite %>% 
  left_join(y = fasta_gene_names %>% rename(reference = entry) %>% select(reference, gene, protein_names, keyword_id), by = "reference") %>%
  full_join(y = EGFR1_pathway_PTMSigDB %>% select(gene, PTM_SEA) , by = c("gene"), relationship = "many-to-many") %>%
  
  mutate(PTM_SEA = case_when(
  is.na(PTM_SEA) ~ FALSE, 
  TRUE ~ TRUE)) %>% 
  
  mutate(overlap = case_when(
    !is.na(condition) & PTM_SEA == TRUE ~ "both",
    is.na(condition) & PTM_SEA == TRUE ~ "literature",
    !is.na(condition) & PTM_SEA == FALSE  ~ "my data"))

EGFR1_overlaps_protein <- ascore_EGFR1_PTMSEA_protein %>% 
  distinct(overlap, gene)

#plot overlaps count of psites in my data vs. PTMSEA EGFR1 pathway
EGFR1_overlaps_protein <- ggplot(data = EGFR1_overlaps_protein) +
  geom_bar(mapping = aes(x = overlap)) +
  alexis_theme() +
  scale_y_continuous(expand = c(0,0)) +
  expand_limits(y = c(0, 1000)) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) +
  ylab("unqiue p-proteins")


EGFR1_overlaps_protein


ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/EGFR1_overlaps_protein.png", plot = EGFR1_overlaps_protein,
       scale = 0.4, width = 6, height = 8)

#plot
# plot_intensity_psites_EGFR1 <- ggplot(data = EGFR1_overlaps) +
#   geom_boxplot(mapping = aes())
```
##_e) overlaps by protein + site
```{r}
EGFR1_overlaps <- ascore_EGFR1_PTMSEA %>% 
  distinct(overlap, gene, psite, mod_res)

#plot overlaps count of psites in my data vs. PTMSEA EGFR1 pathway
EGFR1_psite_overlaps <- ggplot(data = EGFR1_overlaps) +
  geom_bar(mapping = aes(x = overlap, fill = mod_res)) +
  scale_fill_viridis_d(direction = -1) +
  alexis_theme() +
  scale_y_continuous(expand = c(0,0), limits = c(0, 1000)) +
  # expand_limits(y = c(0, 12000)) +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) +
  ylab("unqiue p-sites")
EGFR1_psite_overlaps
ggsave(filename = "output/MainFig3to6_SuppFig9to15/pTyrSiteLevel/EGFR1_psite_overlaps.png", plot = EGFR1_psite_overlaps,
       scale = 0.4, width = 6, height = 8)

#plot
# plot_intensity_psites_EGFR1 <- ggplot(data = EGFR1_overlaps) +
#   geom_boxplot(mapping = aes())
```


#20. PTM NAVIGATOR


##a) write_csv for input to PTMNavigator

###_i. not imputed


```{r}
PTMNav_psite_input <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  
  #select only comparisons relative to 0 min:
  filter(comparison %in% c("EGF15min_vs_EGF0min",
                           "EGF5min_vs_EGF0min",
                           "EGF3min_vs_EGF0min",
                           "EGF1min_vs_EGF0min")) %>%
  
  #flip direction of fold change and label for 15 min vs. 0 min:
  mutate(diff = case_when(
    comparison == "EGF15min_vs_EGF0min" ~ -diff,
    TRUE ~ diff)) %>% 
  mutate(comparison = case_when(
    comparison == "EGF15min_vs_EGF0min" ~ "EGF15min_vs_EGF0min", 
    TRUE ~ comparison)) %>% 
  
  distinct(reference, psite, comparison, diff, adj_pval) %>%
  filter(!is.na(reference)) %>% 
  mutate(
    regulation = case_when(
      adj_pval <= 0.05 & diff > 0 ~ "up",
      adj_pval <= 0.05 & diff < 0 ~ "down",
      adj_pval > 0.05 ~ "") )


colnames(PTMNav_psite_input) <- c("Protein IDs", "p-site", "Experiment", "Fold change", "adjusted pvalue", "Regulation")

write_csv(x = PTMNav_psite_input, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/PTMNav_psite_input.csv")
```

###_i. imputed


```{r}
PTMNav_psite_input_imputed <- psite_diff_abundance_gene_2xDB_imputed_forvolcano %>%
  
  left_join(y = ascore_gene_clusters_Imputation_noSD %>%
              
              select(gene_ref, reference, psite) %>% 
              mutate(
                gene_ref = str_replace_all(gene_ref, " ", "_") ), by = c("gene_ref", "psite", "reference")) %>%
  # rename(modres_position = psite) %>% 
  
  
  #select only comparisons relative to 0 min:
  filter(comparison %in% c("EGF15min_vs_EGF0min",
                           "EGF5min_vs_EGF0min",
                           "EGF3min_vs_EGF0min",
                           "EGF1min_vs_EGF0min")) %>%
  
 
  
  distinct(reference, psite, comparison, diff, adj_pval) %>%
  filter(!is.na(reference)) %>% 
  mutate(
    regulation = case_when(
      adj_pval <= 0.05 & diff > 1 ~ "up",
      adj_pval <= 0.05 & diff < -1 ~ "down",
      adj_pval > 0.05 ~ "") )


colnames(PTMNav_psite_input_imputed) <- c("Protein IDs", "p-site", "Experiment", "Fold change", "adjusted pvalue", "Regulation")

write_csv(x = PTMNav_psite_input_imputed, file = "modified_data/MainFig3to6_SuppFig9to15/pTyrSiteLevel/PTMNav_psite_input_imputed.csv")
```
B9A884F47F5E9DC8FD52DC172A61AF41
